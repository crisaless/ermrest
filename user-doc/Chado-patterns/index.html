<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Chado Vocabulary Patterns - ERMrest API Documentation</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  <link href="../../css/extra.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Chado Vocabulary Patterns";
    var mkdocs_page_input_path = "user-doc/Chado-patterns.md";
    var mkdocs_page_url = "/user-doc/Chado-patterns/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> ERMrest API Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Welcome to the documentation</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">User Docs</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../install-centos7/">Installing on CentOS 7</a>
                </li>
                <li class="">
                    
    <a class="" href="../install-ubuntu1204/">Installing on Ubuntu 12.04</a>
                </li>
                <li class="">
                    
    <a class="" href="../acls/">ERMrest Access Control</a>
                </li>
                <li class="">
                    
    <a class="" href="../row-level-security/">Row-Level Authorization</a>
                </li>
                <li class="">
                    
    <a class="" href="../tuning/">Performance Tuning</a>
                </li>
                <li class="">
                    
    <a class="" href="../annotation/">Model Annotation</a>
                </li>
                <li class="">
                    
    <a class="" href="../ermrest-registry-purge/">ermrest-registry-purge</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Chado Vocabulary Patterns</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#chado-vocabulary-patterns">Chado Vocabulary Patterns</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#assumptions-and-conventions">Assumptions and conventions</a></li>
        
            <li><a class="toctree-l4" href="#chado-derived-core-tables">Chado-derived core tables</a></li>
        
            <li><a class="toctree-l4" href="#domain-tables">Domain tables</a></li>
        
            <li><a class="toctree-l4" href="#domain-path-tables">Domain path tables</a></li>
        
            <li><a class="toctree-l4" href="#data-tables-using-controlled-terms">Data tables using controlled terms</a></li>
        
            <li><a class="toctree-l4" href="#heuristics-and-idioms">Heuristics and idioms</a></li>
        
            <li><a class="toctree-l4" href="#open-questions">Open questions</a></li>
        
            <li><a class="toctree-l4" href="#implementation">Implementation</a></li>
        
        </ul>
    

    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">ERMrest API</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../api-docs/">Guide to the ERMrest API</a>
                </li>
                <li class="">
                    
    <a class="" href="../../api-docs/model/naming/">ERMrest Model Resource Naming</a>
                </li>
                <li class="">
                    
    <a class="" href="../../api-docs/model/rest/">ERMrest Model Operations</a>
                </li>
                <li class="">
                    
    <a class="" href="../../api-docs/data/naming/">ERMrest Data Resource Naming</a>
                </li>
                <li class="">
                    
    <a class="" href="../../api-docs/data/rest/">ERMrest Data Operations</a>
                </li>
                <li class="">
                    
    <a class="" href="../../api-docs/rest-catalog/">ERMrest Catalog Operations</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">ERMrest API Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>User Docs &raquo;</li>
        
      
    
    <li>Chado Vocabulary Patterns</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <div class="toc">
<ul>
<li><a href="#chado-vocabulary-patterns">Chado Vocabulary Patterns</a><ul>
<li><a href="#assumptions-and-conventions">Assumptions and conventions</a></li>
<li><a href="#chado-derived-core-tables">Chado-derived core tables</a><ul>
<li><a href="#db">db</a></li>
<li><a href="#cv">cv</a></li>
<li><a href="#dbxref">dbxref</a></li>
<li><a href="#cvterm">cvterm</a></li>
<li><a href="#cvtermpath">cvtermpath</a></li>
</ul>
</li>
<li><a href="#domain-tables">Domain tables</a></li>
<li><a href="#domain-path-tables">Domain path tables</a></li>
<li><a href="#data-tables-using-controlled-terms">Data tables using controlled terms</a></li>
<li><a href="#heuristics-and-idioms">Heuristics and idioms</a><ul>
<li><a href="#basic-data-access">Basic data access</a></li>
<li><a href="#data-integrity-and-basic-value-enumeration">Data integrity and basic value enumeration</a></li>
<li><a href="#prettier-term-display">Prettier term display</a></li>
<li><a href="#semantic-search-via-transitive-closures">Semantic search via transitive closures</a></li>
</ul>
</li>
<li><a href="#open-questions">Open questions</a><ul>
<li><a href="#should-we-differentiate-between-different-types-of-synonyms">Should we differentiate between different types of synonyms?</a></li>
<li><a href="#which-alternate-dbxrefs-should-be-included-in-the-cvterm-table">Which alternate dbxrefs should be included in the cvterm table?</a></li>
<li><a href="#what-dbxrefs-should-appear-in-the-domain-table">What dbxrefs should appear in the domain table?</a></li>
<li><a href="#second-thoughts-about-arrays-in-cvterm">Second thoughts about arrays in cvterm</a></li>
</ul>
</li>
<li><a href="#implementation">Implementation</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="chado-vocabulary-patterns">Chado Vocabulary Patterns<a class="headerlink" href="#chado-vocabulary-patterns" title="Permanent link">&para;</a></h1>
<p>This page is to explore some possible use-case patterns for using
Chado schema for controlled vocabularies.</p>
<h2 id="assumptions-and-conventions">Assumptions and conventions<a class="headerlink" href="#assumptions-and-conventions" title="Permanent link">&para;</a></h2>
<ol>
<li>We want to load ontologies easily, so being consistent with Chado is probably helpful.</li>
<li>We want to separate ontology/vocabulary preparation from normal data management operations</li>
<li>Vocabularies and terms are defined <em>before</em> use in data tables</li>
<li>Restricted domain tables are used to present subsets of ontologies for use in data columns</li>
<li>Data serialization should not depend on order vocabularies are loaded</li>
<li>We will use the dbxref concept specifically with <em>DB</em> <code>:</code> <em>ACCESSION</em> <code>:</code> <em>VERSION</em> textual formatted indentifiers as keys and foreign keys in vocabulary storage columns, e.g. <code>OBO_REL:is_a:</code>.</li>
</ol>
<h2 id="chado-derived-core-tables">Chado-derived core tables<a class="headerlink" href="#chado-derived-core-tables" title="Permanent link">&para;</a></h2>
<p>Assume a basic ontology storage area similar to
<a href="http://gmod.org/wiki/Chado_CV_Module">Chado CV Module</a>.  Here, we
only focus on the few tables that would affect normal data
management.</p>
<h3 id="db">db<a class="headerlink" href="#db" title="Permanent link">&para;</a></h3>
<p>The <code>db</code> table enumerates database authorities.</p>
<pre><code>CREATE TABLE db (
  name text PRIMARY KEY,
  description text,
  urlprefix text,
  url text
  );

</code></pre>

<h3 id="cv">cv<a class="headerlink" href="#cv" title="Permanent link">&para;</a></h3>
<p>The <code>cv</code> table enumerates controlled vocabularies.</p>
<pre><code>CREATE TABLE cv (
  name text PRIMARY KEY,
  definition text
);

</code></pre>

<h3 id="dbxref">dbxref<a class="headerlink" href="#dbxref" title="Permanent link">&para;</a></h3>
<p>The <code>dbxref</code> table enumerates global, unique, stable public identifiers. This table probably won't be used in day-to-day
queries because the db, accession, and version are included in denormalized form elsewhere; it's included in the model
because this is the only place the dbxref <code>description</code> field exists.</p>
<pre><code>CREATE TABLE dbxref (
  name text PRIMARY KEY,
  db text NOT NULL REFERENCES db(name) DEFERRABLE,
  accession text NOT NULL,
  version text NOT NULL DEFAULT '',
  description text,
  UNIQUE(db, accession, version)
);
</code></pre>

<h3 id="cvterm">cvterm<a class="headerlink" href="#cvterm" title="Permanent link">&para;</a></h3>
<p>The <code>cvterm</code> table enumerates all available terms. In addition to denormalizing the <code>dbxref</code> and <code>cv</code> fields, we've
added a <code>dbxref_unversioned</code> field (the dbxref without version information, which is likely to be searched for) and
array fields for synonyms and alternate dbxrefs (derived from the chado <code>cvtermsynonym</code> and <code>cvterm_dbxref</code> tables).</p>
<pre><code>create table cvterm (
  dbxref text PRIMARY KEY REFERENCES dbxref(name) DEFERRABLE,
  dbxref_unversioned text NOT NULL,
  cv text NOT NULL REFERENCES cv(name) DEFERRABLE,
  name text NOT NULL,
  definition text,
  is_obsolete boolean NOT NULL,
  is_relationshiptype boolean NOT NULL,
  synonyms text[],
  alternate_dbxrefs text[],
  UNIQUE(cv, name, is_obsolete),
  CHECK(dbxref LIKE dbxref_unversioned || ':%')
);
</code></pre>

<h3 id="cvtermpath">cvtermpath<a class="headerlink" href="#cvtermpath" title="Permanent link">&para;</a></h3>
<p>The <code>cvtermpath</code> table stores transitive closures of term-to-term relationship graphs.
The <code>cvtermpath_id</code> field is present only because ermrest requires a single-valued unique key.</p>
<pre><code>CREATE TABLE cvtermpath (
  cvtermpath_id bigserial PRIMARY KEY,
  type_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,
  subject_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,
  object_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,
  pathdistance integer NOT NULL,
  UNIQUE(type_dbxref, subject_dbxref, object_dbxref)
);  
</code></pre>

<p>We constrain the path table:</p>
<ol>
<li>Don't allow NULL <code>type_dbxref</code> which is a closure over multiple relationships</li>
<li>Don't store multiple rows for same subject, relationship, object. Store <em>minimum</em> path distance.</li>
</ol>
<h2 id="domain-tables">Domain tables<a class="headerlink" href="#domain-tables" title="Permanent link">&para;</a></h2>
<p>We can have any number of domain tables to enumerate a subset of
controlled vocabulary terms. Each domain table is a filtered subset of
<code>cvterm</code> with the same structure. A domain table could be implemented as
materialized views defined with <code>create materialized view mydomain1 as select * from cvterm where ...</code>,
as tables curated by hand, etc.</p>
<pre><code>CREATE TABLE mydomain1 (
  cvtermpath_id bigserial PRIMARY KEY,
  type_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,
  subject_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,
  object_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,
  pathdistance integer NOT NULL,
  UNIQUE(type_dbxref, subject_dbxref, object_dbxref)
);
</code></pre>

<p>We want a foreign key reference constraint to emphasize that the domain table is a proper subset of the core cvterm table.</p>
<h2 id="domain-path-tables">Domain path tables<a class="headerlink" href="#domain-path-tables" title="Permanent link">&para;</a></h2>
<p>For each domain table, we will have a corresponding table defined as a subset of
<code>cvtermpath</code> with all records that include any term in the domain table. For example,
a domain path table could be defined with</p>
<pre><code>create materialized view mydomain1_path as
  select * from cvtermpath p
  join mydomain1 d on d.dbxref = p.subject_dbxref or d.dbxref = p.object_dbxref;
</code></pre>

<h2 id="data-tables-using-controlled-terms">Data tables using controlled terms<a class="headerlink" href="#data-tables-using-controlled-terms" title="Permanent link">&para;</a></h2>
<p>We can use controlled vocabularies for any number of data columns by
configuring a foreign key constraint to a domain table.</p>
<pre><code>CREATE TABLE mydata (
   ...
   myconcept text REFERENCES mydomain1 (dbxref),
   ...
);
</code></pre>

<h2 id="heuristics-and-idioms">Heuristics and idioms<a class="headerlink" href="#heuristics-and-idioms" title="Permanent link">&para;</a></h2>
<h3 id="basic-data-access">Basic data access<a class="headerlink" href="#basic-data-access" title="Permanent link">&para;</a></h3>
<p>Naive access to data tables can completely ignore the connections to a
vocabulary and just consume the stored data column as explicit dbxref
strings.</p>
<h3 id="data-integrity-and-basic-value-enumeration">Data integrity and basic value enumeration<a class="headerlink" href="#data-integrity-and-basic-value-enumeration" title="Permanent link">&para;</a></h3>
<p>Any consumer can introspect the data table and understand the foreign
key constraint to see which dbxref values are allows in a data
column. The database will enforce the foreign key integrity to prevent
values from being added to a data column outside the configured domain
term set.</p>
<h3 id="prettier-term-display">Prettier term display<a class="headerlink" href="#prettier-term-display" title="Permanent link">&para;</a></h3>
<p>Because the domain table uses the same schema as the core cvterm table,
it includes definitions and other metadata. Some presentation customization
can be done based on this information alone. However, there might be more
vocabulary-aware UX features desired in some cases?</p>
<p>Options:</p>
<ol>
<li>Use normal Chaise/annotation features to adjust domain table "row name".</li>
<li>Detect fkey chain to core cvterm table to enable special vocabulary functions?</li>
<li>Annotate domain tables to enable special vocabulary functions?</li>
</ol>
<h3 id="semantic-search-via-transitive-closures">Semantic search via transitive closures<a class="headerlink" href="#semantic-search-via-transitive-closures" title="Permanent link">&para;</a></h3>
<p>Any consumer can recognize the foreign key chain, through domain
table, to the <code>cvterm</code> table and the presence of the <code>cvtermpath</code>
table encoding inter-term relationships.</p>
<p>A phase 1 joined query similar to this ERMrest URL can be used to
search for a set of terms:</p>
<pre><code>/catalog/N/attribute/P:=cvtermpath/T:=(type_id)/dbxref=REL/pathdistance::lt::10/$P/O:=(object_id)/dbexref=BOUND/S:=(subject_id)/mydomain1/dbxref
</code></pre>

<p>This query would return a set of distinct dbxref values that are less
than <code>10</code> hops below an upper-bound dbxref <code>BOUND</code> in the graph of
<code>REL</code> relationship (mixed-in with <code>OBO_REL:is_a</code> (subclass)
relationship but only if the output terms also appear in the term
domain <code>mydomain1</code> which is a subset of all possible terms in the
system.</p>
<p>A phase 2 search can express actual data column constraints to match
on a disjunctive list of terms found by the phase 1 search.  Even if
we implement this on the server, we'd probably do the same two-phase
search, to in-line the bounded term set as a disjunction of constants
(that's our experience with how to get high performance out of
Postgres for complex analytic queries).</p>
<p>Options:</p>
<ol>
<li>Do both search phases on client side with no new ERMrest API
   features.  Might hit some URL length limits eventually.</li>
<li>Add a filter syntax to ERMrest API to allow the query triplet of
   (term domain, relationship, and boundary to be encoded as a direct
   predicate on a data column.  E.g. <code>column::relationship::boundary</code></li>
</ol>
<p>Discussion:</p>
<p>To add a query syntactic sugar to ERMrest, we'd need to hard-code a
mapping of directed relationship terms, e.g. <code>OBO_REL:is_a</code>, to new
ERMrest predicate operators, e.g. <code>::subclass_of::</code> and
<code>::has_subclass::</code> so we can express both upper and lower-bounded
constraints against a data column. The right-hand side of the
predicate would specify the boundary value as a dbxref string
(URL-encoded to escape the colon chars). With this sugar, the
<code>pathdistance</code> would not be able to be constrained since there is no
reasonable binary predicate syntax to combine relationship type,
boundary, and path-length.</p>
<p>To provide a GUI UX for semantic search, you probably need more than
to choose a relationship and type in dbxref boundary values. You
probably need the equivalent of the phase 1 search to show the user
how the term space expands from a particular combination of boundary
and relationship type while still being limited to the column's term
domain.  In order to present such a UX, you already have to have
client-side detection and awareness of when semantic search is
applicable as well as how to retrieve and preview these term
sub-graphs.</p>
<p>Assuming all the client-side work for a semantic search UX, it is not
clear what value the ERMrest syntactic sugar would add except
robustness against large term sets being encoded in URLs. The
client-side complexity does not change much as long as you need to
guide users through a query-construction UX...</p>
<h2 id="open-questions">Open questions<a class="headerlink" href="#open-questions" title="Permanent link">&para;</a></h2>
<h3 id="should-we-differentiate-between-different-types-of-synonyms">Should we differentiate between different types of synonyms?<a class="headerlink" href="#should-we-differentiate-between-different-types-of-synonyms" title="Permanent link">&para;</a></h3>
<p>Currently, all synonyms included in the <code>cvtermsynonym</code> table are included in the <code>synonyms</code> field of <code>cvterm</code>.
Synonyms can be of different types, however, and we may want to treat synonyms differently based on their type.
To facilitate discussion, I've included the <code>cvtermsynonym</code> table (denormalized for our-style foreign keys),
which includes all synonyms and their types:</p>
<pre><code>create table cvtermsynonym (
  cvtermsynonym_id bigserial PRIMARY KEY,
  dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,
  synonym text NOT NULL,
  synonym_type text,
  UNIQUE (dbxref, synonym)
);
</code></pre>

<h3 id="which-alternate-dbxrefs-should-be-included-in-the-cvterm-table">Which alternate dbxrefs should be included in the cvterm table?<a class="headerlink" href="#which-alternate-dbxrefs-should-be-included-in-the-cvterm-table" title="Permanent link">&para;</a></h3>
<p>Chado has a table called <code>cvterm_dbxref</code> which includes both external
dbxrefs and dbxrefs that are used for provenance
information. Currently, we include both in the <code>alternate_dbxrefs</code>
field of the <code>cvterm</code> database. To facilitate discussion, I've
included the <code>cvterm_dbxref</code> table (denormalized for our-style foreign
keys):</p>
<pre><code>CREATE TABLE cvterm_dbxref (
  cvterm_dbxref_id bigserial PRIMARY KEY,
  cvterm text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,
  alternate_dbxref text NOT NULL REFERENCES dbxref(name) DEFERRABLE,
  is_for_definition boolean,
  UNIQUE(primary_dbxref, alternate_dbxref)
);
</code></pre>

<h3 id="what-dbxrefs-should-appear-in-the-domain-table">What dbxrefs should appear in the domain table?<a class="headerlink" href="#what-dbxrefs-should-appear-in-the-domain-table" title="Permanent link">&para;</a></h3>
<p>Our current model specifies that domain tables should have the same format as <code>cvterm</code> tables, with the <code>dbxref</code> field a foreign
key to the <code>cvterm</code> table. For example, one entry from Uberon looks like this:</p>
<pre><code>dbxref              | UBERON:0000006:
dbxref_unversioned  | UBERON:0000006
cv                  | uberon
name                | islet of Langerhans
definition          | the clusters of hormone-producing cells that are scattered throughout the pancreas
is_obsolete         | f
is_relationshiptype | f
synonyms            | {&quot;pancreatic islet&quot;,&quot;pancreatic insula&quot;,&quot;islets of Langerhans&quot;,&quot;island of pancreas&quot;,&quot;island of Langerhans&quot;}
alternate_dbxrefs   | {XAO:0000159:,VHOG:0000646:,UMLS:C0022131:,MIAA:0000076:,MESH:D007515:,MAT:0000076:,
                       URL:http://linkedlifedata.com/resource/umls/id/C0022131:,
               URL:http://en.wikipedia.org/wiki/Islets_of_Langerhans:,GAID:324:,FMA:16016:,EV:0100130:,EMAPA:32927:,
               EFO:0000856:,CALOHA:TS-0741:,BTO:0000991:,AAO:0010406:,NULL:C12608:,MP:0005215:,MESH:A03.734.414:,MA:0000127:}
</code></pre>

<p>A GUDMAP user is more likely to want to look for EMAPA:32927 than any
of the dbxrefs in this entry (<code>alternate_dbxrefs</code> includes the
versioned version EMAPA:32927:). It might make more sense for the
<code>dbxref_unversioned</code> column of the domain table to include the
unversioned dbxref that users are most likely to recognize, like this:</p>
<pre><code>dbxref              | UBERON:0000006:
dbxref_unversioned  | EMAPA:32927
cv                  | uberon
name                | islet of Langerhans
definition          | the clusters of hormone-producing cells that are scattered throughout the pancreas
is_obsolete         | f
is_relationshiptype | f
synonyms            | {&quot;pancreatic islet&quot;,&quot;pancreatic insula&quot;,&quot;islets of Langerhans&quot;,&quot;island of pancreas&quot;,&quot;island of Langerhans&quot;}
alternate_dbxrefs   | {XAO:0000159:,VHOG:0000646:,UMLS:C0022131:,MIAA:0000076:,MESH:D007515:,MAT:0000076:,
                       URL:http://linkedlifedata.com/resource/umls/id/C0022131:,
               URL:http://en.wikipedia.org/wiki/Islets_of_Langerhans:,GAID:324:,FMA:16016:,EV:0100130:,EMAPA:32927:,
               EFO:0000856:,CALOHA:TS-0741:,BTO:0000991:,AAO:0010406:,NULL:C12608:,MP:0005215:,MESH:A03.734.414:,MA:0000127:}
</code></pre>

<p>If we do this, we might want to change the name <code>dbxref_unversioned</code> to something like <code>dbxref_common</code>.</p>
<h3 id="second-thoughts-about-arrays-in-cvterm">Second thoughts about arrays in cvterm<a class="headerlink" href="#second-thoughts-about-arrays-in-cvterm" title="Permanent link">&para;</a></h3>
<p>In Postgres, there are two equivalent ways to express "'foo' is an element of the array bar" in a query:</p>
<pre><code>'foo' = ANY(bar)
</code></pre>

<p>or</p>
<pre><code>'{foo}' &lt;@ bar
</code></pre>

<p>The second form will take advantage of gin indexes; the first form will not. Pattern matching is also difficult on array elements.
We might want to consider dropping the array columns from <code>cvterm</code> and using <code>cvtermsynonym</code> and <code>cvterm_dbxref</code> instead.</p>
<h2 id="implementation">Implementation<a class="headerlink" href="#implementation" title="Permanent link">&para;</a></h2>
<p>See the <a href="https://github.com/informatics-isi-edu/data-commons/tree/master/chado">data commons chado directory</a> for
scripts to create a data_commons schema and pull data from chado into those tables. See the
<a href="https://github.com/informatics-isi-edu/data-commons/tree/master/chado/obo">data commons chado/obo directory</a>
for information about reading obo files into standard chado tables.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../api-docs/" class="btn btn-neutral float-right" title="Guide to the ERMrest API">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../ermrest-registry-purge/" class="btn btn-neutral" title="ermrest-registry-purge"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Copyright &copy; 2018 <a href="http://github.com/informatics-isi-edu/ermrest">ERMrest Project</a>.</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../ermrest-registry-purge/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../api-docs/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/require.js"></script>
      <script src="../../search/search.js"></script>

</body>
</html>
