{
    "docs": [
        {
            "location": "/", 
            "text": "ERMrest Documentation\n\uf0c1\n\n\nTBD", 
            "title": "Welcome to the documentation"
        }, 
        {
            "location": "/#ermrest-documentation", 
            "text": "TBD", 
            "title": "ERMrest Documentation"
        }, 
        {
            "location": "/user-doc/install-centos7/", 
            "text": "ERMrest Installation (CentOS 7)\n\uf0c1\n\n\nThis guide provides instructions for installing ERMrest on the CentOS 7.x Linux\ndistribution.\n\n\nPrerequisites\n\uf0c1\n\n\nERMrest depends on the following prerequisites:\n- CentOS 7.x\n- EPEL 7 repository\n- PostgreSQL 9.4 or above (note: we recommend latest stable version)\n- WebAuthn\n\n\nThis guide assumes only that you have installed the CentOS 7.x Linux\ndistribution. See http://www.centos.org for more information.\n\n\nIn this document, commands that begin with \n#\n should be run as root or with\nsuper user privileges (\nsudo\n). Commands that begin with \n$\n may be run as a\nnormal user.\n\n\nExtended Packages for Enterprise Linux (EPEL)\n\uf0c1\n\n\nRun the following commands to install the EPEL repository.\n\n\n# rsync -v rsync://mirrors.kernel.org/fedora-epel/7/x86_64/e/epel-release*.rpm .\n# dnf install epel-release*.rpm\n\n\n\n\nPostgreSQL 9.4 or above\n\uf0c1\n\n\nPostgreSQL must be installed and configured to operate within the\n\nSE-Linux\n access control mechanism.  We recommend using the latest\nstable release, i.e. Postgres 9.5 at time of writing.\n\n\n\n\nInstall the PostgreSQL 9.x repository.\n\n\n\n\nCheck the list of packages for the version of PostgreSQL and your \n   distribution from the list at \nhttp://yum.postgresql.org/\n.\n\n\nFor CentOS 7, use:\n\n\n# dnf install https://download.postgresql.org/pub/repos/yum/9.5/redhat/rhel-7-x86_64/pgdg-centos95-9.5-2.noarch.rpm\n\n   For Fedora 23, use:\n\n\n# dnf install https://download.postgresql.org/pub/repos/yum/9.5/fedora/fedora-23-x86_64/pgdg-fedora95-9.5-3.noarch.rpm\n\n\n\n\nInstall the required packages. You may first want to uninstall any\n   conflicting packages if you had default PostgreSQL packages installed with\n   your base CentOS installation.\n\n\n\n\n# dnf install policycoreutils-python\n   # dnf remove postgresql{,-server}\n   # dnf install postgresql95{,-server,-docs,-contrib}\n\n\n\n\nAdd local labeling rules to \nSE-Linux\n since the files are not where CentOS\n   expects them.\n\n\n\n\n# semanage fcontext --add --type postgresql_tmp_t \"/tmp/\\.s\\.PGSQL\\.[0-9]+.*\"\n  # semanage fcontext --add --type postgresql_exec_t \"/usr/pgsql-9\\.[0-9]/bin/(initdb|postgres)\"\n  # semanage fcontext --add --type postgresql_log_t \"/var/lib/pgsql/9\\.[0-9]/pgstartup\\.log\"\n  # semanage fcontext --add --type postgresql_db_t \"/var/lib/pgsql/9\\.[0-9]/data(/.*)?\"\n  # restorecon -rv /var/lib/pgsql/\n  # restorecon -rv /usr/pgsql-9.*\n\n\n\n\nInitialize and enable the \npostgresql\n service.\n\n\n\n\n# /usr/pgsql-9.5/bin/postgresql95-setup initdb\n   # systemctl enable postgresql-9.5.service\n   # systemctl start postgresql-9.5.service\n\n\n\n\nVerify that postmaster is running under the right SE-Linux context\n   \npostgresql_t\n (though process IDs will vary of course).\n\n\n\n\n# ps -eZ | grep postgres\n   system_u:system_r:unconfined_service_t:s0 22188 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22189 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22191 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22192 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22193 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22194 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22195 ? 00:00:00 postgres\n\n\n\n\nPermit network connections to the database service.\n\n\n\n\n# setsebool -P httpd_can_network_connect_db=1\n\n\nOther Prerequisites\n\uf0c1\n\n\n# dnf install httpd mod_{ssl,wsgi} python{,-psycopg2,-dateutil,-setuptools,-ply} pytz\n# dnf install python-webpy\n\n\n\n\nIf \npython-webpy\n does not exist in the package repo, install it with \npip\n.\n\n\n# pip install web.py\n\n\n\n\nWebAuthn\n\uf0c1\n\n\nWebAuthn\n is a library that provides a small extension to the lightweight\n\nweb.py\n web framework. It must be installed first before installing ERMrest.\n\n\n\n\nDownload WebAuthn.\n\n\n\n\n$ git clone https://github.com/informatics-isi-edu/webauthn.git webauthn\n\n\n\n\nFrom the WebAuthn source directory, run the installation and deployment scripts.\n\n\n\n\n# cd webauthn\n   # make install\n   # make deploy\n\n\nThis will install the WebAuthn Python module under\n   \n/usr/lib/python2*/site-packages/webauthn2/\n. It will also create a\n   daemon account \nwebauthn\n and place a default security config under\n   \n~webauthn/webauthn2_config.json\n. A new web service will be\n   enabled under \n/etc/httpd/conf.d/wsgi_webauthn2.conf\n.\n\n\nInstalling ERMrest\n\uf0c1\n\n\nAfter installing the prerequisite, you are ready to install ERMrest.\n\n\n\n\nDownload ERMrest.\n\n\n\n\n$ git clone https://github.com/informatics-isi-edu/ermrest.git ermrest\n\n\n\n\nFrom the ERMrest source directory, run the installation script.\n\n\n\n\n# cd ermrest\n   # make install [PLATFORM=centos7]\n\n\nThe install script:\n   - installs the ERMrest Python module under\n     \n/usr/lib/python2*/site-packages/ermrest/\n\n   - installs command-line interface (CLI) tools under \n/usr/sbin\n.\n\n\n\n\nFrom the same directory, run the deployment script.\n\n\n\n\n# make deploy [PLATFORM=centos7]\n\n\nThe deployment script:\n   - runs install target\n   - prepares service environment (makes ERMrest daemon user, creates directories)\n   - creates and initializes ERMrest-specific database, owned by daemon user\n   - creates default service config as \n/etc/httpd/conf.d/wsgi_ermrest.conf\n.\n\n\nCentOS notes:\n   - you may need to uninstall mod_python to use mod_wsgi\n   - you may need to uncomment \n/etc/httpd/conf.d/wsgi.conf\n load module.\n\n\n\n\nRestart the Apache httpd service\n\n\n\n\n# service httpd restart\n\n\nUpdating ERMrest\n\uf0c1\n\n\nChanges to code in your working copy can be quickly tested with the following\ncommands.\n\n\n# cd path/to/ermrest\n# make install [PLATFORM=centos7]\n# service httpd restart\n\n\n\n\nThe install target updates files under \n/usr/lib/python2*/site-packages/ermrest\n.\n\n\nYou may want to review \n/usr/share/ermrest/ermrest_config.json\n and\n\n/usr/share/ermrest/wsgi_ermrest.conf\n for changes, as these are\ndeployed to \n/home/ermrest/\n and \n/etc/httpd/conf.d/\n, respectively,\nduring fresh installs but will not overwrite deployed configurations\nduring an updating install.\n\n\nChange web_authn config\n\uf0c1\n\n\nChange the following config file to use different authentication modes:\n* /home/webauthn/webauthn2_config.json\n\n\n  \nsessionids_provider\n: \nwebcookie\n, \n  \nsessionstates_provider\n: \ndatabase\n, \n  \nclients_provider\n: \ndatabase\n, \n  \nattributes_provider\n: \ndatabase\n, \n  \npreauth_provider\n: \ndatabase\n,\n\n\n\n\nSee config example \nhere\n.\n\n\nSetup User Accounts\n\uf0c1\n\n\nThe WebAuthn framework allows for pluggable security providers for\nauthenticating clients. The simplest configuration assumes \nbasic authentication\n\nagainst an internal database of usernames and passwords and attributes.\n\n\n\n\nSwitch to the \nwebauthn\n user in order to perform the  configuration steps.\n\n\n\n\n# su - webauthn\n\n\n\n\nSetup an administrator account.\n\n\n\n\n$ webauthn2-manage adduser root\n   $ webauthn2-manage addattr admin\n   $ webauthn2-manage assign root admin\n   $ webauthn2-manage passwd root 'your password here'\n\n\nThe \nadmin\n attribute has special meaning only because it appears in\n   \n~webauthn/webauthn2_config.json\n in some ACLs.\n\n\n\n\nSetup a user account.\n\n\n\n\n$ webauthn2-manage adduser myuser\n   $ webauthn2-manage passwd myuser 'your password here'\n\n\nCreate Your First Catalog\n\uf0c1\n\n\nA quick sanity check of the above configuration is to login to ERMrest, create\na catalog, and read its meta properties. The following commands can be run as\nany local user.\n\n\n\n\nLogin to ERMrest using an 'admin' account previously created with\n   \nermrest-webauthn-manage\n. Do not include the single quotes in the parameter. The following script will create a cookie file named \ncookie\n.\n\n\n\n\n$ curl -k -c cookie -d username=root -d password='your password here' https://$(hostname)/ermrest/authn/session\n\n\n\n\nCreate a catalog.\n\n\n\n\n$ curl -k -b cookie -XPOST https://$(hostname)/ermrest/catalog/\n\n\n\n\nInspect the catalog metadata. (Readable indentation added here.)\n\n\n\n\n```\n   $ curl -k -b cookie -H \"Accept: application/json\" \\\n\n\n\n\nhttps://$(hostname)/ermrest/catalog/1\n   {\n     \"meta\": [\n       {\"k\": \"owner\", \"v\": \"testuser\"},\n       {\"k\": \"write_user\", \"v\": \"testuser\"},\n       {\"k\": \"read_user\", \"v\": \"testuser\"},\n       {\"k\": \"schema_write_user\", \"v\": \"testuser\"},\n       {\"k\": \"content_read_user\", \"v\": \"testuser\"},\n       {\"k\": \"content_write_user\", \"v\": \"testuser\"}],\n     \"id\": \"1\"\n   }\n   ```\n\n\n\n\n\n\nInspect the catalog schema.\n\n\n\n\n```\n   $ curl -k -b cookie -H \"Accept: application/json\" \\\n\n\n\n\nhttps://$(hostname)/ermrest/catalog/1/schema\n   {\n      \"schemas\": {\n      ...\n   }\n   ```\n\n\n\n\nFirewall\n\uf0c1\n\n\nYou will need to edit your firewall rules if you want to access the ERMrest\nservice from remote hosts. There are multiple ways to do this.\n\n\nhttps://fedoraproject.org/wiki/How_to_edit_iptables_rules\n\n\nNormally, you need to expose the HTTPS port (TCP 443) to client\nmachines. Contact your local system administrator if you need help\naccomplishing this.", 
            "title": "Installing on CentOS 7"
        }, 
        {
            "location": "/user-doc/install-centos7/#ermrest-installation-centos-7", 
            "text": "This guide provides instructions for installing ERMrest on the CentOS 7.x Linux\ndistribution.", 
            "title": "ERMrest Installation (CentOS 7)"
        }, 
        {
            "location": "/user-doc/install-centos7/#prerequisites", 
            "text": "ERMrest depends on the following prerequisites:\n- CentOS 7.x\n- EPEL 7 repository\n- PostgreSQL 9.4 or above (note: we recommend latest stable version)\n- WebAuthn  This guide assumes only that you have installed the CentOS 7.x Linux\ndistribution. See http://www.centos.org for more information.  In this document, commands that begin with  #  should be run as root or with\nsuper user privileges ( sudo ). Commands that begin with  $  may be run as a\nnormal user.  Extended Packages for Enterprise Linux (EPEL) \uf0c1  Run the following commands to install the EPEL repository.  # rsync -v rsync://mirrors.kernel.org/fedora-epel/7/x86_64/e/epel-release*.rpm .\n# dnf install epel-release*.rpm  PostgreSQL 9.4 or above \uf0c1  PostgreSQL must be installed and configured to operate within the SE-Linux  access control mechanism.  We recommend using the latest\nstable release, i.e. Postgres 9.5 at time of writing.   Install the PostgreSQL 9.x repository.   Check the list of packages for the version of PostgreSQL and your \n   distribution from the list at  http://yum.postgresql.org/ .  For CentOS 7, use:  # dnf install https://download.postgresql.org/pub/repos/yum/9.5/redhat/rhel-7-x86_64/pgdg-centos95-9.5-2.noarch.rpm \n   For Fedora 23, use:  # dnf install https://download.postgresql.org/pub/repos/yum/9.5/fedora/fedora-23-x86_64/pgdg-fedora95-9.5-3.noarch.rpm   Install the required packages. You may first want to uninstall any\n   conflicting packages if you had default PostgreSQL packages installed with\n   your base CentOS installation.   # dnf install policycoreutils-python\n   # dnf remove postgresql{,-server}\n   # dnf install postgresql95{,-server,-docs,-contrib}   Add local labeling rules to  SE-Linux  since the files are not where CentOS\n   expects them.   # semanage fcontext --add --type postgresql_tmp_t \"/tmp/\\.s\\.PGSQL\\.[0-9]+.*\"\n  # semanage fcontext --add --type postgresql_exec_t \"/usr/pgsql-9\\.[0-9]/bin/(initdb|postgres)\"\n  # semanage fcontext --add --type postgresql_log_t \"/var/lib/pgsql/9\\.[0-9]/pgstartup\\.log\"\n  # semanage fcontext --add --type postgresql_db_t \"/var/lib/pgsql/9\\.[0-9]/data(/.*)?\"\n  # restorecon -rv /var/lib/pgsql/\n  # restorecon -rv /usr/pgsql-9.*   Initialize and enable the  postgresql  service.   # /usr/pgsql-9.5/bin/postgresql95-setup initdb\n   # systemctl enable postgresql-9.5.service\n   # systemctl start postgresql-9.5.service   Verify that postmaster is running under the right SE-Linux context\n    postgresql_t  (though process IDs will vary of course).   # ps -eZ | grep postgres\n   system_u:system_r:unconfined_service_t:s0 22188 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22189 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22191 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22192 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22193 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22194 ? 00:00:00 postgres\n   system_u:system_r:unconfined_service_t:s0 22195 ? 00:00:00 postgres   Permit network connections to the database service.   # setsebool -P httpd_can_network_connect_db=1  Other Prerequisites \uf0c1  # dnf install httpd mod_{ssl,wsgi} python{,-psycopg2,-dateutil,-setuptools,-ply} pytz\n# dnf install python-webpy  If  python-webpy  does not exist in the package repo, install it with  pip .  # pip install web.py  WebAuthn \uf0c1  WebAuthn  is a library that provides a small extension to the lightweight web.py  web framework. It must be installed first before installing ERMrest.   Download WebAuthn.   $ git clone https://github.com/informatics-isi-edu/webauthn.git webauthn   From the WebAuthn source directory, run the installation and deployment scripts.   # cd webauthn\n   # make install\n   # make deploy  This will install the WebAuthn Python module under\n    /usr/lib/python2*/site-packages/webauthn2/ . It will also create a\n   daemon account  webauthn  and place a default security config under\n    ~webauthn/webauthn2_config.json . A new web service will be\n   enabled under  /etc/httpd/conf.d/wsgi_webauthn2.conf .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/user-doc/install-centos7/#installing-ermrest", 
            "text": "After installing the prerequisite, you are ready to install ERMrest.   Download ERMrest.   $ git clone https://github.com/informatics-isi-edu/ermrest.git ermrest   From the ERMrest source directory, run the installation script.   # cd ermrest\n   # make install [PLATFORM=centos7]  The install script:\n   - installs the ERMrest Python module under\n      /usr/lib/python2*/site-packages/ermrest/ \n   - installs command-line interface (CLI) tools under  /usr/sbin .   From the same directory, run the deployment script.   # make deploy [PLATFORM=centos7]  The deployment script:\n   - runs install target\n   - prepares service environment (makes ERMrest daemon user, creates directories)\n   - creates and initializes ERMrest-specific database, owned by daemon user\n   - creates default service config as  /etc/httpd/conf.d/wsgi_ermrest.conf .  CentOS notes:\n   - you may need to uninstall mod_python to use mod_wsgi\n   - you may need to uncomment  /etc/httpd/conf.d/wsgi.conf  load module.   Restart the Apache httpd service   # service httpd restart", 
            "title": "Installing ERMrest"
        }, 
        {
            "location": "/user-doc/install-centos7/#updating-ermrest", 
            "text": "Changes to code in your working copy can be quickly tested with the following\ncommands.  # cd path/to/ermrest\n# make install [PLATFORM=centos7]\n# service httpd restart  The install target updates files under  /usr/lib/python2*/site-packages/ermrest .  You may want to review  /usr/share/ermrest/ermrest_config.json  and /usr/share/ermrest/wsgi_ermrest.conf  for changes, as these are\ndeployed to  /home/ermrest/  and  /etc/httpd/conf.d/ , respectively,\nduring fresh installs but will not overwrite deployed configurations\nduring an updating install.", 
            "title": "Updating ERMrest"
        }, 
        {
            "location": "/user-doc/install-centos7/#change-web_authn-config", 
            "text": "Change the following config file to use different authentication modes:\n* /home/webauthn/webauthn2_config.json     sessionids_provider :  webcookie , \n   sessionstates_provider :  database , \n   clients_provider :  database , \n   attributes_provider :  database , \n   preauth_provider :  database ,  See config example  here .", 
            "title": "Change web_authn config"
        }, 
        {
            "location": "/user-doc/install-centos7/#setup-user-accounts", 
            "text": "The WebAuthn framework allows for pluggable security providers for\nauthenticating clients. The simplest configuration assumes  basic authentication \nagainst an internal database of usernames and passwords and attributes.   Switch to the  webauthn  user in order to perform the  configuration steps.   # su - webauthn   Setup an administrator account.   $ webauthn2-manage adduser root\n   $ webauthn2-manage addattr admin\n   $ webauthn2-manage assign root admin\n   $ webauthn2-manage passwd root 'your password here'  The  admin  attribute has special meaning only because it appears in\n    ~webauthn/webauthn2_config.json  in some ACLs.   Setup a user account.   $ webauthn2-manage adduser myuser\n   $ webauthn2-manage passwd myuser 'your password here'", 
            "title": "Setup User Accounts"
        }, 
        {
            "location": "/user-doc/install-centos7/#create-your-first-catalog", 
            "text": "A quick sanity check of the above configuration is to login to ERMrest, create\na catalog, and read its meta properties. The following commands can be run as\nany local user.   Login to ERMrest using an 'admin' account previously created with\n    ermrest-webauthn-manage . Do not include the single quotes in the parameter. The following script will create a cookie file named  cookie .   $ curl -k -c cookie -d username=root -d password='your password here' https://$(hostname)/ermrest/authn/session   Create a catalog.   $ curl -k -b cookie -XPOST https://$(hostname)/ermrest/catalog/   Inspect the catalog metadata. (Readable indentation added here.)   ```\n   $ curl -k -b cookie -H \"Accept: application/json\" \\   https://$(hostname)/ermrest/catalog/1\n   {\n     \"meta\": [\n       {\"k\": \"owner\", \"v\": \"testuser\"},\n       {\"k\": \"write_user\", \"v\": \"testuser\"},\n       {\"k\": \"read_user\", \"v\": \"testuser\"},\n       {\"k\": \"schema_write_user\", \"v\": \"testuser\"},\n       {\"k\": \"content_read_user\", \"v\": \"testuser\"},\n       {\"k\": \"content_write_user\", \"v\": \"testuser\"}],\n     \"id\": \"1\"\n   }\n   ```    Inspect the catalog schema.   ```\n   $ curl -k -b cookie -H \"Accept: application/json\" \\   https://$(hostname)/ermrest/catalog/1/schema\n   {\n      \"schemas\": {\n      ...\n   }\n   ```", 
            "title": "Create Your First Catalog"
        }, 
        {
            "location": "/user-doc/install-centos7/#firewall", 
            "text": "You will need to edit your firewall rules if you want to access the ERMrest\nservice from remote hosts. There are multiple ways to do this.  https://fedoraproject.org/wiki/How_to_edit_iptables_rules  Normally, you need to expose the HTTPS port (TCP 443) to client\nmachines. Contact your local system administrator if you need help\naccomplishing this.", 
            "title": "Firewall"
        }, 
        {
            "location": "/user-doc/install-ubuntu1204/", 
            "text": "Installing on Ubuntu 12.04\n\uf0c1\n\n\n\n\nEnable upstream Postgresql repo following \nApt instructions from Postgresql Wiki\n.\n\n\nSet the \nPLATFORM=ubuntu1204\n variable for our Makefiles\n\n\nDo normal installation sequence as \nroot\n user\n\n\nsudo su -\n\n\ncd ~devuser/webauthn\n\n\nmake install PLATFORM=ubuntu1204\n\n\ncd ~devuser/ermrest\n\n\nmake predeploy PLATFORM=ubuntu1204\n\n\nmake install PLATFORM=ubuntu1204\n\n\nmake deploy PLATFORM=ubuntu1204\n\n\nEnable SSL\n\n\n\n\nHTTPS Notes\n\uf0c1\n\n\n\n\nThe web service is called \napache2\n and some file locations and operating details differ from that documented for CentOS.\n\n\nThe ermrest \npredeploy\n make target will run \napt-get\n to install dependencies including self-signed certificates for apache.\n\n\nThe HTTPS service needs to be enabled explicitly, unlike on CentOS\n\n\na2enmod ssl\n\n\ns2ensite default-ssl\n\n\nservice apache2 reload\n\n\n\n\nPostgres Notes\n\uf0c1\n\n\nContent of \n/etc/apt/sources.list.d/pgdg.list\n:\n\n\ndeb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main\n\n\n\n\nWe try to install \npostgresql-9.4\n in our \npredeploy\n target, but you \nmay want to install it sooner to make sure no other implicit postgres \ndependencies pull in an older, incompatible postgres from Ubuntu 12.04 itself.", 
            "title": "Installing on Ubuntu 12.04"
        }, 
        {
            "location": "/user-doc/install-ubuntu1204/#installing-on-ubuntu-1204", 
            "text": "Enable upstream Postgresql repo following  Apt instructions from Postgresql Wiki .  Set the  PLATFORM=ubuntu1204  variable for our Makefiles  Do normal installation sequence as  root  user  sudo su -  cd ~devuser/webauthn  make install PLATFORM=ubuntu1204  cd ~devuser/ermrest  make predeploy PLATFORM=ubuntu1204  make install PLATFORM=ubuntu1204  make deploy PLATFORM=ubuntu1204  Enable SSL", 
            "title": "Installing on Ubuntu 12.04"
        }, 
        {
            "location": "/user-doc/install-ubuntu1204/#https-notes", 
            "text": "The web service is called  apache2  and some file locations and operating details differ from that documented for CentOS.  The ermrest  predeploy  make target will run  apt-get  to install dependencies including self-signed certificates for apache.  The HTTPS service needs to be enabled explicitly, unlike on CentOS  a2enmod ssl  s2ensite default-ssl  service apache2 reload", 
            "title": "HTTPS Notes"
        }, 
        {
            "location": "/user-doc/install-ubuntu1204/#postgres-notes", 
            "text": "Content of  /etc/apt/sources.list.d/pgdg.list :  deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main  We try to install  postgresql-9.4  in our  predeploy  target, but you \nmay want to install it sooner to make sure no other implicit postgres \ndependencies pull in an older, incompatible postgres from Ubuntu 12.04 itself.", 
            "title": "Postgres Notes"
        }, 
        {
            "location": "/user-doc/acls/", 
            "text": "ERMrest Access Control\n\uf0c1\n\n\nScope of Use Cases to Address\n\uf0c1\n\n\nThe ERMrest resource hierarchy supports a rich set of possible\nresource operations. We intend to provide fine-grained control of\nthese operations, differentiating rights of one user from another in a\nshared system:\n\n\n\n\nMake some content invisible\n\n\nAn entire catalog\n\n\nAn entire schema\n\n\nAn entire table\n\n\nAn entire column of a table\n\n\nSome rows of a table (as if row does not exist)\n\n\nSome fields of some rows of a table (as if the value is NULL)\n\n\n\n\n\n\nPrevent modification of some content\n\n\nAccess control policy\n\n\nTable structure\n\n\nTable constraints\n\n\nRow insertion\n\n\nRow modification\n\n\nRow deletion\n\n\nField modification (can change parts of row but not all parts)\n\n\nValue expression (can apply some values but not others in a given field)\n\n\n\n\n\n\nDelegate some rights within a community\n\n\nAuthorize additional owners for sub-resources (can't suppress/mask parent owners from sub-resources)\n\n\n~~Delegate management of specific table's structure and constraints~~\n\n\nDelegate creation of new schema (while protecting other schemas)\n\n\nDelegate creation of new table (while protecting other tables)\n\n\n\n\n\n\nMake sure simple policies are still simple to manage\n\n\nEntire catalog visible to one group\n\n\nEntire catalog data mutable by one group\n\n\nEntire catalog model managed by one group\n\n\n\n\n\n\n\n\nComplications\n\uf0c1\n\n\nControlling visibility is complicated, particularly when done to the\nextent desired by some use cases we've observed.\n\n\n\n\nMost forms of access depend on other access\n\n\nMust see model to make sense of data APIs\n\n\nMust see data to make use of data modification APIs\n\n\nMust see related data to make sense of reference constraints\n\n\nMust see policy to make sense of what access mechanisms are available\n\n\n\n\n\n\nReference constraints can expose \"hidden\" data\n\n\nRows can be hidden in a domain table's policy\n\n\nReferring rows might still be visible due to a referring table's more open policy\n\n\nPresence of hidden domain data is revealed\n\n\n\n\n\n\nIntegrity constraints can expose \"hidden\" columns\n\n\nA hidden column will receive default values on insert\n\n\nA default expression is not guaranteed to satisfy integrity constraints\n\n\nThe conflict error will reveal information about the hidden column\n\n\nThat a column with this name exists\n\n\nWhat the default value looks like\n\n\nWhat kind of constraint is violated by the default value\n\n\n\n\n\n\n\n\n\n\n\n\nWe will initially require policy administrators to reconcile most of\nthese problems by forming well coordinated schemas and policies. In\nsome cases, we may be able to improve usability by having the system\nautomatically detect conflicts and/or reconcile them?\n\n\nCore Concepts\n\uf0c1\n\n\nCatalog Resource Hierarchy\n\uf0c1\n\n\nPolicy will be expressed over the hierarchical catalog model, with\npolicies attached to specific resources in the following model\nhierarchy (already present in ERMrest catalog introspection):\n\n\n\n\nCatalog\n\n\nSchema\n\n\nTable\n\n\nColumn\n\n\nConstraint\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAccess Modes\n\uf0c1\n\n\nA number of distinct access modes are defined such that permission can\nbe granted or denied for each mode separately. Some modes are short-hand\nfor a combination of distinct modes, where a general level of access\ncan be further sub-divided into very specific scenarios you might control\nseparately:\n\n\n\n\nOwn model element (can do everything)\n\n\nCreate new child model element\n\n\nEnumerate existing model element\n\n\nWrite data (can make any data change)\n\n\nReference to key\n\n\nInsert new data\n\n\nModify existing data\n\n\nDelete existing data\n\n\n\n\n\n\nSelect existing data\n\n\n\n\n\n\n\n\nOwnership is not quite an access mode but convenient to think about as\nthe superior mode to all other modes.\n\n\nThe precise meaning of some data access modes varies by resource type:\n\n\n\n\n\n\n\n\nMode\n\n\nTable\n\n\nColumn\n\n\nReference\n\n\n\n\n\n\n\n\n\n\nInsert\n\n\nCreate new row\n\n\nSet value during row insert\n\n\nMake reference to key (during row insert)\n\n\n\n\n\n\nUpdate\n\n\nModify row\n\n\nReplace value\n\n\nMake reference to key (during row update)\n\n\n\n\n\n\nDelete\n\n\nRemove row\n\n\nReset to default value\n\n\nN/A\n\n\n\n\n\n\nSelect\n\n\nObserve/detect row\n\n\nObserve/detect value\n\n\nN/A\n\n\n\n\n\n\n\n\nForeign key reference resources offer control of value expression:\nrather than limiting what row or field can change, they can limit what\nvalues are allowed to be placed into a field. They complement the row\nand column-level access controls which can only consider the current\nvalues of data rather than the proposed new value.\n\n\nPolicy Scoping and Resource Dependencies\n\uf0c1\n\n\nA policy attached to a resource will govern access to that\nresource. Because many forms of access depend on multiple resources, a\ncomplete request will be granted or denied based on the conjunction of\npolicies governing each resource involved in the request.\n\n\nFor example:\n- Joined sets can only be viewed if all involved data can be viewed.\n- Data can only be viewed if the enclosing table is visible.\n- A table can only be accessed if its enclosing schema is visible.\n- A schema can only be access if its enclosing catalog is visible.\n- A column can only be modified if its governing reference constraints allow the new value.\n- A key constraint is only visible if the columns it governs are selectable.\n- A foreign key constraint is only visible if the columns it governs are selectable.\n\n\nThe last two dependencies above are more strict than necessary.  A\nconstraint can be well-defined if its constituent columns are\nenumerable. But, in practice most clients cannot do anything useful\nwith the constraint unless it can also see the data, and the presence\nof the useless constraint would only confuse most model-driven clients.\n\n\nData-Dependent Policies\n\uf0c1\n\n\nSome, but not all, fine-grained access decisions involve data values.\nModel-level Access Control Lists (ACLs) support \ndata-independent\n\ndecisions, i.e. granting access to all rows of a table uniformly.\nDynamic ACL bindings support \ndata-dependent\n decisions, i.e. granting\naccess to specific rows of a table.\n\n\nData-dependent policies can grant more selective rights to a client\nthat would not be possible with a static policy. The decision process\ndepends on the configured policy:\n\n\n\n\nA data-access request is not well-formed if it depends model elements that are invisible to the client.\n\n\nData-visibility policies determine whether a request is allowed:\n\n\nIf data-independent policies permit an access, it is allowed\n\n\nIf data-dependent policies permit an access, it is allowed\n\n\nIf neither, it is denied\n\n\n\n\n\n\n\n\nIn practice, this means that ERMrest can statically solve some policy\ndecisions and make a decision without investigating actual data\nvalues. But, in the worst case, it needs to include dynamic policy\nchecks to decide if a particular access is allowed or denied.\n\n\nWhen data-dependent data viewing policies are active, the effective\nresult set is \nfiltered\n by the visibility policy. When only static\nviewing policies are in effect, the request will be denied rather than\nreturning an empty result set.\n\n\nPolicy Inheritance and Implication\n\uf0c1\n\n\nA resource owner \nalways owns all sub-resources\n. Any sub-resource\nownership policy can only extend the privilege to more clients but can\nnever block the owners \ninherited\n from the enclosing resource.\n\n\nSimilarly, a more general access right \nalways implies all\nsub-rights\n. Any sub-mode policy can extend the privilege to more\nclients but can never block the parent mode. For example, a client\nwith \"data write\" privileges also has \"data insert\" privileges, even\nif the an explicit \"data insert\" policy is empty on the same resource.\n\n\nFor non-ownership policies, a locally unconfigured (\nnull\n) policy on\na sub-resource means the policy will be inherited from the enclosing\nresource. However, any other value including an empty policy (\n[]\n)\nwill \noverride\n the inherited policy for that access mode. Thus,\nlesser privileges may be selectively blocked on specific\nsub-resources.\n\n\n\n\nA local policy can \nrestrict\n access compared to the enclosing resource\n\n\nOne table is read-only in an otherwise read-write schema\n\n\nOne column is hidden in an otherwise read-write table\n\n\nBut ownership can never be restricted in sub-resources\n\n\n\n\n\n\nA local policy can \nbroaden\n access compared to the enclosing resource\n\n\nOne table is writable in an otherwise read-only schema\n\n\nOne column is mutable in an otherwise read-only table\n\n\nOwnership can be extended to more parties on sub-resources\n\n\n\n\n\n\nA more specific access mode can be \nextended\n to more clients\n\n\nOne table is writable by a curator group, and another group can only insert new rows\n\n\nOne column is writable by a curator group, and another group can only set values during row insertion\n\n\nBut a curator group with general write access can not be denied row insert access\n\n\n\n\n\n\nBut, access decisions still involve resource dependencies\n\n\nAn invisible catalog hides all schemas inside it\n\n\nAn invisible schema hides all tables inside it\n\n\nAn invisible table hides all columns inside it\n\n\n\n\n\n\n\n\nModel-level ACLs\n\uf0c1\n\n\nACLs are distributed throughout the hierarchical model of the catalog.\n\n\n\n\nThe predefined \nname\n of each ACL identifies the type of access governed.\n\n\nThe \nresource\n to which the ACL is attached identifies the scope of the access governed.\n\n\nThe \ncontent\n of each ACL is a list of disjunctive matching choices which may include the wildcard \n*\n matching any client.\n\n\n\n\nCatalog ACLs\n\uf0c1\n\n\nA catalog-level ACL describes what access to permit on the whole\ncatalog. Catalogs do not inherit ACLs from elsewhere, so an\nunconfigured catalog ACL is not possible.\n\n\nDuring catalog creation the \nowner\n defaults to the requesting\nclient. Other ACLs are set to empty \n[]\n if not otherwise specified in\nthe request.\n\n\nFor catalogs and all other ERMrest resources described below, it is\nimpossible for a client to create or manage a resource while\ndisclaiming ownership in the request. They may set the ownership more\nbroadly, e.g. to a group for which they are a member, rather than\nlisting their client ID as the sole owner. But, they can never\nconfigure a owner ACL which would prevent them from being an owner at\nthe end of the request. The only way to transfer resource ownership is\nto add an additional owner, and then have that other owner strip the\noriginal owner identity from the owner ACL. Alternatively, ownership\ncan be assigned to a particular owners group and then the group\nmembership can fluctuate due to external management without changing\nthe ERMrest ACL content.\n\n\nSchema ACLs\n\uf0c1\n\n\nA schema-level ACL describes what access to permit on the whole\nschema. When not configured locally, the effective schema-level ACL is\ninherited from the catalog.\n\n\nDuring schema creation, the \nowner\n defaults to the requesting client\nor to \nnull\n if the client is also an owner of the catalog at the time\nof creation; all other schema ACLs are set to \nnull\n if not otherwise\nspecified in the request.\n\n\nTable ACLs\n\uf0c1\n\n\nA table-level ACL describes what access to permit on the whole\ntable. When not configured locally, the effective table-level ACL is\ninherited from the schema.\n\n\nDuring table creation, the \nowner\n defaults to the requesting client\nor to \nnull\n if the client is also an owner of the table at the time\nof creation; all other table ACLs are set to \nnull\n if not otherwise\nspecified in the request.\n\n\nDynamic table-level ACL bindings\n can augment\ntable-level ACLs to enable access to only a subset of data rows.  The\npresence of dynamic ACL bindings for data retrieval access modes\nsuppresses a \n403 Forbidden\n response which would otherwise be\ngenerated in the absence of a static ACL granting read access;\ninstead, a \n200 OK\n response is generated where any denied row is\nabsent from the result set.\n\n\nAll static and dynamic table ACLs are disjunctively considered when\ndeciding row access. Any access denied decision for data modifying\nrequests will continue to raise a \n403 Forbidden\n response.\n\n\nColumn ACLs\n\uf0c1\n\n\nA column-level ACL describes what access to permit on the whole\ncolumn. When not configured locally, the effective column-level ACL is\ninherited from the table.\n\n\nColumns are considered part of the enclosing table resource and do not\nhave separable ownership. Column ACLs are set to \nnull\n if not\notherwise specified in the request.\n\n\nDynamic column ACL bindings\n can augment\ncolumn-level ACLs to enable access to only a subset of data fields in\nthis column.  The presence of dynamic ACL bindings for data retrieval\naccess modes suppresses a \n403 Forbidden\n response which would\notherwise be generated in the absence of a static ACL granting read\naccess; instead, a \n200 OK\n response is generated where any denied\nfield is replaced with a NULL value.\n\n\nReference ACLs\n\uf0c1\n\n\nA reference-level ACL describes whether to permit foreign key\nreferences to be expressed.\n\n\nReference ACLs are set to \n[\"*\"]\n if not otherwise specified in the\nrequest.  In practice, reference ACLs are less often restricted and so\nthis default simplifies common configurations. A model which needs to\nrestrict expression of foreign keys SHOULD explicitly override the\ndefault ACLs; to completely disable expression of foreign keys, the\nreference ACL set \n{\"insert\": [], \"update\": []}\n MAY be used.\n\n\nReference constraints are considered part of the enclosing table\nresource and do not have separable ownership.\n\n\nDynamic reference ACL bindings\n can augment\nreference ACLs to enable expression of only a subset of data in a\ncolumn governed by that reference constraint. These ACLs are actually\nmanaged on foreign key reference constraints, but their effect is to\nlimit what new values can be expressed in the foreign key's\nconstituent columns.\n\n\nDynamic ACL Bindings\n\uf0c1\n\n\nDynamic ACL bindings configure sources of ACL content associated with\neach individual tuple or datum, i.e. a query which projects\nuser attributes out of the data catalog itself:\n\n\n\n\nThe predefined \ntype\n of each ACL binding identifies the mode of access governed.\n\n\nAn arbitrary \nname\n of each ACL binding facilitates subsequent management tasks on the policy.\n\n\nThe \nresource\n to which the ACL binding is attached identifies the scope of the access governed.\n\n\nThe \nprojection\n of each ACL binding describes how to retrieve ACL content.\n\n\n\n\nACL binding projections are a form of ERMrest attribute query in which\nthe query path and projection syntax is specified without the base\ntable instance. The base table instance is inferred from the resource\nscope of the binding.\n\n\nIt is the responsibility of the data modeler to create self-consistent\npolicies. For example, a dynamic ACL binding is only effective for\naccess control if the ACL storage itself is protected from unwanted\nchanges. Because the ACL storage is within the database and subject to\ndata modification APIs, appropriately restrictive policies must be\ndefined to protect the stored ACL content.\n\n\nDynamic Defaults\n\uf0c1\n\n\nTBD. Provide some remotely manageable mechanism to do basic\nprovenance-tracking idioms where we currently need to use SQL\ntriggers?  I.e. store a client identity, client object, or some data\ndetermined indirectly via a query constrained by client attributes?\n\n\nDynamic Table ACLs\n\uf0c1\n\n\nA table-level ACL binding describes how to retrieve ACLs which govern\naccess to rows of a table.\n\n\n\n\nThe base table for the projection is the bound table itself.\n\n\nACLs can be stored in columns of the table itself\n\n\nACLs can be stored in related entities\n\n\n\n\n\n\nGoverned access modes cover whole-entity access:\n\n\nRow visibility (invisible rows are filtered from results)\n\n\nRow writing\n\n\nRow update\n\n\nRow delete\n\n\n\n\n\n\n\n\n\n\n\n\nDynamic Column ACLs\n\uf0c1\n\n\nA column-level ACL binding describes how to retrieve ACLs which govern\naccess to fields within rows of a table.\n\n\n\n\nThe base table for the projection is the enclosing table resource for the bound column.\n\n\nACLs can be stored in sibling columns of the same table\n\n\nACLs can be stored in related entities\n\n\n\n\n\n\nGoverned access modes cover individual field (table cell) access:\n\n\nField visibility (invisible fields are replaced with NULLs)\n\n\nField writing\n\n\nField targeted during row updates\n\n\nField cleared by attribute deletes\n\n\n\n\n\n\n\n\n\n\n\n\nColumn-level dynamic ACLs are not involved in row insertion nor\ndeletion decisions.\n\n\nAs a convenience, columns inherit the dynamic ACL bindings of their\ntable. Thus, if no column-level ACL bindings are specified, the column\nallows whatever operation the table would allow for that row. The\ncolumn-level policy MAY apply a special binding value of \nfalse\n to\nsuppress an ACL binding inherited from the table under the same name.\n\n\nDynamic Reference ACLs\n\uf0c1\n\n\nA reference-level ACL binding describes how to retrieve ACLs which\ngovern expression of data within fields which are subject to a foreign\nkey reference constraint.\n\n\n\n\nThe base table for the projection is the referenced table resource, i.e. the domain table for the constraint.\n\n\nACLs can be stored in sibling columns of the referenced key\n\n\nACLs can be stored in related entities of the referenced entities\n\n\n\n\n\n\nGoverned access modes cover individual domain datum access:\n\n\nValue writing during row insertion or update\n\n\n\n\n\n\n\n\nNo access control distinction is allowed between reference value\ninsertion during row creation and reference value insertion during row\nupdate.\n\n\nReference-level dynamic ACLs are not involved in row deletion\ndecisions nor in default value expression during row creation.\n\n\nTechnical Reference\n\uf0c1\n\n\nAvailable Static ACL Names\n\uf0c1\n\n\nMost of the previously described \naccess modes\n have a\ncorresponding static ACL name associated with them. Some model access rights\nare not separately controlled and instead require full ownership\nrights. This might change in future revisions.\n\n\nBecause more general access mode rights imply lesser access mode\nrights and sub-resources inherit ACLs, brevity in policy\nconfigurations can be achieved:\n- A small set of owners need not be repeated in other ACLs\n- Less privileged roles are mentioned only in their corresponding lesser ACLs\n- Sub-resource ACLs can be set to \nnull\n unless local overrides are needed\n\n\nAvailable ACL names and applicability to specific model elements:\n\n\n\n\n\n\n\n\nACL Name\n\n\nCatalog\n\n\nSchema\n\n\nTable\n\n\nColumn\n\n\nReference\n\n\n\n\n\n\n\n\n\n\nowner\n\n\nall access\n\n\nall access\n\n\nall access\n\n\nN/A \nnote1\n\n\nN/A \nnote1\n\n\n\n\n\n\ncreate\n\n\nadd schema\n\n\nadd table\n\n\nN/A\n\n\nN/A\n\n\nN/A\n\n\n\n\n\n\nselect\n\n\nnote2\n\n\nnote2\n\n\nobserve row\n\n\nobserve value\n\n\nN/A\n\n\n\n\n\n\ninsert\n\n\nnote2\n\n\nnote2\n\n\nadd row\n\n\nset value \nnote3\n\n\nset value \nnote3\n\n\n\n\n\n\nupdate\n\n\nnote2\n\n\nnote2\n\n\nchange row\n\n\nset value \nnote3\n\n\nset value \nnote3\n\n\n\n\n\n\nwrite\n\n\nnote2\n\n\nnote2\n\n\nall data access\n\n\nset value \nnote3\n\n\nset value \nnote3\n\n\n\n\n\n\ndelete\n\n\nnote2\n\n\nnote2\n\n\ndelete row\n\n\nN/A\n\n\nN/A\n\n\n\n\n\n\nenumerate\n\n\nintrospect\n\n\nintrospect\n\n\nintrospect\n\n\nintrospect\n\n\nintrospect\n\n\n\n\n\n\n\n\nWhen a new schema is added to a catalog, or a new table is added to a\nschema, the requesting client becomes the owner of the newly added\nelement.\n\n\nNotes:\n- \nN/A\n: The named ACL is not supported on this kind of model element.\n- \nnote1\n: Columns and references are considered part of the table and so cannot have local ownership settings.\n- \nnote2\n: Data access ACLs on catalogs and schemas only serve to set inherited access policies for the tables which are sub-resources within those containers respectively. These only have effect if the table does not have a locally configured policy for the same named ACL, and they grant no special access to the catalog or schema itself.\n- \nnote3\n: The insert/update ACLs on columns and references configure whether values can be supplied during that type of operation on the containing row.\n\n\nAs described previously, some access rights imply other rights:\n\n\n\n\n\n\n\n\nACL Name\n\n\nImplies\n\n\n\n\n\n\n\n\n\n\nenumerate\n\n\n\n\n\n\n\n\ncreate\n\n\nenumerate\n\n\n\n\n\n\nselect\n\n\nenumerate\n\n\n\n\n\n\ninsert\n\n\nenumerate\n\n\n\n\n\n\nupdate\n\n\nselect, enumerate\n\n\n\n\n\n\ndelete\n\n\nselect, enumerate\n\n\n\n\n\n\nwrite\n\n\ninsert, update, delete, select, enumerate\n\n\n\n\n\n\nowner\n\n\ncreate, insert, update, delete, select, enumerate\n\n\n\n\n\n\n\n\nOwnership is inherited even if a sub-resource specifies a locally\nconfigured owner ACL. The effective owner policy is the disjunction of\ninherited owner and local owner policies. Other locally configured ACLs\noverride their respective inherited ACL and so may grant fewer rights\nthan would be granted with the inherited policy.\n\n\nACL Representation\n\uf0c1\n\n\nThe data-independent ACLs are encoded in an \n\"acls\"\n sub-resource of the\ngoverned resource. This is a hash-map keyed by ACL name. For example,\na schema resource has a canonical representation as in the following\nexample:\n\n\n{\n  \"schema_name\": \"My Schema\",\n  \"comment\": \"The purpose of My Schema is...\",\n  \"annotations\": ...,\n  \"tables\": ...,\n  \"acls\": {\n    \"owner\": [\"some/user/URI\"],\n    \"select\": [\"*\"]\n  }\n}\n\n\n\nThis example has locally configured ACLs for the schema owner and\npermits public access to enumerate the schema and select data, but\ninherits other ACLs from the enclosing catalog. For brevity, ACL names\nwith \nnull\n configuration are omitted from the canonical\nrepresentation. Specifying each such ACL name with a literal \nnull\n\nhas the same meaning.\n\n\nACL Management\n\uf0c1\n\n\nThe ACL sub-resources are managed by a simple REST API. They can be\nembedded in the enclosing resource description during resource update\nor resource retrieval. For ACL management on existing resources, a\nsub-API is supported on each resource to address one ACL by name.\n\n\n\n\n.../acl\n: collection of all named ACLs\n\n\nGET: retrieve ACL collection\n\n\nPUT: replace all ACLs in collection\n\n\nDELETE: unconfigure all ACLs in collection\n\n\n.../acl/name\n: individually named ACL\n\n\nGET: retrieve one ACL\n\n\nPUT: replace one ACL\n\n\nDELETE: unconfigure one ACL\n\n\n\n\nAn ACL collection is the sub-resource described previously: an object\nkeyed by ACL name where unconfigured ACLs are omitted. Each individual\nACL is a JSON array of strings.\n\n\n\n\n\n\n\n\nGoverned Resource\n\n\nExample for ACL name \nA\n\n\n\n\n\n\n\n\n\n\nCatalog\n\n\n/catalog/N/acl/A\n\n\n\n\n\n\nSchema\n\n\n/catalog/N/schema/S/acl/A\n\n\n\n\n\n\nTable\n\n\n/catalog/N/schema/S/table/T/acl/A\n\n\n\n\n\n\nColumn\n\n\n/catalog/N/schema/S/table/T/column/C/acl/A\n\n\n\n\n\n\n\n\nAvailable Dynamic ACL Types\n\uf0c1\n\n\nSome of the previously described \naccess modes\n have a\ncorresponding dynamic ACL type associated with them. Because dynamic ACLs\nare for data-dependent access, they have more restrictive applicability:\n\n\n\n\n\n\n\n\nType\n\n\nMode\n\n\nImplies\n\n\nSupported Resources\n\n\n\n\n\n\n\n\n\n\nowner\n\n\nWrite data\n\n\ninsert, update, delete, select\n\n\ntable, column, reference\n\n\n\n\n\n\ninsert\n\n\nInsert data\n\n\n\n\nreference\n\n\n\n\n\n\nupdate\n\n\nModify data\n\n\n\n\ntable, column, reference\n\n\n\n\n\n\ndelete\n\n\nDelete data\n\n\n\n\ntable, column\n\n\n\n\n\n\nselect\n\n\nView data\n\n\n\n\ntable, column\n\n\n\n\n\n\n\n\nTable and column-level dynamic ACLs are only applicable to access\nrequests against existing database content. Insertion of new rows can\nonly be granted by a static policy. However, reference-level dynamic\nACLs can grant or deny the ability to specify specific foreign keys \neven during row insertion.\n\n\nDynamic data rights do not imply model access. Model access must be\ndetermined in a data-independent manner in order to even pose an\naccess request which might be granted by dynamic access rights.\n\n\nDynamic ACL Binding Representation\n\uf0c1\n\n\nThe data-dependent ACL bindings are encoded in an \n\"acl_bindings\"\n\nsub-resource of the governed resource. This is a hash-map keyed by ACL\nbinding name. For example, a table resource has a canonical\nrepresentation as in the following example:\n\n\n{\n  \"schema_name\": \"My Schema\",\n  \"table_name\": \"My Table\",\n  \"kind\": \"table\",\n  \"comment\": \"The purpose of My Table is...\",\n  \"annotations\": ...,\n  \"column_definitions\": ...,\n  \"keys\": ...,\n  \"foreign_keys\": ...,\n  \"acls\": {\n    \"write\": [\"some/curator/URI\"]\n  },\n  \"acl_bindings\": {\n    \"My Binding\": {\n      \"types\": [\"owner\"],\n      \"projection\": \"Managed By\",\n      \"projection_type\": \"acl\"\n    }\n  }\n}\n\n\n\nThis example has an explicitly set, data-independent curator group who\ncan modify all rows in the table, while other data-independent ACLs\nare inherited from the enclosing schema. A dynamic ACL binding called\n\nMy Row Owners\n specifies that an ACL stored in the \nManaged By\n\ncolumn of the table grants \nowner\n dynamic access type for individual\nrows. The representation uses an array for the \ntype\n so that multiple\naccess modes can be more easily configured without having to repeat the\nsame projection many times.\n\n\nInheritence and False Binding\n\uf0c1\n\n\nAs a convenience, columns effectively inherit the ACL bindings of\ntheir table. A column whose \n\"acl_bindings\"\n document is empty will\npermit all operations that the table would allow for each row. To\ngrant fewer writes, the column-level \n\"acl_bindings\"\n MUST override\nthe named bindings inherited from the table.\n\n\n\n\nReplacement: the column MAY provide a different binding document under the same binding name.\n\n\nSuppression: the column MAY provide a literal \nfalse\n value instead of a binding document.\n\n\n\n\nProjection Document\n\uf0c1\n\n\nThe \n\"projection\"\n field of the ACL binding is a document representing\na parsed \nabstract syntax tree\n for an attribute query fragment. The\ngeneral form of the ACL document is an array of path elements:\n\n\n\n\n[\n \nelement\n \n,\n ... \n,\n \ncolumn\n \n]\n\n\n\n\nThis corresponds to the serialized query fragment \nelement/.../column\n\nto project ACL content from an implicit base entity context using the\nERMrest \n/attribute/base\n API.  The final \ncolumn\n MUST be a string\nliteral naming a column in the effective entity-path context. Each\nanterior \nelement\n MAY use one of the following sub-document\nstructures:\n\n\n\n\n{ \"context\":\n \nleftalias\n \n,\n \ndirection\n \n:\n \nfkeyname\n  \n, \"alias\":\n \nrightalias\n \n}\n\n\nLinks a new table instance to the existing path via inner join\n\n\nThe left-hand path context is the table instance named by \nleftalias\n or the immediately preceding path context if \nleftalias\n is \nnull\n or absent.\n\n\nThe alias \n\"base\"\n is implicitly bound to the base table to which this ACL is bound.\n\n\n\n\n\n\nThe joining condition is determined by the named foreign key constraint \nfkeyname\n where one end is tied to the left-hand path context and the other to the newly added table instance.\n\n\nThe \ndirection\n of the joining condition is \n\"inbound\"\n or \n\"outbound\"\n and MUST be specified.\n\n\nThe \nrightalias\n string literal is bound to the new table instance unless it is \nnull\n or absent.\n\n\nThe alias \n\"base\"\n is reserved and cannot be bound as a \nrightalias\n.\n\n\n\n\n\n\n\n\n\n\n{ \"and\": [\n \nfilter\n \n,\n ... \n], \"negate\":\n \nnegate\n \n}\n\n\nA logical conjunction of multiple \nfilter\n clauses is applied to the query to constrain matching rows.\n\n\nThe logical result is negated only if \nnegate\n is \ntrue\n.\n\n\nEach \nfilter\n clause may be a terminal filter element, conjunction, or disjunction.\n\n\n\n\n\n\n{ \"or\": [\n \nfilter\n \n,\n ... \n], \"negate\":\n \nnegate\n \n}\n\n\nA logical disjunction of multiple \nfilter\n clauses is applied to the query to constrain matching rows.\n\n\nThe logical result is negated only if \nnegate\n is \ntrue\n.\n\n\nEach \nfilter\n clause may be a terminal filter element, conjunction, or disjunction.\n\n\n\n\n\n\n{ \"filter\": [\n \nleftalias\n \n,\n \ncolumn\n \n], \"operand\":\n \nvalue\n \n, \"operator\":\n \noperator\n \n, \"negate\":\n \nnegate\n \n}\n\n\nAn individual filter \nelement\n is applied to the query or individual \nfilter\n clauses participate in a conjunction or disjunction.\n\n\nThe filter constrains a named \ncolumn\n in the table named by \nleftalias\n or the current path context if \nleftalias\n is \nnull\n.\n\n\nThe \noperator\n specifies the constraint operator via one of the valid operator names in the ERMrest REST API.\n\n\nThe \nvalue\n specifies the constant operand for a binary constraint operator.\n\n\nThe logical result of the constraint is negated only if \nnegate\n is \ntrue\n.\n\n\n\n\n\n\n\n\nMany fields may be omitted from the above structures to allow concise\nprojection documents:\n\n\n\n\nMany \nnull\n or absent values have a default semantics defined:\n\n\nleftalias\n is omitted to get a default path-based entity context\n\n\nrightalias\n is omitted if no alias binding is required\n\n\nnegate\n is omitted for normal (non-negated) logical decisions\n\n\noperator\n is omitted for regular \n\"=\"\n equality comparisons\n\n\nvalue\n is omitted when the unary \n\"::null::\"\n operator is used\n\n\n\n\n\n\nA few fields are required to be present with a non-null value\n\n\ndirection\n and \nfkeyname\n MUST always be present in link documents.\n\n\nfilter\n MUST always be present in conjunction and disjunction documents.\n\n\ncolumn\n MUST always be present in filter clauses.\n\n\nvalue\n MUST always be present with each binary \noperator\n including the default \n\"=\"\n\n\n\n\n\n\nTwo syntactic short-hands are allowed for bare column names:\n\n\nAn single-element projection \n[\n \ncolumn\n \n]\n MAY omit the array and specify just the string literal \ncolumn\n.\n\n\nAn unqualified filter column \n[ null,\n \ncolumn\n \n]\n MAY omit the array and specify just the string literal \ncolumn\n.\n\n\n\n\n\n\n\n\nEffective ACL Projection Query\n\uf0c1\n\n\nThe \nprojection document\n assumes that a \nbase\nrow query\n similar to \n/ermrest/catalog/N/attribute/Base/key=X/\n will\nbe formulated by the system, and the projection document describes the\nsuffix necessary to turn this into an ACL projection query. E.g. in\nthe \ndynamic ACL example\n above,\nthe projection string \n\"Managed%20By\"\n names a column \nManaged By\n\ncould be appended to a base-row URL to form a complete ACL projection\nquery URL:\n\n\n/ermrest/catalog/N/attribute/My%20Schema:My20Table/key=X/Managed%20By\n\n\n\nFor more complicated projection documents, there is a similar\nmechanical transformation which can produce an effective ACL\nprojection query. The supported projection language covers a subset of\nall possible query URLs.\n\n\nProjection Types\n\uf0c1\n\n\nZero or one rows MAY be returned as the query result. Several\nprojected column types are supported, and more than one projection\ntype is supported. See the following matrix:\n\n\n\n\n\n\n\n\nProjected Column Type\n\n\nSupported \n\"projection_type\"\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntext[]\n\n\nacl\n (default)\n\n\nThe projected array is interpreted as ACL content.\n\n\n\n\n\n\ntext\n\n\nacl\n (default)\n\n\nThe projected text is interpreted as if it were an array containing the single value.\n\n\n\n\n\n\nany\n\n\nnonnull\n\n\nA non-null projected value is interpreted as a \ntrue\n authorization decision.\n\n\n\n\n\n\n\n\nThe \nnonnull\n projection type is supported by all column types. The\n\nacl\n projection type is only supported for the projected column types\nshown above.\n\n\nDynamic ACL Binding Management\n\uf0c1\n\n\nThe ACL binding sub-resources are managed by a simple REST API. They\ncan be embedded in the enclosing resource description during resource\nupdate or resource retrieval. For ACL binding management on existing\nresources, a sub-API is supported on each resource to address one ACL\nbinding by name.\n\n\n\n\n.../acl_binding\n: collection of all named ACL bindings\n\n\nGET: retrieve ACL binding collection\n\n\nPUT: replace ACL binding collection\n\n\nDELETE: unconfigure ACL binding collection\n\n\n.../acl_binding/name\n: individually named ACL binding\n\n\nGET: retrieve one ACL\n\n\nPUT: replace one ACL\n\n\nDELETE: unconfigure one ACL\n\n\n\n\nAn ACL binding collection returns a JSON representation identical to\nthat described previously, providing an object keyed by ACL binding\nname. Each individual ACL binding is a JSON object with \n\"type\"\n and\n\n\"projection\"\n fields.\n\n\n\n\n\n\n\n\nGoverned Resource\n\n\nExample ACL Binding URL\n\n\n\n\n\n\n\n\n\n\nTable\n\n\n/ermrest/catalog/N/schema/S/table/T/acl_binding/My%20Binding\n\n\n\n\n\n\nColumn\n\n\n/ermrest/catalog/N/schema/S/table/T/column/C/acl_binding/My%20Binding\n\n\n\n\n\n\nForeign Key\n\n\n/ermrest/catalog/N/schema/S/table/T/foreignkey/C1/reference/S2:T2/C2/acl_binding/My%20Binding\n\n\n\n\n\n\n\n\nAccess Decision Introspection\n\uf0c1\n\n\nBecause many user-interfaces benefit from anticipating policy\ndecisions and customizing the options presented to the user, ERMrest\nexposes decision information summarizing the effects of currently\nactive policy. These rights summaries take into account the requesting\nclient's privileges.\n\n\nThe decision information is presented in different ways depending\non the resource and access mode:\n\n\n\n\nAn invisible catalog will raise an access error for all access requests.\n\n\nAn invisible model element will be omitted from the catalog introspection response and raise an error for all direct access or dependent access requests (i.e. a client guessing at model elements not shown in the introspection).\n\n\nSchemas can be entirely hidden.\n\n\nTables can be entirely hidden.\n\n\nColumns can be entirely hidden.\n\n\nKeys and foreign keys will be hidden if their constituent columns disallow data selection.\n\n\n\n\n\n\nSome access rights will be advertised on model elements in the introspection document.\n\n\nAn invisible row or datum will be filtered during queries (both for data retrieval and queries in support of data-modifying requests).\n\n\nDatum-specific access rights will be advertised on retrieved data rows.\n\n\nDatum-specific expression rights will be advertised on foreign key reference constraints as a filtered domain query.\n\n\n\n\nStatic Rights Summary\n\uf0c1\n\n\nThe \n\"rights\"\n sub-resources appear throughout the schema\nintrospection document to describe the requesting client's rights. The\nfollowing illustrates where these rights are distributed on sub-resources:\n\n\n{\n  \"rights\": {\n    \"owner\": bool,\n    \"create\": bool\n  },\n  \"schemas\": {\n    \"S\": {\n      \"rights\": {\n        \"owner\": bool,\n        \"create\": bool\n      },\n      \"tables\": {\n        \"T\": {\n          \"rights\": {\n            \"owner\": bool,\n            \"insert\": bool,\n            \"update\": bool,\n            \"delete\": bool,\n            \"select\": bool\n          },\n          \"column_definitions\": [\n            {\n              \"name\": \"C\",\n              \"rights\": {\n                \"insert\": bool,\n                \"update\": bool,\n                \"delete\": bool,\n                \"select\": bool\n              }\n            },\n            ...\n          ],\n          \"foreign_keys\": [\n            {\n              \"domain_queries\": {\n                \"insert\": url,\n                \"update\": url\n              },\n              ...\n            },\n            ...\n          ]\n        },\n        ...\n      }\n    },\n    ...\n  }\n}\n\n\n\nModel enumeration access is not indicated through the \n\"rights\"\n\nsub-document. Rather, a model element which does not grant enumeration\nwill be omitted from the catalog introspection results. The rights\nsub-document does not include fields for all ACLs which may be present\non a given model element, but only for the subset of actual access\nmodes which apply to the model element itself. E.g. data access modes\ncan be configured globally on catalogs or schemas, but they only grant\nactual access rights for operations applied to tables or columns.\n\n\nThe \n\"domain_queries\"\n sub-document on a foreign key will specify an\nERMrest query URL which shows the set of allowed values for a given\naccess mode. For foreign keys with dynamic ACL bindings, this query\nmay encode extra filtering on the domain. Without dynamic ACL\nbindings, the query simply encodes the source of the domain values for\nthe foreign-key reference constraint.\n\n\nRow-Level Rights Summary\n\uf0c1\n\n\nWhen dynamic ACL bindings are in effect, the static rights described\nin the preceding section MAY replace the boolean \ntrue\n or \nfalse\n\naccess right decision with \nnull\n meaning the decision cannot be\nstatically determined. In this case, a row-level rights summary can\nbe consulted to understand access rights on existing data.\n\n\nThe \nermrights\n virtual column is available on data rows and has the following\nstructure in each row:\n\n\n{\n  \"update\": bool,\n  \"delete\": bool,\n  \"column_rights\": {\n    \"Column Name\": {\n      \"update\": bool,\n      \"delete\": bool\n    },\n    ...\n  }\n}\n\n\n\nThe \n\"update\"\n and \n\"delete\"\n fields describe row-level mutation\nrights. The \n\"update\"\n field may again be \nnull\n if an update decision\ncannot be made for the entire row but instead must consider the scope\nof affected fields within the row.  The \n\"column_rights\"\n\nsub-document summarizes field-level rights within the row.\n\n\nThere are several compact encoding conventions for this document:\n\n\n\n\nThe entire document may be \nnull\n if static rights completely\n  describe the client's access privileges.\n\n\nIndividual columns may be omitted from the \n\"column_rights\"\n\n  sub-document if static column rights completely describe the\n  client's access privileges.\n\n\nOnly \nupdate\n and \ndelete\n access modes are summarized, since any\n  query results will already be filtered to only show row or column\n  data where \nselect\n is \ntrue\n, and row-level policy cannot control\n  insertion of new rows.\n\n\nThe \n\"column_rights\"\n sub-document may be omitted if it is empty.\n\n\n\n\nPredicting Access Decisions\n\uf0c1\n\n\nTo predict whether a given request will be permitted, all of the\nstatic and row-level rights summaries must be consulted together:\n\n\n\n\nAll involved model resources must be visible in the enumerated model document.\n\n\nThe operation must be allowed by all involved model resources\n\n\nModel rights must allow model access operations\n\n\nStatic data-access rights must not disallow data access operations\n\n\nAffected table or tables must not disallow access in rights advertised on table\n\n\nAffected column or columns must not disallow access in rights advertised on columns\n\n\nForeign key values must be found in domain queries advertised on foreign key reference constraints\n\n\n\n\n\n\n\n\n\n\nRow-dependent access rights must not disallow access on existing data\n\n\nAffected rows must be visible in a query\n\n\nAffected row rights must not disallow data modification operations\n\n\nAffected row-column rights must not disallow data modification operations\n\n\n\n\n\n\n\n\nKeep in mind, even when all rights seem to allow an operation, the\nsubsequent operation may still fail due to either asynchronous changes\nto server state or due to other integrity constraints and operational\nconsiderations not included in the policy system introspection.\n\n\nUsage Scenarios\n\uf0c1\n\n\nMore illustrations might be helpful. Or, a separate cookbook document?\n\n\nBackwards-Compatible Catalog ACLs\n\uf0c1\n\n\nTo get the same effective behavior as older versions of ERMrest, set\ncatalog-level ACLs, leave all other sub-resource ACLs as unconfigured\n\nnull\n values, and do not define any dynamic ACL bindings.\n\n\nSparse Table Restrictions\n\uf0c1\n\n\nStarting with a\n\nbackwards-compatible catalog scenario\n,\nset a more limited ACL on one table. This table will now be subject to\nmore stringent access requirements than the rest of the catalog.\n\n\nSparse Table Exposure\n\uf0c1\n\n\nStarting with a\n\nbackwards-compatible catalog scenario\n,\nset a more inclusive ACL on one table. This table will now be subject\nto less stringent access requirements than the rest of the catalog.\n\n\nSparse Row-Level Restrictions\n\uf0c1\n\n\nStarting with a\n\nrestricted table scenario\n, make sure the\ntable-level ACLs exclude a class of user to whom you wish to grant\nlimited row-level rights (dynamic ACLs are only effective if they\ngrant extra permissions that are not already granted by a\ndata-independent policy). Then, add a dynamic ACL binding which can\nselectively grant access on a row-by-row basis.", 
            "title": "ERMrest Access Control"
        }, 
        {
            "location": "/user-doc/acls/#ermrest-access-control", 
            "text": "", 
            "title": "ERMrest Access Control"
        }, 
        {
            "location": "/user-doc/acls/#scope-of-use-cases-to-address", 
            "text": "The ERMrest resource hierarchy supports a rich set of possible\nresource operations. We intend to provide fine-grained control of\nthese operations, differentiating rights of one user from another in a\nshared system:   Make some content invisible  An entire catalog  An entire schema  An entire table  An entire column of a table  Some rows of a table (as if row does not exist)  Some fields of some rows of a table (as if the value is NULL)    Prevent modification of some content  Access control policy  Table structure  Table constraints  Row insertion  Row modification  Row deletion  Field modification (can change parts of row but not all parts)  Value expression (can apply some values but not others in a given field)    Delegate some rights within a community  Authorize additional owners for sub-resources (can't suppress/mask parent owners from sub-resources)  ~~Delegate management of specific table's structure and constraints~~  Delegate creation of new schema (while protecting other schemas)  Delegate creation of new table (while protecting other tables)    Make sure simple policies are still simple to manage  Entire catalog visible to one group  Entire catalog data mutable by one group  Entire catalog model managed by one group     Complications \uf0c1  Controlling visibility is complicated, particularly when done to the\nextent desired by some use cases we've observed.   Most forms of access depend on other access  Must see model to make sense of data APIs  Must see data to make use of data modification APIs  Must see related data to make sense of reference constraints  Must see policy to make sense of what access mechanisms are available    Reference constraints can expose \"hidden\" data  Rows can be hidden in a domain table's policy  Referring rows might still be visible due to a referring table's more open policy  Presence of hidden domain data is revealed    Integrity constraints can expose \"hidden\" columns  A hidden column will receive default values on insert  A default expression is not guaranteed to satisfy integrity constraints  The conflict error will reveal information about the hidden column  That a column with this name exists  What the default value looks like  What kind of constraint is violated by the default value       We will initially require policy administrators to reconcile most of\nthese problems by forming well coordinated schemas and policies. In\nsome cases, we may be able to improve usability by having the system\nautomatically detect conflicts and/or reconcile them?", 
            "title": "Scope of Use Cases to Address"
        }, 
        {
            "location": "/user-doc/acls/#core-concepts", 
            "text": "Catalog Resource Hierarchy \uf0c1  Policy will be expressed over the hierarchical catalog model, with\npolicies attached to specific resources in the following model\nhierarchy (already present in ERMrest catalog introspection):   Catalog  Schema  Table  Column  Constraint         Access Modes \uf0c1  A number of distinct access modes are defined such that permission can\nbe granted or denied for each mode separately. Some modes are short-hand\nfor a combination of distinct modes, where a general level of access\ncan be further sub-divided into very specific scenarios you might control\nseparately:   Own model element (can do everything)  Create new child model element  Enumerate existing model element  Write data (can make any data change)  Reference to key  Insert new data  Modify existing data  Delete existing data    Select existing data     Ownership is not quite an access mode but convenient to think about as\nthe superior mode to all other modes.  The precise meaning of some data access modes varies by resource type:     Mode  Table  Column  Reference      Insert  Create new row  Set value during row insert  Make reference to key (during row insert)    Update  Modify row  Replace value  Make reference to key (during row update)    Delete  Remove row  Reset to default value  N/A    Select  Observe/detect row  Observe/detect value  N/A     Foreign key reference resources offer control of value expression:\nrather than limiting what row or field can change, they can limit what\nvalues are allowed to be placed into a field. They complement the row\nand column-level access controls which can only consider the current\nvalues of data rather than the proposed new value.  Policy Scoping and Resource Dependencies \uf0c1  A policy attached to a resource will govern access to that\nresource. Because many forms of access depend on multiple resources, a\ncomplete request will be granted or denied based on the conjunction of\npolicies governing each resource involved in the request.  For example:\n- Joined sets can only be viewed if all involved data can be viewed.\n- Data can only be viewed if the enclosing table is visible.\n- A table can only be accessed if its enclosing schema is visible.\n- A schema can only be access if its enclosing catalog is visible.\n- A column can only be modified if its governing reference constraints allow the new value.\n- A key constraint is only visible if the columns it governs are selectable.\n- A foreign key constraint is only visible if the columns it governs are selectable.  The last two dependencies above are more strict than necessary.  A\nconstraint can be well-defined if its constituent columns are\nenumerable. But, in practice most clients cannot do anything useful\nwith the constraint unless it can also see the data, and the presence\nof the useless constraint would only confuse most model-driven clients.  Data-Dependent Policies \uf0c1  Some, but not all, fine-grained access decisions involve data values.\nModel-level Access Control Lists (ACLs) support  data-independent \ndecisions, i.e. granting access to all rows of a table uniformly.\nDynamic ACL bindings support  data-dependent  decisions, i.e. granting\naccess to specific rows of a table.  Data-dependent policies can grant more selective rights to a client\nthat would not be possible with a static policy. The decision process\ndepends on the configured policy:   A data-access request is not well-formed if it depends model elements that are invisible to the client.  Data-visibility policies determine whether a request is allowed:  If data-independent policies permit an access, it is allowed  If data-dependent policies permit an access, it is allowed  If neither, it is denied     In practice, this means that ERMrest can statically solve some policy\ndecisions and make a decision without investigating actual data\nvalues. But, in the worst case, it needs to include dynamic policy\nchecks to decide if a particular access is allowed or denied.  When data-dependent data viewing policies are active, the effective\nresult set is  filtered  by the visibility policy. When only static\nviewing policies are in effect, the request will be denied rather than\nreturning an empty result set.  Policy Inheritance and Implication \uf0c1  A resource owner  always owns all sub-resources . Any sub-resource\nownership policy can only extend the privilege to more clients but can\nnever block the owners  inherited  from the enclosing resource.  Similarly, a more general access right  always implies all\nsub-rights . Any sub-mode policy can extend the privilege to more\nclients but can never block the parent mode. For example, a client\nwith \"data write\" privileges also has \"data insert\" privileges, even\nif the an explicit \"data insert\" policy is empty on the same resource.  For non-ownership policies, a locally unconfigured ( null ) policy on\na sub-resource means the policy will be inherited from the enclosing\nresource. However, any other value including an empty policy ( [] )\nwill  override  the inherited policy for that access mode. Thus,\nlesser privileges may be selectively blocked on specific\nsub-resources.   A local policy can  restrict  access compared to the enclosing resource  One table is read-only in an otherwise read-write schema  One column is hidden in an otherwise read-write table  But ownership can never be restricted in sub-resources    A local policy can  broaden  access compared to the enclosing resource  One table is writable in an otherwise read-only schema  One column is mutable in an otherwise read-only table  Ownership can be extended to more parties on sub-resources    A more specific access mode can be  extended  to more clients  One table is writable by a curator group, and another group can only insert new rows  One column is writable by a curator group, and another group can only set values during row insertion  But a curator group with general write access can not be denied row insert access    But, access decisions still involve resource dependencies  An invisible catalog hides all schemas inside it  An invisible schema hides all tables inside it  An invisible table hides all columns inside it     Model-level ACLs \uf0c1  ACLs are distributed throughout the hierarchical model of the catalog.   The predefined  name  of each ACL identifies the type of access governed.  The  resource  to which the ACL is attached identifies the scope of the access governed.  The  content  of each ACL is a list of disjunctive matching choices which may include the wildcard  *  matching any client.   Catalog ACLs \uf0c1  A catalog-level ACL describes what access to permit on the whole\ncatalog. Catalogs do not inherit ACLs from elsewhere, so an\nunconfigured catalog ACL is not possible.  During catalog creation the  owner  defaults to the requesting\nclient. Other ACLs are set to empty  []  if not otherwise specified in\nthe request.  For catalogs and all other ERMrest resources described below, it is\nimpossible for a client to create or manage a resource while\ndisclaiming ownership in the request. They may set the ownership more\nbroadly, e.g. to a group for which they are a member, rather than\nlisting their client ID as the sole owner. But, they can never\nconfigure a owner ACL which would prevent them from being an owner at\nthe end of the request. The only way to transfer resource ownership is\nto add an additional owner, and then have that other owner strip the\noriginal owner identity from the owner ACL. Alternatively, ownership\ncan be assigned to a particular owners group and then the group\nmembership can fluctuate due to external management without changing\nthe ERMrest ACL content.  Schema ACLs \uf0c1  A schema-level ACL describes what access to permit on the whole\nschema. When not configured locally, the effective schema-level ACL is\ninherited from the catalog.  During schema creation, the  owner  defaults to the requesting client\nor to  null  if the client is also an owner of the catalog at the time\nof creation; all other schema ACLs are set to  null  if not otherwise\nspecified in the request.  Table ACLs \uf0c1  A table-level ACL describes what access to permit on the whole\ntable. When not configured locally, the effective table-level ACL is\ninherited from the schema.  During table creation, the  owner  defaults to the requesting client\nor to  null  if the client is also an owner of the table at the time\nof creation; all other table ACLs are set to  null  if not otherwise\nspecified in the request.  Dynamic table-level ACL bindings  can augment\ntable-level ACLs to enable access to only a subset of data rows.  The\npresence of dynamic ACL bindings for data retrieval access modes\nsuppresses a  403 Forbidden  response which would otherwise be\ngenerated in the absence of a static ACL granting read access;\ninstead, a  200 OK  response is generated where any denied row is\nabsent from the result set.  All static and dynamic table ACLs are disjunctively considered when\ndeciding row access. Any access denied decision for data modifying\nrequests will continue to raise a  403 Forbidden  response.  Column ACLs \uf0c1  A column-level ACL describes what access to permit on the whole\ncolumn. When not configured locally, the effective column-level ACL is\ninherited from the table.  Columns are considered part of the enclosing table resource and do not\nhave separable ownership. Column ACLs are set to  null  if not\notherwise specified in the request.  Dynamic column ACL bindings  can augment\ncolumn-level ACLs to enable access to only a subset of data fields in\nthis column.  The presence of dynamic ACL bindings for data retrieval\naccess modes suppresses a  403 Forbidden  response which would\notherwise be generated in the absence of a static ACL granting read\naccess; instead, a  200 OK  response is generated where any denied\nfield is replaced with a NULL value.  Reference ACLs \uf0c1  A reference-level ACL describes whether to permit foreign key\nreferences to be expressed.  Reference ACLs are set to  [\"*\"]  if not otherwise specified in the\nrequest.  In practice, reference ACLs are less often restricted and so\nthis default simplifies common configurations. A model which needs to\nrestrict expression of foreign keys SHOULD explicitly override the\ndefault ACLs; to completely disable expression of foreign keys, the\nreference ACL set  {\"insert\": [], \"update\": []}  MAY be used.  Reference constraints are considered part of the enclosing table\nresource and do not have separable ownership.  Dynamic reference ACL bindings  can augment\nreference ACLs to enable expression of only a subset of data in a\ncolumn governed by that reference constraint. These ACLs are actually\nmanaged on foreign key reference constraints, but their effect is to\nlimit what new values can be expressed in the foreign key's\nconstituent columns.  Dynamic ACL Bindings \uf0c1  Dynamic ACL bindings configure sources of ACL content associated with\neach individual tuple or datum, i.e. a query which projects\nuser attributes out of the data catalog itself:   The predefined  type  of each ACL binding identifies the mode of access governed.  An arbitrary  name  of each ACL binding facilitates subsequent management tasks on the policy.  The  resource  to which the ACL binding is attached identifies the scope of the access governed.  The  projection  of each ACL binding describes how to retrieve ACL content.   ACL binding projections are a form of ERMrest attribute query in which\nthe query path and projection syntax is specified without the base\ntable instance. The base table instance is inferred from the resource\nscope of the binding.  It is the responsibility of the data modeler to create self-consistent\npolicies. For example, a dynamic ACL binding is only effective for\naccess control if the ACL storage itself is protected from unwanted\nchanges. Because the ACL storage is within the database and subject to\ndata modification APIs, appropriately restrictive policies must be\ndefined to protect the stored ACL content.  Dynamic Defaults \uf0c1  TBD. Provide some remotely manageable mechanism to do basic\nprovenance-tracking idioms where we currently need to use SQL\ntriggers?  I.e. store a client identity, client object, or some data\ndetermined indirectly via a query constrained by client attributes?  Dynamic Table ACLs \uf0c1  A table-level ACL binding describes how to retrieve ACLs which govern\naccess to rows of a table.   The base table for the projection is the bound table itself.  ACLs can be stored in columns of the table itself  ACLs can be stored in related entities    Governed access modes cover whole-entity access:  Row visibility (invisible rows are filtered from results)  Row writing  Row update  Row delete       Dynamic Column ACLs \uf0c1  A column-level ACL binding describes how to retrieve ACLs which govern\naccess to fields within rows of a table.   The base table for the projection is the enclosing table resource for the bound column.  ACLs can be stored in sibling columns of the same table  ACLs can be stored in related entities    Governed access modes cover individual field (table cell) access:  Field visibility (invisible fields are replaced with NULLs)  Field writing  Field targeted during row updates  Field cleared by attribute deletes       Column-level dynamic ACLs are not involved in row insertion nor\ndeletion decisions.  As a convenience, columns inherit the dynamic ACL bindings of their\ntable. Thus, if no column-level ACL bindings are specified, the column\nallows whatever operation the table would allow for that row. The\ncolumn-level policy MAY apply a special binding value of  false  to\nsuppress an ACL binding inherited from the table under the same name.  Dynamic Reference ACLs \uf0c1  A reference-level ACL binding describes how to retrieve ACLs which\ngovern expression of data within fields which are subject to a foreign\nkey reference constraint.   The base table for the projection is the referenced table resource, i.e. the domain table for the constraint.  ACLs can be stored in sibling columns of the referenced key  ACLs can be stored in related entities of the referenced entities    Governed access modes cover individual domain datum access:  Value writing during row insertion or update     No access control distinction is allowed between reference value\ninsertion during row creation and reference value insertion during row\nupdate.  Reference-level dynamic ACLs are not involved in row deletion\ndecisions nor in default value expression during row creation.", 
            "title": "Core Concepts"
        }, 
        {
            "location": "/user-doc/acls/#technical-reference", 
            "text": "Available Static ACL Names \uf0c1  Most of the previously described  access modes  have a\ncorresponding static ACL name associated with them. Some model access rights\nare not separately controlled and instead require full ownership\nrights. This might change in future revisions.  Because more general access mode rights imply lesser access mode\nrights and sub-resources inherit ACLs, brevity in policy\nconfigurations can be achieved:\n- A small set of owners need not be repeated in other ACLs\n- Less privileged roles are mentioned only in their corresponding lesser ACLs\n- Sub-resource ACLs can be set to  null  unless local overrides are needed  Available ACL names and applicability to specific model elements:     ACL Name  Catalog  Schema  Table  Column  Reference      owner  all access  all access  all access  N/A  note1  N/A  note1    create  add schema  add table  N/A  N/A  N/A    select  note2  note2  observe row  observe value  N/A    insert  note2  note2  add row  set value  note3  set value  note3    update  note2  note2  change row  set value  note3  set value  note3    write  note2  note2  all data access  set value  note3  set value  note3    delete  note2  note2  delete row  N/A  N/A    enumerate  introspect  introspect  introspect  introspect  introspect     When a new schema is added to a catalog, or a new table is added to a\nschema, the requesting client becomes the owner of the newly added\nelement.  Notes:\n-  N/A : The named ACL is not supported on this kind of model element.\n-  note1 : Columns and references are considered part of the table and so cannot have local ownership settings.\n-  note2 : Data access ACLs on catalogs and schemas only serve to set inherited access policies for the tables which are sub-resources within those containers respectively. These only have effect if the table does not have a locally configured policy for the same named ACL, and they grant no special access to the catalog or schema itself.\n-  note3 : The insert/update ACLs on columns and references configure whether values can be supplied during that type of operation on the containing row.  As described previously, some access rights imply other rights:     ACL Name  Implies      enumerate     create  enumerate    select  enumerate    insert  enumerate    update  select, enumerate    delete  select, enumerate    write  insert, update, delete, select, enumerate    owner  create, insert, update, delete, select, enumerate     Ownership is inherited even if a sub-resource specifies a locally\nconfigured owner ACL. The effective owner policy is the disjunction of\ninherited owner and local owner policies. Other locally configured ACLs\noverride their respective inherited ACL and so may grant fewer rights\nthan would be granted with the inherited policy.  ACL Representation \uf0c1  The data-independent ACLs are encoded in an  \"acls\"  sub-resource of the\ngoverned resource. This is a hash-map keyed by ACL name. For example,\na schema resource has a canonical representation as in the following\nexample:  {\n  \"schema_name\": \"My Schema\",\n  \"comment\": \"The purpose of My Schema is...\",\n  \"annotations\": ...,\n  \"tables\": ...,\n  \"acls\": {\n    \"owner\": [\"some/user/URI\"],\n    \"select\": [\"*\"]\n  }\n}  This example has locally configured ACLs for the schema owner and\npermits public access to enumerate the schema and select data, but\ninherits other ACLs from the enclosing catalog. For brevity, ACL names\nwith  null  configuration are omitted from the canonical\nrepresentation. Specifying each such ACL name with a literal  null \nhas the same meaning.  ACL Management \uf0c1  The ACL sub-resources are managed by a simple REST API. They can be\nembedded in the enclosing resource description during resource update\nor resource retrieval. For ACL management on existing resources, a\nsub-API is supported on each resource to address one ACL by name.   .../acl : collection of all named ACLs  GET: retrieve ACL collection  PUT: replace all ACLs in collection  DELETE: unconfigure all ACLs in collection  .../acl/name : individually named ACL  GET: retrieve one ACL  PUT: replace one ACL  DELETE: unconfigure one ACL   An ACL collection is the sub-resource described previously: an object\nkeyed by ACL name where unconfigured ACLs are omitted. Each individual\nACL is a JSON array of strings.     Governed Resource  Example for ACL name  A      Catalog  /catalog/N/acl/A    Schema  /catalog/N/schema/S/acl/A    Table  /catalog/N/schema/S/table/T/acl/A    Column  /catalog/N/schema/S/table/T/column/C/acl/A     Available Dynamic ACL Types \uf0c1  Some of the previously described  access modes  have a\ncorresponding dynamic ACL type associated with them. Because dynamic ACLs\nare for data-dependent access, they have more restrictive applicability:     Type  Mode  Implies  Supported Resources      owner  Write data  insert, update, delete, select  table, column, reference    insert  Insert data   reference    update  Modify data   table, column, reference    delete  Delete data   table, column    select  View data   table, column     Table and column-level dynamic ACLs are only applicable to access\nrequests against existing database content. Insertion of new rows can\nonly be granted by a static policy. However, reference-level dynamic\nACLs can grant or deny the ability to specify specific foreign keys \neven during row insertion.  Dynamic data rights do not imply model access. Model access must be\ndetermined in a data-independent manner in order to even pose an\naccess request which might be granted by dynamic access rights.  Dynamic ACL Binding Representation \uf0c1  The data-dependent ACL bindings are encoded in an  \"acl_bindings\" \nsub-resource of the governed resource. This is a hash-map keyed by ACL\nbinding name. For example, a table resource has a canonical\nrepresentation as in the following example:  {\n  \"schema_name\": \"My Schema\",\n  \"table_name\": \"My Table\",\n  \"kind\": \"table\",\n  \"comment\": \"The purpose of My Table is...\",\n  \"annotations\": ...,\n  \"column_definitions\": ...,\n  \"keys\": ...,\n  \"foreign_keys\": ...,\n  \"acls\": {\n    \"write\": [\"some/curator/URI\"]\n  },\n  \"acl_bindings\": {\n    \"My Binding\": {\n      \"types\": [\"owner\"],\n      \"projection\": \"Managed By\",\n      \"projection_type\": \"acl\"\n    }\n  }\n}  This example has an explicitly set, data-independent curator group who\ncan modify all rows in the table, while other data-independent ACLs\nare inherited from the enclosing schema. A dynamic ACL binding called My Row Owners  specifies that an ACL stored in the  Managed By \ncolumn of the table grants  owner  dynamic access type for individual\nrows. The representation uses an array for the  type  so that multiple\naccess modes can be more easily configured without having to repeat the\nsame projection many times.  Inheritence and False Binding \uf0c1  As a convenience, columns effectively inherit the ACL bindings of\ntheir table. A column whose  \"acl_bindings\"  document is empty will\npermit all operations that the table would allow for each row. To\ngrant fewer writes, the column-level  \"acl_bindings\"  MUST override\nthe named bindings inherited from the table.   Replacement: the column MAY provide a different binding document under the same binding name.  Suppression: the column MAY provide a literal  false  value instead of a binding document.   Projection Document \uf0c1  The  \"projection\"  field of the ACL binding is a document representing\na parsed  abstract syntax tree  for an attribute query fragment. The\ngeneral form of the ACL document is an array of path elements:   [   element   ,  ...  ,   column   ]   This corresponds to the serialized query fragment  element/.../column \nto project ACL content from an implicit base entity context using the\nERMrest  /attribute/base  API.  The final  column  MUST be a string\nliteral naming a column in the effective entity-path context. Each\nanterior  element  MAY use one of the following sub-document\nstructures:   { \"context\":   leftalias   ,   direction   :   fkeyname    , \"alias\":   rightalias   }  Links a new table instance to the existing path via inner join  The left-hand path context is the table instance named by  leftalias  or the immediately preceding path context if  leftalias  is  null  or absent.  The alias  \"base\"  is implicitly bound to the base table to which this ACL is bound.    The joining condition is determined by the named foreign key constraint  fkeyname  where one end is tied to the left-hand path context and the other to the newly added table instance.  The  direction  of the joining condition is  \"inbound\"  or  \"outbound\"  and MUST be specified.  The  rightalias  string literal is bound to the new table instance unless it is  null  or absent.  The alias  \"base\"  is reserved and cannot be bound as a  rightalias .      { \"and\": [   filter   ,  ...  ], \"negate\":   negate   }  A logical conjunction of multiple  filter  clauses is applied to the query to constrain matching rows.  The logical result is negated only if  negate  is  true .  Each  filter  clause may be a terminal filter element, conjunction, or disjunction.    { \"or\": [   filter   ,  ...  ], \"negate\":   negate   }  A logical disjunction of multiple  filter  clauses is applied to the query to constrain matching rows.  The logical result is negated only if  negate  is  true .  Each  filter  clause may be a terminal filter element, conjunction, or disjunction.    { \"filter\": [   leftalias   ,   column   ], \"operand\":   value   , \"operator\":   operator   , \"negate\":   negate   }  An individual filter  element  is applied to the query or individual  filter  clauses participate in a conjunction or disjunction.  The filter constrains a named  column  in the table named by  leftalias  or the current path context if  leftalias  is  null .  The  operator  specifies the constraint operator via one of the valid operator names in the ERMrest REST API.  The  value  specifies the constant operand for a binary constraint operator.  The logical result of the constraint is negated only if  negate  is  true .     Many fields may be omitted from the above structures to allow concise\nprojection documents:   Many  null  or absent values have a default semantics defined:  leftalias  is omitted to get a default path-based entity context  rightalias  is omitted if no alias binding is required  negate  is omitted for normal (non-negated) logical decisions  operator  is omitted for regular  \"=\"  equality comparisons  value  is omitted when the unary  \"::null::\"  operator is used    A few fields are required to be present with a non-null value  direction  and  fkeyname  MUST always be present in link documents.  filter  MUST always be present in conjunction and disjunction documents.  column  MUST always be present in filter clauses.  value  MUST always be present with each binary  operator  including the default  \"=\"    Two syntactic short-hands are allowed for bare column names:  An single-element projection  [   column   ]  MAY omit the array and specify just the string literal  column .  An unqualified filter column  [ null,   column   ]  MAY omit the array and specify just the string literal  column .     Effective ACL Projection Query \uf0c1  The  projection document  assumes that a  base\nrow query  similar to  /ermrest/catalog/N/attribute/Base/key=X/  will\nbe formulated by the system, and the projection document describes the\nsuffix necessary to turn this into an ACL projection query. E.g. in\nthe  dynamic ACL example  above,\nthe projection string  \"Managed%20By\"  names a column  Managed By \ncould be appended to a base-row URL to form a complete ACL projection\nquery URL:  /ermrest/catalog/N/attribute/My%20Schema:My20Table/key=X/Managed%20By  For more complicated projection documents, there is a similar\nmechanical transformation which can produce an effective ACL\nprojection query. The supported projection language covers a subset of\nall possible query URLs.  Projection Types \uf0c1  Zero or one rows MAY be returned as the query result. Several\nprojected column types are supported, and more than one projection\ntype is supported. See the following matrix:     Projected Column Type  Supported  \"projection_type\"  Description      text[]  acl  (default)  The projected array is interpreted as ACL content.    text  acl  (default)  The projected text is interpreted as if it were an array containing the single value.    any  nonnull  A non-null projected value is interpreted as a  true  authorization decision.     The  nonnull  projection type is supported by all column types. The acl  projection type is only supported for the projected column types\nshown above.  Dynamic ACL Binding Management \uf0c1  The ACL binding sub-resources are managed by a simple REST API. They\ncan be embedded in the enclosing resource description during resource\nupdate or resource retrieval. For ACL binding management on existing\nresources, a sub-API is supported on each resource to address one ACL\nbinding by name.   .../acl_binding : collection of all named ACL bindings  GET: retrieve ACL binding collection  PUT: replace ACL binding collection  DELETE: unconfigure ACL binding collection  .../acl_binding/name : individually named ACL binding  GET: retrieve one ACL  PUT: replace one ACL  DELETE: unconfigure one ACL   An ACL binding collection returns a JSON representation identical to\nthat described previously, providing an object keyed by ACL binding\nname. Each individual ACL binding is a JSON object with  \"type\"  and \"projection\"  fields.     Governed Resource  Example ACL Binding URL      Table  /ermrest/catalog/N/schema/S/table/T/acl_binding/My%20Binding    Column  /ermrest/catalog/N/schema/S/table/T/column/C/acl_binding/My%20Binding    Foreign Key  /ermrest/catalog/N/schema/S/table/T/foreignkey/C1/reference/S2:T2/C2/acl_binding/My%20Binding", 
            "title": "Technical Reference"
        }, 
        {
            "location": "/user-doc/acls/#access-decision-introspection", 
            "text": "Because many user-interfaces benefit from anticipating policy\ndecisions and customizing the options presented to the user, ERMrest\nexposes decision information summarizing the effects of currently\nactive policy. These rights summaries take into account the requesting\nclient's privileges.  The decision information is presented in different ways depending\non the resource and access mode:   An invisible catalog will raise an access error for all access requests.  An invisible model element will be omitted from the catalog introspection response and raise an error for all direct access or dependent access requests (i.e. a client guessing at model elements not shown in the introspection).  Schemas can be entirely hidden.  Tables can be entirely hidden.  Columns can be entirely hidden.  Keys and foreign keys will be hidden if their constituent columns disallow data selection.    Some access rights will be advertised on model elements in the introspection document.  An invisible row or datum will be filtered during queries (both for data retrieval and queries in support of data-modifying requests).  Datum-specific access rights will be advertised on retrieved data rows.  Datum-specific expression rights will be advertised on foreign key reference constraints as a filtered domain query.   Static Rights Summary \uf0c1  The  \"rights\"  sub-resources appear throughout the schema\nintrospection document to describe the requesting client's rights. The\nfollowing illustrates where these rights are distributed on sub-resources:  {\n  \"rights\": {\n    \"owner\": bool,\n    \"create\": bool\n  },\n  \"schemas\": {\n    \"S\": {\n      \"rights\": {\n        \"owner\": bool,\n        \"create\": bool\n      },\n      \"tables\": {\n        \"T\": {\n          \"rights\": {\n            \"owner\": bool,\n            \"insert\": bool,\n            \"update\": bool,\n            \"delete\": bool,\n            \"select\": bool\n          },\n          \"column_definitions\": [\n            {\n              \"name\": \"C\",\n              \"rights\": {\n                \"insert\": bool,\n                \"update\": bool,\n                \"delete\": bool,\n                \"select\": bool\n              }\n            },\n            ...\n          ],\n          \"foreign_keys\": [\n            {\n              \"domain_queries\": {\n                \"insert\": url,\n                \"update\": url\n              },\n              ...\n            },\n            ...\n          ]\n        },\n        ...\n      }\n    },\n    ...\n  }\n}  Model enumeration access is not indicated through the  \"rights\" \nsub-document. Rather, a model element which does not grant enumeration\nwill be omitted from the catalog introspection results. The rights\nsub-document does not include fields for all ACLs which may be present\non a given model element, but only for the subset of actual access\nmodes which apply to the model element itself. E.g. data access modes\ncan be configured globally on catalogs or schemas, but they only grant\nactual access rights for operations applied to tables or columns.  The  \"domain_queries\"  sub-document on a foreign key will specify an\nERMrest query URL which shows the set of allowed values for a given\naccess mode. For foreign keys with dynamic ACL bindings, this query\nmay encode extra filtering on the domain. Without dynamic ACL\nbindings, the query simply encodes the source of the domain values for\nthe foreign-key reference constraint.  Row-Level Rights Summary \uf0c1  When dynamic ACL bindings are in effect, the static rights described\nin the preceding section MAY replace the boolean  true  or  false \naccess right decision with  null  meaning the decision cannot be\nstatically determined. In this case, a row-level rights summary can\nbe consulted to understand access rights on existing data.  The  ermrights  virtual column is available on data rows and has the following\nstructure in each row:  {\n  \"update\": bool,\n  \"delete\": bool,\n  \"column_rights\": {\n    \"Column Name\": {\n      \"update\": bool,\n      \"delete\": bool\n    },\n    ...\n  }\n}  The  \"update\"  and  \"delete\"  fields describe row-level mutation\nrights. The  \"update\"  field may again be  null  if an update decision\ncannot be made for the entire row but instead must consider the scope\nof affected fields within the row.  The  \"column_rights\" \nsub-document summarizes field-level rights within the row.  There are several compact encoding conventions for this document:   The entire document may be  null  if static rights completely\n  describe the client's access privileges.  Individual columns may be omitted from the  \"column_rights\" \n  sub-document if static column rights completely describe the\n  client's access privileges.  Only  update  and  delete  access modes are summarized, since any\n  query results will already be filtered to only show row or column\n  data where  select  is  true , and row-level policy cannot control\n  insertion of new rows.  The  \"column_rights\"  sub-document may be omitted if it is empty.   Predicting Access Decisions \uf0c1  To predict whether a given request will be permitted, all of the\nstatic and row-level rights summaries must be consulted together:   All involved model resources must be visible in the enumerated model document.  The operation must be allowed by all involved model resources  Model rights must allow model access operations  Static data-access rights must not disallow data access operations  Affected table or tables must not disallow access in rights advertised on table  Affected column or columns must not disallow access in rights advertised on columns  Foreign key values must be found in domain queries advertised on foreign key reference constraints      Row-dependent access rights must not disallow access on existing data  Affected rows must be visible in a query  Affected row rights must not disallow data modification operations  Affected row-column rights must not disallow data modification operations     Keep in mind, even when all rights seem to allow an operation, the\nsubsequent operation may still fail due to either asynchronous changes\nto server state or due to other integrity constraints and operational\nconsiderations not included in the policy system introspection.", 
            "title": "Access Decision Introspection"
        }, 
        {
            "location": "/user-doc/acls/#usage-scenarios", 
            "text": "More illustrations might be helpful. Or, a separate cookbook document?  Backwards-Compatible Catalog ACLs \uf0c1  To get the same effective behavior as older versions of ERMrest, set\ncatalog-level ACLs, leave all other sub-resource ACLs as unconfigured null  values, and do not define any dynamic ACL bindings.  Sparse Table Restrictions \uf0c1  Starting with a backwards-compatible catalog scenario ,\nset a more limited ACL on one table. This table will now be subject to\nmore stringent access requirements than the rest of the catalog.  Sparse Table Exposure \uf0c1  Starting with a backwards-compatible catalog scenario ,\nset a more inclusive ACL on one table. This table will now be subject\nto less stringent access requirements than the rest of the catalog.  Sparse Row-Level Restrictions \uf0c1  Starting with a restricted table scenario , make sure the\ntable-level ACLs exclude a class of user to whom you wish to grant\nlimited row-level rights (dynamic ACLs are only effective if they\ngrant extra permissions that are not already granted by a\ndata-independent policy). Then, add a dynamic ACL binding which can\nselectively grant access on a row-by-row basis.", 
            "title": "Usage Scenarios"
        }, 
        {
            "location": "/user-doc/row-level-security/", 
            "text": "Row-Level Authorization\n\uf0c1\n\n\nWith ERMrest, all web requests execute under daemon accounts with\neponymous PostgresQL roles:\n\n\n\n\nAll service logic as \nermrest\n daemon.\n\n\nThe \nermrest\n role owns all catalogs, schemas, tables,\n    sequences, etc.\n\n\nThe \nFORCE ROW LEVEL SECURITY\n flag is set on every table.\n\n\nThe ERMrest service code tests web client context against stored\n    ACLs to enforce coarse-grained access rights on catalogs.\n\n\n\n\nTherefore, policy features using PostgreSQL roles are insufficient to\nprovide differentiated privileges to data within one catalog for\ndifferent web clients.\n\n\nRow-level security is useful because it allows arbitrary boolean\nexpressions in the policy statements and rewrites these into all\nqueries executed against the database. The policies are \nmixed into\n\nall the data access SQL generated by the ERMrest service, enforcing\nrow-level constraints regardless of how complex the data access\nqueries become.\n\n\nThus, we can effectively grant data access to the \nermrest\n user only\nwhen additional data constraints are met, considering:\n\n\n\n\nThe content of existing rows for SELECT, UPDATE, and DELETE.\n\n\nThe new or replacement row content for INSERT and UPDATE.\n\n\nThe value of \n_ermrest.current_client()\n scalar subquery of type \ntext\n.\n\n\nThe value of \n_ermrest.current_attributes()\n scalar subquery of type \ntext[]\n.\n\n\nOther scalar subqueries which MAY lookup indirect values from other tables to find links between the affected row content and the current ermrest client or attributes context.\n\n\n\n\nNote: row-level security policies can compute arbitrary boolean\nresults based on these input values. There are no built-in concepts of\nownership, access control lists, or any other privilege\nmodel. Operations are simply allowed or denied if the boolean\nexpression returns a true value or not. It is up to the data modeler\nin each table to decide if or how to interpret or restrict the content\nof row data to make access control decisions. There is no distinction\nbetween access control or non-access control data at the SQL nor\nERMrest protocol level.\n\n\nPerformance Considerations\n\uf0c1\n\n\nBecause row-level security policies are effectively injecting SQL\nexpressions into the WHERE clauses of the other service-generated SQL\nqueries, they can dramatically change service performance if used\nindiscriminately.\n\n\n\n\nAvoid using scalar subqueries which access other tables on a\n   row-by-row basis.\n\n\nWhen calling procedures, the effective performance after query\n   planning and optimization depends on the volatility class of the\n   procedure, with performance descending in order: IMMUTABLE, STABLE,\n   VOLATILE.\n\n\nWhen calling procedures defined in pure SQL, they may be better\n   optimized in recent PostgreSQL versions than procedures defined in\n   PL/pgsql.\n\n\nWhen calling procedures in PostgreSQL 9.6, the declaration of\n   PARALLEL SAFE is required to allow parallel query plans. Other\n   factors may still suppress parallelism.\n\n\nFor web applications which run many AJAX calls concurrently, there\n   may be enough parallelism such that parallel plans are not\n   beneficial. They help most for running a single, long-running\n   query.\n\n\nRecent versions of ERMrest define a session parameter\n   \nwebauthn2.attributes_array\n as a native text representation of a\n   PostgreSQL \ntext[]\n value. This supports faster authorization\n   checks than the legacy \nwebauthn2.attributes\n parameter which is a\n   JSON serialization. It requires an updated\n   \n_ermrest.current_attributes()\n stored procedure to have any\n   benefit.\n\n\nPostgreSQL 9.6 introduces a new function \ncurrent_setting(text,\n   bool)\n which can check a session parameter without throwing\n   exceptions when the parameter is absent. A faster, pure SQL\n   implementation of \n_ermrest.current_attributes()\n can exploit this.\n\n\n\n\nA good practice to evaluate impact of row-level policies is to perform\nequivalent queries through the \npsql\n command-line interface using\nthe daemon account and the \nEXPLAIN ANALYZE ...\n command:\n\n\n\n\nBy default, \nermrest\n is subject to row-level security and shows you\n  how much slower it will be when queried by web clients. To emulate a\n  particular web client privilege level, manually set the session\n  parameters in your connection as described below.\n\n\nYou can use a postgres \"super-user\" role to bypass row-level\n  security on tables. \nCaveat\n: note that SQL views are executed with\n  the privileges of the role owning the view, and not the role of the\n  querying user. So, these views when properly owned by \nermrest\n will\n  not bypass row-level security on any tables they consume, even when\n  queried by the super-user.\n\n\n\n\nFor this comparison to be valid, you may need to set session\nparameters to a valid client context. Otherwise the SQL plan may be\nsignificantly different due to the NULL client attributes.\n\n\nHere is a more optimal stored procedure only usable with recent\nERMrest on PostgreSQL 9.6:\n\n\nCREATE OR REPLACE FUNCTION _ermrest.current_attributes() \nRETURNS text[] STABLE PARALLEL SAFE AS $$\n  SELECT current_setting(\n    'webauthn2.attributes_array',\n    True\n  )::text[];\n$$ LANGUAGE SQL;\n\n\n\nThis can be applied manually to an existing catalog to upgrade its\nperformance if you are using PostgreSQL 9.6 already. The ERMrest\ncode-base does not yet include such a definition as we have not yet\nmade a hard requirement on 9.6 features.\n\n\nThis variant can achieve similar performance on 9.5:\n\n\nCREATE OR REPLACE FUNCTION _ermrest.current_attributes() \nRETURNS text[] STABLE AS $$\n  SELECT current_setting(\n    'webauthn2.attributes_array'\n  )::text[];\n$$ LANGUAGE SQL;\n\n\n\nthis procedure will raise exceptions if used in SQL session that is\nnot managed by ERMrest, unlike the ERMrest-supplied implementation\nthat uses PL/pgsql and exception handlers to catch that condition and\nmap it to a NULL result.\n\n\nTo manually simulate an ERMrest-managed client session for testing,\nyou can connect using the \nermrest\n daemon role and manually set the\nattributes. Assuming the above implementations are in place, you\nwould do:\n\n\nSELECT set_config(\n  'webauthn2.attributes_array',\n  (ARRAY['attr1', 'attr2']::text[])::text,\n  False\n);\n\n\n\nor with the legacy implementation you would instead do:\n\n\nSELECT set_config(\n  'webauthn2.attributes',\n  '[\"attr1\", \"attr2\"]',\n  False\n);\n\n\n\nWhere \nattr1\n and \nattr2\n are actually attribute URIs obtained from a\nvalid webauthn session.  If you retrieve a session object manually and\nstore it to \nsession.json\n, you might obtain the list of attribute\nURIs with the following Python snippet:\n\n\nimport json\n\nf = open('session.json')\ns = json.load(f)\n[ a['id'] for a in s['attributes'] ]\n\n\n\nOther Considerations\n\uf0c1\n\n\nRow-level security affects all access to tables for which it is\nenabled. Backup database dumps could be incomplete unless taken by a\nPostgreSQL superuser and/or with row level security temporarily\ndisabled.\n\n\nWe have observed problems with round-tripping of row-level security\npolicies from functioning databases, to dumps created by \npg_dump\n,\nand back to restored databases. Some important type casts and similar\nmay be lost in the policy that is dumped, such that PostgreSQL refuses\nto load the policies again.  Thus, anyone experimenting with row-level\nsecurity SHOULD maintain an authoritative policy SQL file and be\nprepared to eliminate policies from a dump, restore the modified dump,\nthen reapply the authoritative policies.\n\n\nOther detailed issues:\n\n\n\n\nThe owner of a table bypasses row-level security unless \nFORCE ROW LEVEL SECURITY\n is kept on for the table.\n\n\nDBAs SHOULD NOT attempt to introduce tables in ermrest backing databases which are not owned by the \nermrest\n role.\n\n\nDBAs SHOULD NOT attempt to introduce SQL views which are not owned by the \nermrest\n role.\n\n\n\n\nInstructions and Examples\n\uf0c1\n\n\n\n\nUpgrade your postgres to 9.5 or later\n\n\nHave latest ERMrest master code deployed with \nFORCE ROW LEVEL SECURITY\n on all tables.\n\n\nEnable row-level security on specific table\n\n\nCreate row-level policies to access table data\n\n\nDrop or alter row-level policies by name\n\n\n\n\nNOTE: the following examples use old-style group IDs as with the \ngoauth\n webauthn provider. In the future, such group IDs will replace the \ng:\n prefix with a URL designating the group membership provider who asserted the group membership attribute.\n\n\nExample 1: Enable row-level security\n\uf0c1\n\n\nALTER TABLE my_example ENABLE ROW LEVEL SECURITY;\n\n\n\nAt this point, ERMrest should still work (a smart thing to test) but data operations on this table will fail as the default policies do not allow any operations on any row data!  Go back to normal with:\n\n\nALTER TABLE my_example DISABLE ROW LEVEL SECURITY;\n\n\n\nExample 2: Create row-level policies to restore all access\n\uf0c1\n\n\nCREATE POLICY select_all ON my_example FOR SELECT USING (True);\nCREATE POLICY delete_all ON my_example FOR DELETE USING (True);\nCREATE POLICY insert_all ON my_example FOR INSERT WITH CHECK (True);\nCREATE POLICY update_all ON my_example FOR UPDATE USING (True) WITH CHECK (True);\n\n\n\nAt this point, all data access is possible again.  In general, the \nUSING (expr)\n part must evaluate to true for existing rows to be accessed while \nWITH CHECK (expr)\n part must evaluate true for new row content to be applied. The \nUSING\n and \nWITH CHECK\n policies MAY reference column data from the existing or new row data, respectively; it is not possible to consider both existing and replacement row content in a single policy expression.\n\n\nExample 3: Drop policies to limit it again\n\uf0c1\n\n\nDROP POLICY update_all ON my_example;\nDROP POLICY insert_all ON my_example;\nDROP POLICY delete_all ON my_example;\nDROP POLICY select_all ON my_example;\n\n\n\nExample 4: Check against webauthn context but not row data, e.g. to emulate a table-level privilege using webauthn roles instead of PostgreSQL roles\n\uf0c1\n\n\nCREATE POLICY select_group\nON my_example\n    FOR SELECT\n    USING ( 'g:f69e0a7a-99c6-11e3-95f6-12313809f035' = ANY (_ermrest.current_attributes()) );\n\nCREATE POLICY select_user\nON my_example\n  FOR SELECT\n  USING ( 'devuser' = _ermrest.current_client() );\n\n\n\nExample 5: Consider row-data in more complete example, assuming the table includes \nowner\n and \nacl\n columns of type \ntext\n and \ntext[]\n, respectively\n\uf0c1\n\n\n-- allow members of group to insert but enforce provenance of owner column\nCREATE POLICY insert_group\nON my_example\n  FOR INSERT\n  WITH CHECK (\n    'g:f69e0a7a-99c6-11e3-95f6-12313809f035' = ANY (_ermrest.current_attributes())\n  AND owner = _ermrest.current_client()\n);\n\n-- owner can update his own rows\n-- but continue to enforce provenance of owner column too\nCREATE POLICY update_owner\nON my_example\n  FOR UPDATE\n  USING ( owner = _ermrest.current_client() )\n  WITH CHECK ( owner = _ermrest.current_client() ) ;\n\n-- owner can delete his own rows\nCREATE POLICY delete_owner\n  ON my_example\n  FOR DELETE\n  USING ( owner = _ermrest.current_client() );\n\n-- owner can read\n-- as can members of groups in ACL\nCREATE POLICY select_owner_acl\n  ON my_example\n  FOR SELECT\n  USING (\n    owner = _ermrest.current_client()\n  OR acl \n _ermrest.current_attributes()\n);", 
            "title": "Row-Level Authorization"
        }, 
        {
            "location": "/user-doc/row-level-security/#row-level-authorization", 
            "text": "With ERMrest, all web requests execute under daemon accounts with\neponymous PostgresQL roles:   All service logic as  ermrest  daemon.  The  ermrest  role owns all catalogs, schemas, tables,\n    sequences, etc.  The  FORCE ROW LEVEL SECURITY  flag is set on every table.  The ERMrest service code tests web client context against stored\n    ACLs to enforce coarse-grained access rights on catalogs.   Therefore, policy features using PostgreSQL roles are insufficient to\nprovide differentiated privileges to data within one catalog for\ndifferent web clients.  Row-level security is useful because it allows arbitrary boolean\nexpressions in the policy statements and rewrites these into all\nqueries executed against the database. The policies are  mixed into \nall the data access SQL generated by the ERMrest service, enforcing\nrow-level constraints regardless of how complex the data access\nqueries become.  Thus, we can effectively grant data access to the  ermrest  user only\nwhen additional data constraints are met, considering:   The content of existing rows for SELECT, UPDATE, and DELETE.  The new or replacement row content for INSERT and UPDATE.  The value of  _ermrest.current_client()  scalar subquery of type  text .  The value of  _ermrest.current_attributes()  scalar subquery of type  text[] .  Other scalar subqueries which MAY lookup indirect values from other tables to find links between the affected row content and the current ermrest client or attributes context.   Note: row-level security policies can compute arbitrary boolean\nresults based on these input values. There are no built-in concepts of\nownership, access control lists, or any other privilege\nmodel. Operations are simply allowed or denied if the boolean\nexpression returns a true value or not. It is up to the data modeler\nin each table to decide if or how to interpret or restrict the content\nof row data to make access control decisions. There is no distinction\nbetween access control or non-access control data at the SQL nor\nERMrest protocol level.", 
            "title": "Row-Level Authorization"
        }, 
        {
            "location": "/user-doc/row-level-security/#performance-considerations", 
            "text": "Because row-level security policies are effectively injecting SQL\nexpressions into the WHERE clauses of the other service-generated SQL\nqueries, they can dramatically change service performance if used\nindiscriminately.   Avoid using scalar subqueries which access other tables on a\n   row-by-row basis.  When calling procedures, the effective performance after query\n   planning and optimization depends on the volatility class of the\n   procedure, with performance descending in order: IMMUTABLE, STABLE,\n   VOLATILE.  When calling procedures defined in pure SQL, they may be better\n   optimized in recent PostgreSQL versions than procedures defined in\n   PL/pgsql.  When calling procedures in PostgreSQL 9.6, the declaration of\n   PARALLEL SAFE is required to allow parallel query plans. Other\n   factors may still suppress parallelism.  For web applications which run many AJAX calls concurrently, there\n   may be enough parallelism such that parallel plans are not\n   beneficial. They help most for running a single, long-running\n   query.  Recent versions of ERMrest define a session parameter\n    webauthn2.attributes_array  as a native text representation of a\n   PostgreSQL  text[]  value. This supports faster authorization\n   checks than the legacy  webauthn2.attributes  parameter which is a\n   JSON serialization. It requires an updated\n    _ermrest.current_attributes()  stored procedure to have any\n   benefit.  PostgreSQL 9.6 introduces a new function  current_setting(text,\n   bool)  which can check a session parameter without throwing\n   exceptions when the parameter is absent. A faster, pure SQL\n   implementation of  _ermrest.current_attributes()  can exploit this.   A good practice to evaluate impact of row-level policies is to perform\nequivalent queries through the  psql  command-line interface using\nthe daemon account and the  EXPLAIN ANALYZE ...  command:   By default,  ermrest  is subject to row-level security and shows you\n  how much slower it will be when queried by web clients. To emulate a\n  particular web client privilege level, manually set the session\n  parameters in your connection as described below.  You can use a postgres \"super-user\" role to bypass row-level\n  security on tables.  Caveat : note that SQL views are executed with\n  the privileges of the role owning the view, and not the role of the\n  querying user. So, these views when properly owned by  ermrest  will\n  not bypass row-level security on any tables they consume, even when\n  queried by the super-user.   For this comparison to be valid, you may need to set session\nparameters to a valid client context. Otherwise the SQL plan may be\nsignificantly different due to the NULL client attributes.  Here is a more optimal stored procedure only usable with recent\nERMrest on PostgreSQL 9.6:  CREATE OR REPLACE FUNCTION _ermrest.current_attributes() \nRETURNS text[] STABLE PARALLEL SAFE AS $$\n  SELECT current_setting(\n    'webauthn2.attributes_array',\n    True\n  )::text[];\n$$ LANGUAGE SQL;  This can be applied manually to an existing catalog to upgrade its\nperformance if you are using PostgreSQL 9.6 already. The ERMrest\ncode-base does not yet include such a definition as we have not yet\nmade a hard requirement on 9.6 features.  This variant can achieve similar performance on 9.5:  CREATE OR REPLACE FUNCTION _ermrest.current_attributes() \nRETURNS text[] STABLE AS $$\n  SELECT current_setting(\n    'webauthn2.attributes_array'\n  )::text[];\n$$ LANGUAGE SQL;  this procedure will raise exceptions if used in SQL session that is\nnot managed by ERMrest, unlike the ERMrest-supplied implementation\nthat uses PL/pgsql and exception handlers to catch that condition and\nmap it to a NULL result.  To manually simulate an ERMrest-managed client session for testing,\nyou can connect using the  ermrest  daemon role and manually set the\nattributes. Assuming the above implementations are in place, you\nwould do:  SELECT set_config(\n  'webauthn2.attributes_array',\n  (ARRAY['attr1', 'attr2']::text[])::text,\n  False\n);  or with the legacy implementation you would instead do:  SELECT set_config(\n  'webauthn2.attributes',\n  '[\"attr1\", \"attr2\"]',\n  False\n);  Where  attr1  and  attr2  are actually attribute URIs obtained from a\nvalid webauthn session.  If you retrieve a session object manually and\nstore it to  session.json , you might obtain the list of attribute\nURIs with the following Python snippet:  import json\n\nf = open('session.json')\ns = json.load(f)\n[ a['id'] for a in s['attributes'] ]", 
            "title": "Performance Considerations"
        }, 
        {
            "location": "/user-doc/row-level-security/#other-considerations", 
            "text": "Row-level security affects all access to tables for which it is\nenabled. Backup database dumps could be incomplete unless taken by a\nPostgreSQL superuser and/or with row level security temporarily\ndisabled.  We have observed problems with round-tripping of row-level security\npolicies from functioning databases, to dumps created by  pg_dump ,\nand back to restored databases. Some important type casts and similar\nmay be lost in the policy that is dumped, such that PostgreSQL refuses\nto load the policies again.  Thus, anyone experimenting with row-level\nsecurity SHOULD maintain an authoritative policy SQL file and be\nprepared to eliminate policies from a dump, restore the modified dump,\nthen reapply the authoritative policies.  Other detailed issues:   The owner of a table bypasses row-level security unless  FORCE ROW LEVEL SECURITY  is kept on for the table.  DBAs SHOULD NOT attempt to introduce tables in ermrest backing databases which are not owned by the  ermrest  role.  DBAs SHOULD NOT attempt to introduce SQL views which are not owned by the  ermrest  role.", 
            "title": "Other Considerations"
        }, 
        {
            "location": "/user-doc/row-level-security/#instructions-and-examples", 
            "text": "Upgrade your postgres to 9.5 or later  Have latest ERMrest master code deployed with  FORCE ROW LEVEL SECURITY  on all tables.  Enable row-level security on specific table  Create row-level policies to access table data  Drop or alter row-level policies by name   NOTE: the following examples use old-style group IDs as with the  goauth  webauthn provider. In the future, such group IDs will replace the  g:  prefix with a URL designating the group membership provider who asserted the group membership attribute.  Example 1: Enable row-level security \uf0c1  ALTER TABLE my_example ENABLE ROW LEVEL SECURITY;  At this point, ERMrest should still work (a smart thing to test) but data operations on this table will fail as the default policies do not allow any operations on any row data!  Go back to normal with:  ALTER TABLE my_example DISABLE ROW LEVEL SECURITY;  Example 2: Create row-level policies to restore all access \uf0c1  CREATE POLICY select_all ON my_example FOR SELECT USING (True);\nCREATE POLICY delete_all ON my_example FOR DELETE USING (True);\nCREATE POLICY insert_all ON my_example FOR INSERT WITH CHECK (True);\nCREATE POLICY update_all ON my_example FOR UPDATE USING (True) WITH CHECK (True);  At this point, all data access is possible again.  In general, the  USING (expr)  part must evaluate to true for existing rows to be accessed while  WITH CHECK (expr)  part must evaluate true for new row content to be applied. The  USING  and  WITH CHECK  policies MAY reference column data from the existing or new row data, respectively; it is not possible to consider both existing and replacement row content in a single policy expression.  Example 3: Drop policies to limit it again \uf0c1  DROP POLICY update_all ON my_example;\nDROP POLICY insert_all ON my_example;\nDROP POLICY delete_all ON my_example;\nDROP POLICY select_all ON my_example;  Example 4: Check against webauthn context but not row data, e.g. to emulate a table-level privilege using webauthn roles instead of PostgreSQL roles \uf0c1  CREATE POLICY select_group\nON my_example\n    FOR SELECT\n    USING ( 'g:f69e0a7a-99c6-11e3-95f6-12313809f035' = ANY (_ermrest.current_attributes()) );\n\nCREATE POLICY select_user\nON my_example\n  FOR SELECT\n  USING ( 'devuser' = _ermrest.current_client() );  Example 5: Consider row-data in more complete example, assuming the table includes  owner  and  acl  columns of type  text  and  text[] , respectively \uf0c1  -- allow members of group to insert but enforce provenance of owner column\nCREATE POLICY insert_group\nON my_example\n  FOR INSERT\n  WITH CHECK (\n    'g:f69e0a7a-99c6-11e3-95f6-12313809f035' = ANY (_ermrest.current_attributes())\n  AND owner = _ermrest.current_client()\n);\n\n-- owner can update his own rows\n-- but continue to enforce provenance of owner column too\nCREATE POLICY update_owner\nON my_example\n  FOR UPDATE\n  USING ( owner = _ermrest.current_client() )\n  WITH CHECK ( owner = _ermrest.current_client() ) ;\n\n-- owner can delete his own rows\nCREATE POLICY delete_owner\n  ON my_example\n  FOR DELETE\n  USING ( owner = _ermrest.current_client() );\n\n-- owner can read\n-- as can members of groups in ACL\nCREATE POLICY select_owner_acl\n  ON my_example\n  FOR SELECT\n  USING (\n    owner = _ermrest.current_client()\n  OR acl   _ermrest.current_attributes()\n);", 
            "title": "Instructions and Examples"
        }, 
        {
            "location": "/user-doc/tuning/", 
            "text": "Performance Tuning\n\uf0c1\n\n\nThere are a few things you can do to improve performance of your new ERMrest installation.\n- Tune Apache HTTPD to allow better reuse of TLS connections\n  - \nKeepAlive On\n\n  - \nMaxKeepAliveRequests 1000\n\n  - \nKeepAliveTimeout 30\n\n- Tune Postgres for your server capacity and workload\n  - \nshared_buffers = 1GB\n ?\n  - \nwork_mem = 128MB\n ?\n  - \nmaintenance_work_mem = 128MB\n ?\n  - \neffective_cache_size = 8 GB\n (your typical file buffer cache size available to Postgres...)\n  - \nfrom_collapse_limit = 500\n (stronger optimization of complex queries)\n  - \njoin_collapse_limit = 500\n (stronger optimization of complex queries)\n  - \ngeqo_threshold = 10\n (may affect planner latency)\n  - \ngeqo_effort = 5\n (May affect planner latency)\n- Vacuum databases to allow better query planner optimization\n  - Run \nVACUUM ANALYZE\n on \nermrest\n database that holds registry of catalogs\n  - Run \nVACUUM ANALYZE\n on each \n_ermrest_\n \nRANDOMKEY\n database that holds catalog-specific data\n- Create indices to accelerate text-search and regular expression operators. Without these indices, all text-search will be brute-force and visit every row of the filtered table to evaluate the requested text patterns. We provide a command-line utility to assist in creating (or recreating) the appropriate value indices which will accelerate the two free text search modes. It takes a catalog ID number as first argument and one or more schema names as subsequent arguments; it will create indices on all tables in each schema specified on the command-line:\n    - \nermrest-freetext-indices 1 public myschema1", 
            "title": "Performance Tuning"
        }, 
        {
            "location": "/user-doc/tuning/#performance-tuning", 
            "text": "There are a few things you can do to improve performance of your new ERMrest installation.\n- Tune Apache HTTPD to allow better reuse of TLS connections\n  -  KeepAlive On \n  -  MaxKeepAliveRequests 1000 \n  -  KeepAliveTimeout 30 \n- Tune Postgres for your server capacity and workload\n  -  shared_buffers = 1GB  ?\n  -  work_mem = 128MB  ?\n  -  maintenance_work_mem = 128MB  ?\n  -  effective_cache_size = 8 GB  (your typical file buffer cache size available to Postgres...)\n  -  from_collapse_limit = 500  (stronger optimization of complex queries)\n  -  join_collapse_limit = 500  (stronger optimization of complex queries)\n  -  geqo_threshold = 10  (may affect planner latency)\n  -  geqo_effort = 5  (May affect planner latency)\n- Vacuum databases to allow better query planner optimization\n  - Run  VACUUM ANALYZE  on  ermrest  database that holds registry of catalogs\n  - Run  VACUUM ANALYZE  on each  _ermrest_   RANDOMKEY  database that holds catalog-specific data\n- Create indices to accelerate text-search and regular expression operators. Without these indices, all text-search will be brute-force and visit every row of the filtered table to evaluate the requested text patterns. We provide a command-line utility to assist in creating (or recreating) the appropriate value indices which will accelerate the two free text search modes. It takes a catalog ID number as first argument and one or more schema names as subsequent arguments; it will create indices on all tables in each schema specified on the command-line:\n    -  ermrest-freetext-indices 1 public myschema1", 
            "title": "Performance Tuning"
        }, 
        {
            "location": "/user-doc/annotation/", 
            "text": "Model Annotation\n\uf0c1\n\n\nThis document defines a set of annotations we suggest may be useful in\ncombination with ERMrest. We define a set of \nannotation keys\n, any\nassociated JSON \nannotation values\n, and their semantics. Communities\nmay use these conventions to modify their interpretation of ERMrest\ncatalog content.\n\n\nThese annotations do not affect the behavior of the ERMrest service\nitself but merely inform clients about intended use beyond that\ncaptured in the entity-relationship model. Further, as described in\nthe \nREST API docs\n, the annotation system is\nopenly extensible so communities MAY use other annotation keys not\ndescribed here; in those cases, the community SHOULD publish similar\ndocumentation on their use and interpretation.\n\n\nNotation and Usage\n\uf0c1\n\n\nEach annotation key is defined in a section of this document and shown\nas a literal string.  We prepend a date in each key name and promise\nnot to modify the semantics of an existing annotation key, once\npublished to GitHub. We may publish typographical or other small\ntextual clarifications, but if we need to change the proposed\nsemantics we will define a new key with a different date and/or key\ntext. We will follow the date stamp conventions from\n\nRFC 4151\n which allow for\nabbreviated ISO dates such as \n2015\n, \n2015-01\n, and \n2015-01-01\n.\n\n\nExample to Set Annotation\n\uf0c1\n\n\nThis example sets the\n\n2015 Display\n annotation:\n\n\nPUT /ermrest/catalog/1/schema/MainContent/annotation/tag%3Amisd.isi.edu%2C2015%3Adisplay HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\"name\": \"Main Content\"}\n\n\n\nTBD changes to propose for ERMrest:\n\n\n\n\nAllow non-escaped characters in the annotation key since it is the final field of the URL and does not have a parsing ambiguity?\n\n\nAllow an empty (0 byte) request body to represent the same thing as JSON \nnull\n?\n\n\n\n\nAnnotations\n\uf0c1\n\n\nSome annotations are supported on multiple types of model element, so\nhere is a quick matrix to locate them.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nSchema\n\n\nTable\n\n\nColumn\n\n\nKey\n\n\nFKR\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\n2015 Display\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nDisplay options\n\n\n\n\n\n\n2015 Vocabulary\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nTable as a vocabulary list\n\n\n\n\n\n\n2016 Table Alternatives\n\n\n-\n\n\nX\n\n\n-\n\n\n_\n\n\n_\n\n\nTable abstracts another table\n\n\n\n\n\n\n2016 Column Display\n\n\n-\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\nColumn-specific display options\n\n\n\n\n\n\n2017 Key Display\n\n\n-\n\n\n-\n\n\n-\n\n\nX\n\n\n-\n\n\nKey augmentation\n\n\n\n\n\n\n2016 Foreign Key\n\n\n-\n\n\n-\n\n\n-\n\n\n-\n\n\nX\n\n\nForeign key augmentation\n\n\n\n\n\n\n2016 Generated\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\nGenerated model element\n\n\n\n\n\n\n2016 Ignore\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\nIgnore model element\n\n\n\n\n\n\n2016 Immutable\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\nImmutable model element\n\n\n\n\n\n\n2016 Non Deletable\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nNon-deletable model element\n\n\n\n\n\n\n2016 App Links\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nIntra-Chaise app links\n\n\n\n\n\n\n2016 Table Display\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nTable-specific display options\n\n\n\n\n\n\n2016 Visible Columns\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nColumn visibility and presentation order\n\n\n\n\n\n\n2016 Visible Foreign Keys\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nForeign key visibility and presentation order\n\n\n\n\n\n\n2017 Asset\n\n\n-\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\nDescribes assets\n\n\n\n\n\n\n\n\nFor brevity, the annotation keys are listed above by their section\nname within this documentation. The actual key URI follows the form\n\ntag:misd.isi.edu,\n \ndate\n \n:\n \nkey\n where the \nkey\n part is\nlower-cased with hyphens replacing whitespace. For example, the\n\n2015 Display\n annotation key URI is actually\n\ntag:misd.isi.edu,2015:display\n.\n\n\n2015 Display\n\uf0c1\n\n\ntag:misd.isi.edu,2015:display\n\n\nThis key is allowed on any number of schemas, tables,\ncolumns, and keys. This annotation indicates display options for the indicated\nelement and its nested model elements.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n... \n\"name\":\n \nname\n ...\n}\n: The \nname\n to use in place of the model element's original name.\n\n\n{\n... \n\"markdown_name\"\n: \nmarkdown\n \n}\n: The \nmarkdown\n to use in place of the model element's original name.\n\n\n{\n... \n\"name_style\":\n \n{\n \n\"underline_space\"\n: \nuspace\n \n,\n \n\"title_case\":\n \ntcase\n \n,\n \n\"markdown\"\n: \nrender\n \n}\n ...\n}\n: Element name conversion instructions.\n\n\n{\n... \n\"show_nulls\":\n \n{\n \nncontext\n \n:\n \nnshow\n \n,\n ... \n}\n: How to display NULL data values.\n\n\n\n\nSupported JSON \nuspace\n patterns:\n\n\n\n\ntrue\n: Convert underline characters (\n_\n) into space characters in model element names.\n\n\nfalse\n: Leave underline characters unmodified (this is also the default if the setting is completely absent).\n\n\n\n\nSupported JSON \ntcase\n patterns:\n\n\n\n\ntrue\n: Convert element names to \"title case\" meaning the first character of each word is capitalized and the rest are lower cased regardless of model element name casing. Word separators include white-space, hyphen, and underline characters.\n\n\nfalse\n: Leave character casing unmodified (this is also the default if the setting is completely absent).\n\n\n\n\nSupported JSON \nrender\n patterns:\n\n\n\n\ntrue\n: Interpret the model element's actual name as a Markdown string. This MAY include rendering visually in applications with such capability.\n\n\nfalse\n: Present the model element's actual name verbatim (this is also the default if the setting is completely absent).\n\n\n\n\nSupported JSON \nnshow\n patterns:\n\n\n\n\ntrue\n (or \n\"\"\n): Show NULL values as an empty field.\n\n\n\"\n \nmarker\n \n\"\n (a quoted string literal): For any string literal \nmarker\n, display the marker text value in place of NULLs.\n\n\nfalse\n: Completely eliminate the field if feasible in the presentation.\n\n\n\n\nSee \nContext Names\n section for the list of supported JSON \nncontext\n patterns.\n\n\n2015 Display Settings Hierarchy\n\uf0c1\n\n\n\n\nThe \n\"name\"\n and \n\"markdown_name\"\n setting applies \nonly\n to the model element which is annotated. They bypass the \nname_style\n controls which only apply to actual model names.\n\n\nThe \n\"markdown_name\"\n setting takes precedence if both are specified.\n\n\nThe \n\"name_style\"\n setting applies to the annotated model element and is also the default for any nested element.\n\n\nThe \n\"show_nulls\"\n settings applies to the annotated model element and is also the default for any nested element.\n\n\nThe annotation is allowed on schemas in order to set the default for all tables in the schema.\n\n\nEach \nncontext\n \n:\n \nnshow\n instruction overrides the inherited instruction for the same \nncontext\n while still deferring to the inherited annotation for any unspecified \nncontext\n. The \n\"*\"\n wildcard \nncontext\n allows masking of any inherited instruction.\n\n\nA global default is assumed: \n{\n... \n\"show_nulls\": { \"detailed\": false, \"*\": true\n ... \n}\n\n\n\n\nThis annotation provides an override guidance for Chaise applications using a hierarchical scoping mode:\n\n\n\n\nColumn-level name\n\n\nColumn-level name_style.\n\n\nTable-level name_style.\n\n\nSchema-level name_style.\n\n\n\n\nNote:\n- An explicit setting of \nnull\n will turn \noff\n inheritence and restore default behavior for that modele element and any of its nested elements.\n- The name_style has to be derived separately for each field e.g. one can set \nunderline_space=true\n at the schema-level and doesn't have to set this again.   \n\n\n2015 Vocabulary\n\uf0c1\n\n\ntag:misd.isi.edu,2015:vocabulary\n\n\nThis key is allowed on any number of tables in the model, where the\ntable contains at least one key comprised of a single textual\ncolumn. A vocabulary table is one where each row represents a term or\nconcept in a controlled vocabulary.\n\n\nSupported JSON payload patterns:\n\n\n\n\nnull\n or \n{}\n: Default heuristics apply.\n\n\n{\n... \n\"uri\":\n \nuri\n ...\n}\n: The \nuri\n indicates the global identifier of the controlled vocabulary. The \nuri\n MAY be a resolvable URL.\n\n\n{\n... \n\"term\":\n \ncolumn\n ...\n}\n: The named \ncolumn\n stores the preferred textual representation of the term. The referenced column MUST comprise a single-column key for the table.\n\n\n{\n... \n\"id\":\n \ncolumn\n ...\n}\n: The named \ncolumn\n stores the preferred compact identifier for the term, which MAY be textual or numeric. The referenced column MUST comprise a single-column key for the table.\n\n\n{\n... \n\"internal\":\n [\ncolumn\n, ...] ...\n}\n: The one or more named \ncolumns\n store internal identifiers for the term, used for efficient normalized storage in the database but not meaningful to typical users. The referenced columns MUST each comprise a single-column key for the table.\n\n\n{\n... \n\"description\":\n \ncolumn\n ...\n}\n: The named \ncolumn\n stores a longer textual representation of the term or concept. The referenced column SHOULD comprise a single-column key for the table.\n\n\n\n\nHeuristics\n\uf0c1\n\n\n\n\nIn the absence of an \ninternal\n assertion, assume all keys are potentially meaningful to users.\n\n\nIn the absence of a \nterm\n assertion\n\n\nTry to find a single-column key named \nterm\n\n\nTry to find a single-column key named \nname\n\n\nIf no term column is found table SHOULD NOT be interpreted as a vocabulary.\n\n\nIn the absence of an \nid\n assertion\n\n\nTry to find a column named \nid\n\n\nTry to find an unambiguous single-column numeric key\n\n\nIf no \nid\n column is found, use the term column as the preferred compact identifier.\n\n\nIn the absence of a \ndescription\n assertion\n\n\nTry to find a column named \ndescription\n\n\nIf no description column is found, proceed as if there is no description or use some other detailed or composite view of the table rows as a long-form presentation.\n\n\n\n\nIn the preceding, an \"unambiguous\" key means that there is only one\nkey matching the specified type and column count.\n\n\nThe preferred compact identifier is more often used in dense table\nrepresentations, technical search, portable data interchange, or\nexpert user scenarios, while the preferred textual representation is\noften used in prose, long-form presentations, tool tips, or other\nscenarios where a user may need more natural language understanding of\nthe concept.\n\n\n2016 Ignore\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:ignore\n\n\nThis key is allowed on any number of Schema, Table, or Column model elements. The only part of chaise that is using this annotation is search application. It does not have any effects on other applications (i.e., record, record-edit, and recordset).\n\n\nThis key was previously specified for these model elements but such use is deprecated:\n\n\n\n\nColumn (use \n2016 Visible Columns\n instead)\n\n\nForeign Key (use \n2016 Visible Foreign Keys\n instead)\n\n\n\n\nThis annotation indicates that the annotated model element should be ignored in typical model-driven user interfaces, with the presentation behaving as if the model element were not present. The JSON payload contextualizes the user interface mode or modes which should ignore the model element.\n\n\nSupported JSON payload patterns:\n- \nnull\n or \ntrue\n: Ignore in any presentation context. \nnull\n is equivalent to \ntag:misd.isi.edu,2015:hidden\n for backward-compatibility.\n- \n[]\n or \nfalse\n: Do \nnot\n ignore in any presentation context.\n- \n[\n \ncontext\n \n,\n ... \n]\n: Ignore \nonly\n in specific listed contexts, otherwise including the model element as per default heuristics. See \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nThis annotation provides an override guidance for Chaise applications\nusing a hierarchical scoping mode:\n\n\n\n\nHard-coded default behavior in Chaise codebase.\n\n\nServer-level configuration in \nchaise-config.js\n on web server overrides hard-coded default.\n\n\nSchema-level annotation overrides server-level or codebase behaviors.\n\n\nTable-level annotation overrides schema-level, server-level, or codebase behaviors.\n\n\nAnnotations on the column or foreign key reference levels override table-level, schema-level, server-level, or codebase behaviors.\n\n\n\n\n2016 App Links\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:app-links\n\n\nThis key is allowed on any number of schemas or tables in the\nmodel. It is used to indicate which application in the Chaise suite\nshould be used for presentation in different context.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n ... \ncontext\n \n:\n \napp name\n \n,\n ... \n}\n: An \napp name\n to be linked to in a different \ncontext\n name.\n\n\napp name\n is one of the following chaise apps:\n\n\ntag:isrd.isi.edu,2016:chaise:record\n,\n\n\ntag:isrd.isi.edu,2016:chaise:record-two\n,\n\n\ntag:isrd.isi.edu,2016:chaise:viewer\n,\n\n\ntag:isrd.isi.edu,2016:chaise:search\n,\n\n\ntag:isrd.isi.edu,2016:chaise:recordset\n\n\n\n\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n \n,\n ... \n}\n: Configure \ncontext1\n to use the same \napp name\n configured for \ncontext2\n.\n\n\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nThis annotation provides an override guidance for Chaise applications\nusing a hierarchical scoping mode:\n\n\n\n\nHard-coded default behavior in Chaise codebase:\n\n\ndetailed\n \n:\n \ntag:isrd.isi.edu,2016:chaise:record\n,\n\n\ncompact\n \n:\n \ntag:isrd.isi.edu,2016:chaise:resultset\n\n\nServer-level configuration in \nchaise-config.js\n on web server overrides hard-coded default.\n\n\nSchema-level annotation overrides server-level or codebase behaviors.\n\n\nTable-level annotation overrides schema-level, server-level, or codebase behaviors.\n\n\n\n\n2016 Immutable\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:immutable\n\n\nThis key indicates that the values for a given model element may not be mutated\n(changed) once set. This key is allowed on any number of columns, tables, and schemas. There is no\ncontent for this key.\n\n\n2016 Generated\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:generated\n\n\nThis key indicates that the values for a given model element will be generated by\nthe system. This key is allowed on any number of columns, tables and schemas.\nThere is no content for this key.\n\n\n2016 Non Deletable\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:non-deletable\n\n\nThis key indicates that the schema or table is non-deletable. This key is allowed\non any number tables and schemas. There is no content for this key.\n\n\n2016 Visible Columns\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:visible-columns\n\n\nThis key indicates that the presentation order and visibility for\ncolumns in a table, overriding the defined table structure.\n\n\nSupported JSON payload pattern:\n\n\n\n\n{\n ... \ncontext\n \n:\n \ncolumnlist\n \n,\n ... \n}\n: A separate \ncolumnlist\n can be specified for any number of \ncontext\n names.\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n \n,\n ... \n}\n: Configure \ncontext1\n to use the same \ncolumnlist\n configured for \ncontext2\n.\n\n\n{\n ... \n\"filter\": { \"and\": [\n \nfacetlist\n \n,\n ... \n]} }\n : Configure list of facets to be displayed.\n\n\n\n\nFor presentation contexts which are not listed in the annotation, or when the annotation is entirely absent, all available columns SHOULD be presented in their defined order unless the application has guidance from other sources.\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nSupported \ncolumnlist\n patterns:\n\n\n\n\n[\n ... \ncolumnentry\n \n,\n ... \n]\n: Present content corresponding to each \ncolumnentry\n, in the order specified in the list. Ignore listed \ncolumnentry\n values that do not correspond to content from the table. Do not present table columns that are not specified in the list.\n\n\n\n\nSupported \ncolumnentry\n patterns:\n\n\n\n\ncolumnname\n: A string literal \ncolumnname\n identifies a constituent column of the table. The value of the column SHOULD be presented, possibly with representation guided by other annotations or heuristics.\n\n\n[\n \nschemaname\n \n,\n \nconstraintname\n \n]\n: A two-element list of string literal \nschemaname\n and \nconstraintname\n identifies a constituent foreign key of the table. The value of the external entity referenced by the foreign key SHOULD be presented, possibly with representation guided by other annotations or heuristics. If the foreginkey is representing an inbound relationship with the current table, it SHOULD be presented in a tabular format since it can represent multiple rows of data.\n\n\n{ \"source\":\n \nsourceentry\n \n}\n:  Defines a pseudo-column based on the given \nsourceentry\n. For detailed explanation and examples please refer to \nhere\n. Other optional attributes that this JSON document can have are:\n\n\nmarkdown_name\n: The markdown to use in place of the default heuristics for title of column.\n\n\ncomment\n: The tooltip to be used in place of the default heuristics for the column.\n\n\nentity\n: If the \nsourceentry\n can be treated as entity (the source column is key of the table), setting this attribute to \nfalse\n will force the scalar mode.\n\n\naggregate\n: The aggregate function that should be used for getting an aggregated result. The available aggregate functions are \nmin\n, \nmax\n, \ncnt\n, \ncnt_d\n, and \narray\n.\n\n\narray\n will return ALL the values including duplicates associated with the specified columns. For data types that are sortable (e.g integer, text), the values will be sorted alphabetically or numerically. Otherwise, it displays values in the order that it receives from ERMrest. There is no paging mechanism to limit what's shown in the aggregate column, therefore please USE WITH CARE as it can incur performance overhead and ugly presentation.\n\n\nUsing \narray\n aggregate in entiy mode will provide an array of row-names instead of just they value of the column.\n\n\n\n\n\n\n\n\nSupported \nsourceentry\n pattern:\n- \ncolumnname\n: : A string literal. \ncolumnname\n identifies a constituent column of the table.\n- \npath\n: An array of \nforeign key path\n that ends with a \ncolumnname\n that will be projected. \nforeign key path\n is in the following format:\n\n\n    \"`{` _direction_ `:[` *schema name*`,` *constraint name* `]}` \"\nWhere _direction_ is either `inbound`, or `outbound`.\n\n\n\nSupported \nfacetlist\n pattern:\n\n\n\n\n[\n ... \nfacetentry\n \n,\n ... \n]\n: Present content corresponding to each \nfacetentry\n, in the order specified in the list. Ignore invalid listed \nfacetentry\n. Do not present other facets that are not specified in the list.\n\n\n\n\nfacetentry\n must be a JSON payload with the following attributes:\n\n\nRequired attributes:\n- \nsource\n: Source of the filter. If it is not specified or is invalid the \nfacetentry\n will be ignored. It has the same pattern as \nsourceentry\n defined above.\n\n\nConstraint attributes (optional):\n\n\nYou can use these attributes to define default preselected facets (Combination of these attributes are not supported yet, you cannot have both \nchoices\n and \nranges\n specified on a facet).\n- \nchoices\n: Discrete choice e.g. maps to a checklist or similar UX. Its value MUST be an array of values.\n- \nranges\n: Half-open or closed intervals, e.g. maps to a slider or similar UX. Its value MUST be an array of JSON payload, with \nmin\n and \nmax\n attributes. The \nmin\n and \nmax\n values will translate into inclusive range filters. In order to force exclusive range, you can use \nmin_exclusive: true\n, or \nmax_exclusive: true\n.\n- \nnot_null\n: Match any record that has a value other than \nnull\n. Its value MUST be \ntrue\n. If you have this constraint defined in your annotation, other constraints will be ignored (other than \n\"choice\"\n: [null]\n. In this case both of the filters will be ignored).\n\n!-- -\nsearch`: Substring search, e.g. maps to a search box UX. --\n\n\nConfiguration attributes (optional):\n- \nmarkdown_name\n: The markdown to use in place of the default heuristics for facet title.\n- \nentity\n: If the facet can be treated as entity (the column that is being used for facet is key of the table), setting this attribute to \nfalse\n will force the facet to show scalar mode.\n- \nopen\n: Setting this attribute to \ntrue\n, will force the facet to open by default.\n- \nbar_plot\n: This attribute is meant to be an object of properties that control the display of the histogram. Setting this attribute to \nfalse\n will force the histogram to not be shown in the facet in the facet panel. If unspecified, default is \ntrue\n (or show the histogram).\n- \nux_mode\n: \nchoices\n or \nranges\n. If a multi-modal facet control UX is available, it will specify the default UX mode that should be used (If \nux_mode\n is defined, the other type of constraint will not be displayed even if you have defined it in the annotation).\n\n\nbar_plot\n attributes (optional):\n- \nn_bins\n: Used to define the number of bins the histogram uses to fetch and display data. If undefined, default is 30 bins.\n\n\nThe following is an example of visible-columns annotation payload for defining facets. You can find more examples in \nhere\n.\n\n\nfilter\n: {\n    \nand\n : [\n        {\nsource\n: \ncolumn\n, \nranges\n: [{\nmin\n: 1}, {\nmin\n:5, \nmax\n:10}] ,\nmarkdown_name\n: \n**col**\n},\n        {\nsource\n: [{\noutbound\n: [\nS\n, \nFK2\n]}, \nid\n], \nchoices\n: [1, 2]},\n        {\nsource\n: [{\ninbound\n: [\nS\n, \nFK1\n]}, {\noutbound\n: [\nS\n, \nFK2\n]}, \nterm\n], \nentity\n: false}\n    ]\n}\n\n\n\n\n2017 Key Display\n\uf0c1\n\n\ntag:isrd.isi.edu,2017:key-display\n\n\nThis key allows augmentation of a unique key constraint\nwith additional presentation information.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n \ncontext\n:\n \noption\n ...\n}\n: Apply each \noption\n to the presentation of referenced content for any number of \ncontext\n names.\n\n\n\n\nSupported display \noption\n syntax:\n\n\n\n\n\"markdown_pattern\":\n \npattern\n: The visual presentation of the key SHOULD be computed by performing \nPattern Expansion\n on \npattern\n to obtain a markdown-formatted text value which MAY be rendered using a markdown-aware renderer.\n\n\n\"column_order\"\n: \n[\n \ncolumnorder_key\n ... \n]\n: An alternative sort method to apply when a client wants to semantically sort by key values.\n\n\n\"column_order\": false\n: Sorting by this key psuedo-column should not be offered.\n\n\n\n\nSupported \ncolumnorder_key\n syntax:\n\n\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": true }\n: Sort according to the values in the \ncolumnname\n column opposite of the order of current sort. For instance if asked to sort the key in descending order, sorting will be based on the ascending values of \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": false }\n: Sort according to the values in the \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n}\n: If omitted, the \n\"descending\"\n field defaults to \nfalse\n as per above.\n\n\ncolumnname\n: A bare \ncolumnname\n is a short-hand for \n{ \"column\":\n \ncolumnname\n \n}\n.\n\n\n\n\nKey pseudo-column-naming heuristics (use first applicable rule):\n\n\n\n\nUse key name specified by \n2015 Display\n if \nname\n attribute is specified.\n\n\nFor simple keys, use effective name of sole constituent column considering \n2015 Display\n and column name from model.\n\n\nOther application-specific defaults might be considered (non-normative examples):\n\n\nAnonymous pseudo-column may be applicable in some presentations\n\n\nA fixed name such as \nKey\n\n\nThe effective table name\n\n\nA composite name formed by joining the effective names of each constituent column of a composite key\n\n\n\n\nKey sorting heuristics (use first applicable rule):\n\n\n\n\nUse the key's display \ncolumn_order\n option, if present.\n\n\nDetermine sort based on constituent column, only if key is non-composite.\n\n\nOtherwise, disable sort for psuedo-column.\n\n\n\n\nThe first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.\n\n\n2016 Foreign Key\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:foreign-key\n\n\nThis key allows augmentation of a foreign key reference constraint\nwith additional presentation information.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n ... \n\"from_name\":\n \nfname\n ... \n}\n: The \nfname\n string is a preferred name for the set of entities containing foreign key references described by this constraint.\n\n\n{\n ... \n\"to_name\":\n \ntname\n ... \n}\n: The \ntname\n string is a preferred name for the set of entities containing keys described by this constraint.\n\n\n{\n ... \n\"display\": {\n \ncontext\n:\n \noption\n ...\n}\n ... \n}\n: Apply each \noption\n to the presentation of referenced content for any number of \ncontext\n names.\n\n\n{\n ... \n\"domain_filter_pattern\":\n \npattern\n ...\n}\n: The \npattern\n yields a \nfilter\n via \nPattern Expansion\n. The \nfilter\n is a URL substring using the ERMrest filter language, which can be applied to the referenced table. The \nfilter\n MUST NOT use any\n\n\n\n\nSupported display \noption\n syntax:\n\n\n\n\n\"column_order\"\n: \n[\n \ncolumnorder_key\n ... \n]\n: An alternative sort method to apply when a client wants to semantically sort by foreign key values.\n\n\n\"column_order\": false\n: Sorting by this foreign key psuedo-column should not be offered.\n\n\n\n\nSupported \ncolumnorder_key\n syntax:\n\n\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": true }\n: Sort according to the values in the \ncolumnname\n column opposite of the order of current sort.For instance if asked to sort the foreign key in descending order, sorting will be based on the ascending values of \ncolumnname\n column. \ncolumnname\n can be the name of any columns from the table that the foreign key is referring to.\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": false }\n: Sort according to the values in the \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n}\n: If omitted, the \n\"descending\"\n field defaults to \nfalse\n as per above.\n\n\ncolumnname\n: A bare \ncolumnname\n is a short-hand for \n{ \"column\":\n \ncolumnname\n \n}\n. \ncolumnname\n can be the name of any columns from the table that the foreign key is referring to.\n\n\n\n\nSet-naming heuristics (use first applicable rule):\n\n\n\n\nA set of \"related entities\" make foreign key reference to a presentation context:\n\n\nThe \nfname\n is a preferred name for the related entity set.\n\n\nThe name of the table containing the related entities may be an appropriate name for the set, particularly if the table has no other relationship to the context.\n\n\nThe name of the table can be composed with other contextual information, e.g. \"Tablename having columnname = value\".\n\n\nTo name a set of \"related entities\" linked to a presentation context by an association table:\n\n\nThe \ntname\n of the foreign key from association table to related entities is a preferred name for the related entity set.\n\n\nThe name of the table containing the related entities may be an appropriate name for the set, particularly if the table has no other relationship to the context.\n\n\n\n\nForeign key sorting heuristics (use first applicable rule):\n\n\n\n\nUse the foreign key's display \ncolumn_order\n option, if present.\n\n\nUse the referenced table display \nrow_order\n option, if present.\n\n\nDetermine sort based on constituent column, only if foreign key is non-composite.\n\n\nOtherwise, disable sort for psuedo-column.\n\n\n\n\nThe first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.\n\n\nDomain value presentation heuristics:\n\n\n\n\nIf \npattern\n expands to \nfilter\n and forms a valid filter string, present filtered results as domain values.\n\n\nWith \nfilter\n \nF\n, the effective domain query would be \nGET /ermrest/catalog/N/entity/S:T/F\n or equivalent.\n\n\nThe \nfilter\n SHOULD be validated according to the syntax summary below.\n\n\nIf a server response suggests the filter is invalid, an application SHOULD retry as if the \npattern\n is not present.\n\n\n\n\n\n\nIf \nfilter\n is not a valid filter string, proceed as if \npattern\n is not present.\n\n\nIf \npattern\n is not present, present unfiltered results.\n\n\n\n\nSupported \nfilter\n language is the subset of ERMrest query path syntax\nallowed in a single path element:\n\n\n\n\nGrouping: \n(\n \nfilter\n \n)\n\n\nDisjunction: \nfilter\n \n;\n \nfilter\n\n\nConjunction: \nfilter\n \n \nfilter\n\n\nNegation: \n!\n \nfilter\n\n\nUnary predicates: \ncolumn\n \n::null::\n\n\nBinary predicates: \ncolumn\n \nop\n \nvalue\n\n\nEquality: \n=\n\n\nInequality: \n::gt::\n, \n::lt::\n, \n::geq::\n, \n::leq::\n\n\nRegular expressions: \n::regexp::\n, \n::ciregexp::\n\n\n\n\nNotably, \nfilters\n MUST NOT contain the path divider \n/\n nor any other\nreserved syntax not summarized above. All \ncolumn\n names and \nvalue\n\nliterals MUST be URL-escaped to protect any special characters. All\n\ncolumn\n names MUST match columns in the referenced table and MUST NOT\nbe qualified with table instance aliases.\n\n\n2016 Column Display\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:column-display\n\n\nThis key allows specification of column data presentation options at the column level of the model.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n ... \ncontext\n \n:\n \n{\n \noption\n ... \n}\n ... \n}\n: Apply each \noption\n to the presentation of column values in the given \ncontext\n.\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n ... \n}\n: Short-hand to allow \ncontext1\n to use the same options configured for \ncontext2\n.\n\n\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nSupported \noption\n syntax:\n\n\n\n\n\"pre_format\"\n: \nformat\n: The column value SHOULD be pre-formatted by evaluating the \nformat\n string with the raw column value as its sole argument. Please refer to \nPre Format Annotation document\n for detailed explanation of supported syntax.\n\n\n\"markdown_pattern\":\n \npattern\n: The visual presentation of the column SHOULD be computed by performing \nPattern Expansion\n on \npattern\n to obtain a markdown-formatted text value which MAY be rendered using a markdown-aware renderer.\n\n\n\"column_order\"\n: \n[\n \ncolumnorder_key\n ... \n]\n: An alternative sort method to apply when a client wants to semantically sort by this column.\n\n\n\"column_order\": false\n: Sorting by this column should not be offered.\n\n\n\n\nSupported \ncolumnorder_key\n syntax:\n\n\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": true }\n: Sort according to the values in the \ncolumnname\n column opposite of the order of current sort. For instance if asked to sort the column in descending order, sorting will be based on the ascending values of \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": false }\n: Sort according to the values in the \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n}\n: If omitted, the \n\"descending\"\n field defaults to \nfalse\n as per above.\n\n\ncolumnname\n: A bare \ncolumnname\n is a short-hand for \n{ \"column\":\n \ncolumnname\n \n}\n.\n\n\n\n\nAll \npre_format\n options for all columns in the table SHOULD be evaluated \nprior\n to any \nmarkdown_pattern\n, thus allowing raw data values to be adjusted by each column's \nformat\n option before they are substituted into any column's \npattern\n.\n\n\nThe \ncolumn_order\n annotation SHOULD always provide a meaningful semantic sort for the presented column content. \ncolumn_order\n MAY be present because the preferred semantic sort may differ from a lexicographic sort of the storage column, e.g. a secondary \"rank\" column might provide a better order for coded values in the annotated storage column.\n\n\nColumn sorting heuristics (use first applicable rule):\n\n\n\n\nUse the column's display \ncolumn_order\n option, if present.\n\n\nSort by presented column value.\n\n\n\n\nThe first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.\n\n\n2016 Table Display\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:table-display\n\n\nThis key allows specification of table presentation options at the table or schema level of the model.\n\n\n\n\n{\n ... \ncontext\n \n:\n \n{\n \noption\n ... \n}\n ... \n}\n: Apply each \noption\n to the presentation of table content in the given \ncontext\n.\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n ... \n}\n: Short-hand to allow \ncontext1\n to use the same options configured for \ncontext2\n.\n\n\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nSupported JSON \noption\n payload patterns:\n\n\n\n\n\"row_order\":\n \n[\n \nsortkey\n ... \n]\n: The list of one or more \nsortkey\n defines the preferred or default order to present rows from a table. The ordered list of sort keys starts with a primary sort and optionally continues with secondary, tertiary, etc. sort keys. The given \nsortkey\n s will be used as is (\ncolumnorder\n SHOULD not be applied recursivly to this).\n\n\n\"page_size\":\n \n_number_\n: The default number of rows to be shown on a page.  \n\n\n\"row_markdown_pattern\":\n \nrowpattern\n: Render the row by composing a markdown representation only when \nrow_markdown_pattern\n is non-null.\n\n\nExpand \nrowpattern\n to obtain a markdown representation of each row via \nPattern Expansion\n. The pattern has access to column values \nafter\n any processing implied by \n2016 Column Display\n.\n\n\n\"separator_markdown\":\n \nseparator\n: Insert \nseparator\n markdown text between each expanded \nrowpattern\n when presenting row sets. (Default new-line \n\"\\n\"\n.)\n\n\nIgnore if \n\"row_markdown_pattern\"\n is not also configured.\n\n\n\"prefix_markdown\":\n \nprefix\n: Insert \nprefix\n markdown before the first \nrowpattern\n expansion when presenting row sets. (Default empty string \n\"\"\n.)\n\n\nIgnore if \n\"row_markdown_pattern\"\n is not also configured.\n\n\n\"suffix_markdown\":\n \nsuffix\n: Insert \nsuffix\n markdown after the last \nrowpattern\n expansion when presenting row sets. (Default empty string \n\"\"\n.)\n\n\nIgnore if \n\"row_markdown_pattern\"\n is not also configured.\n\n\n\"module\":\n \nmodule\n: Activate \nmodule\n to present the entity set. The string literal \nmodule\n name SHOULD be one that Chaise associates with a table-presentation plug-in.\n\n\n\"module_attribute_path\":\n \npathsuffix\n: Configure the data source for activated \nmodule\n. Ignore if \nmodule\n is not configured or not understood.\n\n\nIf \npathsuffix\n is omitted, use the ERMrest \n/entity/\n API and a data path denoting the desired set of entities.\n\n\nIf \npathsuffix\n is specified, use the ERMrest \n/attribute/\n API and append \npathsuffix\n to a data path denoting the desired set of entities and which binds \nS\n as the table alias for this entire entity set.\n\n\nThe provided \npathsuffix\n MUST provide the appropriate projection-list to form a valid \n/attribute/\n API URI.\n\n\nThe \npathsuffix\n MAY join additional tables to the path and MAY project from these tables as well as the table bound to the \nS\n table alias.\n\n\nThe \npathsuffix\n SHOULD reset the path context to \n$S\n if it has joined other tables.\n\n\n\n\n\n\n\n\nIt is not meaningful to use both \nrow_markdown_pattern\n and \nmodule\n in for the same \ncontext\n. If both are specified, it is RECOMMENDED that the application prefer the \nmodule\n configuration and ignore the markdown instructions.\n\n\nSupported JSON \nsortkey\n patterns:\n\n\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": true }\n: Sort according to the values in the \ncolumnname\n column in descending order. This is equivalent to the ERMrest sort specifier \n@sort(\n \ncolumnname\n \n::desc::\n \n)\n.\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": false }\n: Sort according to the values in the \ncolumnname\n column in ascending order. This is equivalent to the ERMrest sort specifier \n@sort(\n \ncolumnname\n \n)\n.\n\n\n{ \"column\":\n \ncolumnname\n \n}\n: If omitted, the \n\"descending\"\n field defaults to \nfalse\n as per above.\n\n\ncolumnname\n: A bare \ncolumnname\n is a short-hand for \n{ \"column\":\n \ncolumnname\n \n}\n.\n\n\n\n\n2016 Table Display Settings Hierarchy\n\uf0c1\n\n\nThe table display settings apply only to tables, but MAY be annotated at the schema level to set a schema-wide default, if appropriate in a particular model. Any table-level specification of these settings will override the behavior for that table. These settings on other model elements are meaningless and ignored.\n\n\nFor hierarchically inheritable settings, an explicit setting of \nnull\n will turn \noff\n inheritence and restore default behavior for that model element and any of its nested elements.\n\n\n2016 Visible Foreign Keys\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:visible-foreign-keys\n\n\nThis key indicates that the presentation order and visibility for\nforeign keys referencing a table, useful when presenting \"related entities\".\n\n\nSupported JSON payload pattern:\n\n\n\n\n{\n ... \ncontext\n \n:\n \nfkeylist\n \n,\n ... \n}\n: A separate \nfkeylist\n can be specified for any number of \ncontext\n names.\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n ... \n}\n: Short-hand to allow \ncontext1\n to use the same fkeylist configured for \ncontext2\n.\n\n\n\n\nFor presentation contexts which are not listed in the annotation, or when the annotation is entirely absent, all available foreign keys SHOULD be presented unless the application has guidance from other sources. See \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nSupported \nfkeylist\n patterns:\n\n\n\n\n[\n \n[\n \nschema name\n,\n \nconstraint name\n \n]\n \n,\n ... \n]\n: Present foreign keys with matching \nschema name\n and \nconstraint name\n, in the order specified in the list. Ignore constraint names that do not correspond to foreign keys in the catalog. Do not present foreign keys that are not mentioned in the list. These 2-element lists use the same format as each element in the \nnames\n property of foreign keys in the JSON model introspection output of ERMrest. The foreign keys MUST represent inbound relationships to the current table.\n\n\n{ \"source\":\n \nsourceentry\n \n}\n:  Defines a pseudo-column based on the given \nsourceentry\n. For detailed explanation and examples please refer to \nhere\n. Other optional attributes that this JSON document can have are:\n\n\nmarkdown_name\n: The markdown to use in place of the default heuristics for title of column.\n\n\n\n\nSupported \nsourceentry\n pattern in here:\n  - \npath\n: An array of \nforeign key path\n that ends with a \ncolumnname\n that will be projected. \nforeign key path\n is in the following format:\n\n\n      \"`{` _direction_ `:[` *schema name*`,` *constraint name* `]}` \"\n  Where _direction_ is either `inbound`, or `outbound`.\n\n\n\n2016 Table Alternatives\n\uf0c1\n\n\ntag:isrd.isi.edu,2016:table-alternatives\n\n\nThis key indicates that the annotated table (e.g. the base storage table) has abstracted views/tables that should be used as \nalternataive\n tables in different contexts. This means that they both represent the same \nentity set\n but\nthe alternative one has modified the representation of each entity in some way.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n ... \ncontext\n \n:\n [ \nsname\n, \ntname\n] \n,\n ... \n}\n: The table identified by \nsname\n:\ntname\n is an alternative table to be used instead of the annoted table in the specified context.\n\n\n\n\nA alternative table or view which abstracts another table \nSHOULD\n have a non-null (psuedo) primary key which is also a foreign key to the base storage table. The base storage table is the one bearing this annotation. Otherwise, a consuming application would not know how to navigate from one abstracted representation of an entity to another representation from the base storage tables.\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names. It is assumed that any application context that is performing mutation (record creation, deletion, or editing) MUST use a base entity storage table that is not an abstraction over another table. However, the use of the \ndetailed\n or \ncompact\n context MAY offer an abstraction that augments the presentation of an existing record. An application offering mutation options while displaying an existing entity record might then present the data from the \ndetailed\n or \ncompact\n abstraction but only offer editing or data-entry controls on the fields available from the base storage table.\n\n\n2017 Asset\n\uf0c1\n\n\ntag:isrd.isi.edu,2017:asset\n\n\nThis key indicates that the annotated column stores asset locations. An \nasset\n is a generic, fixed-length octet-stream of data, i.e. a \"file\" or \"object\" which can be stored, retrieved, and interpreted by consumers.\n\n\nAn asset \nlocation\n is a \nglobally unique\n and \nresolvable\n string, used to reference and retrieve the identified asset either directly or indirectly through a resolution service. For example, an HTTP URL is both globally unique and resolvable. In the case of a relative URL, the client should resolve the URL within the context from which it was retrieved. Persistent identifier schemes MAY be used such as MINID, DOI, ARK, or PURL. It is up to client tooling to recognize and resolve identifiers in such schemes.\n\n\nA new asset location may be specified via a pattern to induce a prospective asset location based on known metadata values, i.e. to normalize where to upload and store a new asset in a data-submission process. Only meaningful where clients can request creation of new assets with a desired location.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n... \n\"url_pattern\":\n \npattern\n ...\n}\n: A desired upload location can be derived by \nPattern Expansion\n on \npattern\n. This attribute is required for browser upload and if it is not specified the client will not provide the browser upload feature. See implementation notes below.\n\n\n{\n... \n\"browser_upload\":\n \nFalse\n ... \n}\n: If \nurl_pattern\n is availale and valid browser upload feature will be enabled. If you want to force disabling this feature set it to \nFalse\n.\n\n\n{\n... \n\"filename_column\":\n \ncolumn\n ...\n}\n: The \ncolumn\n stores the filename of the asset.\n\n\n{\n... \n\"byte_count_column\":\n \ncolumn\n ...\n}\n: The \ncolumn\n stores the file size in bytes of the asset. It SHOULD be an integer typed column.\n\n\n{\n... \n\"md5\":\n \ncolumn\n | \nTrue\n ...\n}\n: If \ncolumn\n, then the \ncolumn\n stores the checksum generated by the 'md5' cryptographic hash function. It MUST be ASCII/UTF-8 hexadecimal encoded. If \nTrue\n, then the client SHOULD generate a 'md5' checksum and communicate it to the asset storage service according to its protocol.\n\n\n{\n... \n\"sha256\":\n \ncolumn\n | \nTrue\n ...\n}\n: If \ncolumn\n, then the \ncolumn\n stores the checksum generated by the 'sha256' cryptographic hash function. It MUST be ASCII/UTF-8 hexadecimal encoded. If \nTrue\n, then the client SHOULD generate a 'sha256' checksum and communicate it to the asset storage service according to its protocol. See implementation notes below.\n\n\n{\n... \n\"filename_ext_filter\": [\n { \nfilename extension\n [\n,\n \nfilename extension\n ]* } \n]\n ...\n}\n: This property specifies a set of \nfilename extension\n filters for use by upload agents to indicate to the user the acceptable filename patterns (\n.jpg\n, \n.png\n, \n.pdf\n, ...). For example, \n.jpg\n would indicate that only JPEG files should be selected by the user.\n\n\n\n\nDefault heuristics:\n- The \n2017 Asset\n annotation explicitly indicates that the associated column is the asset location.\n- \nurl_pattern\n MUST be specified for browser upload. If it is not specified or if it produces a null value, the browser upload will be disabled.\n- Column MUST be \ntext\n typed. Otherwise the asset annotation will be ignored.\n- In addition to native columns, the following properties are also available under the annotated column object and can be referred in the \npattern\n e.g. \n_URI.md5_hex\n where \nURI\n is the annotated column (notice the \nunderscore before the column name\n).\n  - \nmd5_hex\n for hex\n\n  - \nmd5_base64\n for base64\n  - \nfilename\n for filename\n  - \nsize\n for size in bytes\n- Nothing may be inferred without additional payload patterns present.\n\n\nProtocol-specific metadata retrieval MAY be applied once an asset location is known. How to present or reconcile contradictions in metadata found in multiple sources is beyond the scope of this specification.\n- Some applications may treat ERMrest data as prefetched or cached metadata.\n- Some applications may treat ERMrest data as authoritative metadata registries.\n- Some location schemes may define authoritative metadata resolution procedures.\n\n\nAt present, the Chaise implementation of the asset annotation has the following limitations:\n1. 'generated' column(s) in the \nurl_pattern\n are only supported in the \nentry/edit\n context and \nnot\n in the \nentry/create\n context. If you wish to use 'generated' column(s) in the \nurl_pattern\n, you will need to use the \n2016 Visible Columns\n annotation and leave the asset column out of the list of visible columns for its \nentry/create\n context.\n2. \nsha256\n is not presently supported.\n3. If \nurl_pattern\n is not available or \nbrowser_upload\n is \nFalse\n Chaise will show a disabled form field for the asset column. It will still provide the download button in read-only contexts.\n\n\nContext Names\n\uf0c1\n\n\nList of \ncontext\n names that are used in ermrest:\n- \n\"compact\"\n: Any compact, tabular presentation of data from multiple entities.\n  - \n\"compact/brief\"\n: A limited compact, tabular presentation of data from multiple entities to be shown under the \ndetailed\n context. In this context, only a page of data will be shown with a link to the access the \ncompact\n context for more detail.\n\n  - \n\"compact/select\"\n: A sub-context of \ncompact\n that is used for selecting entities, e.g. when prompting the user for choosing a foreign key value.\n- \n\"detailed\"\n: Any detailed read-only, entity-level presentation context.\n- \n\"entry\"\n: Any data-entry presentation context, i.e. when prompting the user for input column values.\n  - \n\"entry/edit\"\n: A sub-context of \nentry\n that only applies to editing existing resources.\n  - \n\"entry/create\"\n: A sub-context of \nentry\n that only applies to creating new resources.\n- \n\"filter\"\n: Any data-filtering control context, i.e. when prompting the user for column constraints or facets.\n- \n\"row_name\"\n: Any abbreviated title-like presentation context.\n  - \n\"row_name/title\"\n: A sub-context of \nrow_name\n that only applies to title of page.\n  - \n\"row_name/compact\"\n: A sub-context of \nrow_name\n that only applies to compact, tabluar presentation of a row (When a foreignkey value is displayed in a tabular presentation).\n  - \n\"row_name/detailed\"\n: A sub-context of \nrow_name\n that only applies to entity-level presentation of a row (When a foreignkey value is displayed in the entity-level page).\n- \n\"*\"\n: A default to apply for any context not matched by a more specific context name.\n\n\nIf more than one \ncontext\n name in the annotation payload matches, the \noptions\n should be combined in the following order (first occurrence wins):\n\n\n\n\nPrefer \noption\n set in matching contexts with exact matching context name.\n\n\nPrefer \noption\n set in matching contexts with longest matching prefix, e.g. an option for \nentry\n can match application context \nentry/edit\n or \nentry/create\n.\n\n\nUse default \noption\n set in context \n*\n.\n\n\n\n\nThe following matrix illustrates which context is meaningful in which annotation.\n\n\n\n\n\n\n\n\nAnnotation\n\n\ncompact\n\n\ncompact/brief\n\n\ncompact/select\n\n\ndetailed\n\n\nentry\n\n\nentry/edit\n\n\nentry/create\n\n\nfilter\n\n\nrow_name\n\n\n*\n\n\n\n\n\n\n\n\n\n\n2015 Display\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Ignore\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Visible Columns\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Column Display\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Table Display\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n2016 Visible Foreign Keys\n\n\nX\n\n\n-\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Table Alternatives\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n\n\nPattern Expansion\n\uf0c1\n\n\nWhen deriving a field value from a \npattern\n, the \npattern\n MAY contain markers for substring replacements of the form \n{{column name}}\n or \n{{{ column name}}}\n where \ncolumn name\n MUST reference a column in the table. Any particular column name MAY be referenced and expanded zero or more times in the same \npattern\n.\n\n\nFor example, a \ncolumn\n may have a \ntag:isrd.isi.edu,2016:column-display\n annotation containing the following payload:\n\n\n{\n   \n*\n : {\n       \nmarkdown_pattern\n: \n[{{{title}}}](https://dev.isrd.isi.edu/chaise/search?name={{{_name}}})\n\n   }\n}\n\n\n\n\nA web user agent that consumes this annotation and the related table data would likely display the following as the value of the column:\n\n\np\n\n    \nimg src=\nhttps://dev.isrd.isi.edu/chaise/search?name=col%20name\n alt=\nTitle of Image\n\n\n/p\n\n\n\n\n\nFor detailed explanation on template and markdown language please refer to \nTemplate and Markdown Guide\n.", 
            "title": "Model Annotation"
        }, 
        {
            "location": "/user-doc/annotation/#model-annotation", 
            "text": "This document defines a set of annotations we suggest may be useful in\ncombination with ERMrest. We define a set of  annotation keys , any\nassociated JSON  annotation values , and their semantics. Communities\nmay use these conventions to modify their interpretation of ERMrest\ncatalog content.  These annotations do not affect the behavior of the ERMrest service\nitself but merely inform clients about intended use beyond that\ncaptured in the entity-relationship model. Further, as described in\nthe  REST API docs , the annotation system is\nopenly extensible so communities MAY use other annotation keys not\ndescribed here; in those cases, the community SHOULD publish similar\ndocumentation on their use and interpretation.", 
            "title": "Model Annotation"
        }, 
        {
            "location": "/user-doc/annotation/#notation-and-usage", 
            "text": "Each annotation key is defined in a section of this document and shown\nas a literal string.  We prepend a date in each key name and promise\nnot to modify the semantics of an existing annotation key, once\npublished to GitHub. We may publish typographical or other small\ntextual clarifications, but if we need to change the proposed\nsemantics we will define a new key with a different date and/or key\ntext. We will follow the date stamp conventions from RFC 4151  which allow for\nabbreviated ISO dates such as  2015 ,  2015-01 , and  2015-01-01 .  Example to Set Annotation \uf0c1  This example sets the 2015 Display  annotation:  PUT /ermrest/catalog/1/schema/MainContent/annotation/tag%3Amisd.isi.edu%2C2015%3Adisplay HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\"name\": \"Main Content\"}  TBD changes to propose for ERMrest:   Allow non-escaped characters in the annotation key since it is the final field of the URL and does not have a parsing ambiguity?  Allow an empty (0 byte) request body to represent the same thing as JSON  null ?", 
            "title": "Notation and Usage"
        }, 
        {
            "location": "/user-doc/annotation/#annotations", 
            "text": "Some annotations are supported on multiple types of model element, so\nhere is a quick matrix to locate them.     Annotation  Schema  Table  Column  Key  FKR  Summary      2015 Display  X  X  X  X  -  Display options    2015 Vocabulary  -  X  -  -  -  Table as a vocabulary list    2016 Table Alternatives  -  X  -  _  _  Table abstracts another table    2016 Column Display  -  -  X  -  -  Column-specific display options    2017 Key Display  -  -  -  X  -  Key augmentation    2016 Foreign Key  -  -  -  -  X  Foreign key augmentation    2016 Generated  X  X  X  -  -  Generated model element    2016 Ignore  X  X  X  -  -  Ignore model element    2016 Immutable  X  X  X  -  -  Immutable model element    2016 Non Deletable  X  X  -  -  -  Non-deletable model element    2016 App Links  X  X  -  -  -  Intra-Chaise app links    2016 Table Display  -  X  -  -  -  Table-specific display options    2016 Visible Columns  -  X  -  -  -  Column visibility and presentation order    2016 Visible Foreign Keys  -  X  -  -  -  Foreign key visibility and presentation order    2017 Asset  -  -  X  -  -  Describes assets     For brevity, the annotation keys are listed above by their section\nname within this documentation. The actual key URI follows the form tag:misd.isi.edu,   date   :   key  where the  key  part is\nlower-cased with hyphens replacing whitespace. For example, the 2015 Display  annotation key URI is actually tag:misd.isi.edu,2015:display .  2015 Display \uf0c1  tag:misd.isi.edu,2015:display  This key is allowed on any number of schemas, tables,\ncolumns, and keys. This annotation indicates display options for the indicated\nelement and its nested model elements.  Supported JSON payload patterns:   { ...  \"name\":   name  ... } : The  name  to use in place of the model element's original name.  { ...  \"markdown_name\" :  markdown   } : The  markdown  to use in place of the model element's original name.  { ...  \"name_style\":   {   \"underline_space\" :  uspace   ,   \"title_case\":   tcase   ,   \"markdown\" :  render   }  ... } : Element name conversion instructions.  { ...  \"show_nulls\":   {   ncontext   :   nshow   ,  ...  } : How to display NULL data values.   Supported JSON  uspace  patterns:   true : Convert underline characters ( _ ) into space characters in model element names.  false : Leave underline characters unmodified (this is also the default if the setting is completely absent).   Supported JSON  tcase  patterns:   true : Convert element names to \"title case\" meaning the first character of each word is capitalized and the rest are lower cased regardless of model element name casing. Word separators include white-space, hyphen, and underline characters.  false : Leave character casing unmodified (this is also the default if the setting is completely absent).   Supported JSON  render  patterns:   true : Interpret the model element's actual name as a Markdown string. This MAY include rendering visually in applications with such capability.  false : Present the model element's actual name verbatim (this is also the default if the setting is completely absent).   Supported JSON  nshow  patterns:   true  (or  \"\" ): Show NULL values as an empty field.  \"   marker   \"  (a quoted string literal): For any string literal  marker , display the marker text value in place of NULLs.  false : Completely eliminate the field if feasible in the presentation.   See  Context Names  section for the list of supported JSON  ncontext  patterns.  2015 Display Settings Hierarchy \uf0c1   The  \"name\"  and  \"markdown_name\"  setting applies  only  to the model element which is annotated. They bypass the  name_style  controls which only apply to actual model names.  The  \"markdown_name\"  setting takes precedence if both are specified.  The  \"name_style\"  setting applies to the annotated model element and is also the default for any nested element.  The  \"show_nulls\"  settings applies to the annotated model element and is also the default for any nested element.  The annotation is allowed on schemas in order to set the default for all tables in the schema.  Each  ncontext   :   nshow  instruction overrides the inherited instruction for the same  ncontext  while still deferring to the inherited annotation for any unspecified  ncontext . The  \"*\"  wildcard  ncontext  allows masking of any inherited instruction.  A global default is assumed:  { ...  \"show_nulls\": { \"detailed\": false, \"*\": true  ...  }   This annotation provides an override guidance for Chaise applications using a hierarchical scoping mode:   Column-level name  Column-level name_style.  Table-level name_style.  Schema-level name_style.   Note:\n- An explicit setting of  null  will turn  off  inheritence and restore default behavior for that modele element and any of its nested elements.\n- The name_style has to be derived separately for each field e.g. one can set  underline_space=true  at the schema-level and doesn't have to set this again.     2015 Vocabulary \uf0c1  tag:misd.isi.edu,2015:vocabulary  This key is allowed on any number of tables in the model, where the\ntable contains at least one key comprised of a single textual\ncolumn. A vocabulary table is one where each row represents a term or\nconcept in a controlled vocabulary.  Supported JSON payload patterns:   null  or  {} : Default heuristics apply.  { ...  \"uri\":   uri  ... } : The  uri  indicates the global identifier of the controlled vocabulary. The  uri  MAY be a resolvable URL.  { ...  \"term\":   column  ... } : The named  column  stores the preferred textual representation of the term. The referenced column MUST comprise a single-column key for the table.  { ...  \"id\":   column  ... } : The named  column  stores the preferred compact identifier for the term, which MAY be textual or numeric. The referenced column MUST comprise a single-column key for the table.  { ...  \"internal\":  [ column , ...] ... } : The one or more named  columns  store internal identifiers for the term, used for efficient normalized storage in the database but not meaningful to typical users. The referenced columns MUST each comprise a single-column key for the table.  { ...  \"description\":   column  ... } : The named  column  stores a longer textual representation of the term or concept. The referenced column SHOULD comprise a single-column key for the table.   Heuristics \uf0c1   In the absence of an  internal  assertion, assume all keys are potentially meaningful to users.  In the absence of a  term  assertion  Try to find a single-column key named  term  Try to find a single-column key named  name  If no term column is found table SHOULD NOT be interpreted as a vocabulary.  In the absence of an  id  assertion  Try to find a column named  id  Try to find an unambiguous single-column numeric key  If no  id  column is found, use the term column as the preferred compact identifier.  In the absence of a  description  assertion  Try to find a column named  description  If no description column is found, proceed as if there is no description or use some other detailed or composite view of the table rows as a long-form presentation.   In the preceding, an \"unambiguous\" key means that there is only one\nkey matching the specified type and column count.  The preferred compact identifier is more often used in dense table\nrepresentations, technical search, portable data interchange, or\nexpert user scenarios, while the preferred textual representation is\noften used in prose, long-form presentations, tool tips, or other\nscenarios where a user may need more natural language understanding of\nthe concept.  2016 Ignore \uf0c1  tag:isrd.isi.edu,2016:ignore  This key is allowed on any number of Schema, Table, or Column model elements. The only part of chaise that is using this annotation is search application. It does not have any effects on other applications (i.e., record, record-edit, and recordset).  This key was previously specified for these model elements but such use is deprecated:   Column (use  2016 Visible Columns  instead)  Foreign Key (use  2016 Visible Foreign Keys  instead)   This annotation indicates that the annotated model element should be ignored in typical model-driven user interfaces, with the presentation behaving as if the model element were not present. The JSON payload contextualizes the user interface mode or modes which should ignore the model element.  Supported JSON payload patterns:\n-  null  or  true : Ignore in any presentation context.  null  is equivalent to  tag:misd.isi.edu,2015:hidden  for backward-compatibility.\n-  []  or  false : Do  not  ignore in any presentation context.\n-  [   context   ,  ...  ] : Ignore  only  in specific listed contexts, otherwise including the model element as per default heuristics. See  Context Names  section for the list of supported  context  names.  This annotation provides an override guidance for Chaise applications\nusing a hierarchical scoping mode:   Hard-coded default behavior in Chaise codebase.  Server-level configuration in  chaise-config.js  on web server overrides hard-coded default.  Schema-level annotation overrides server-level or codebase behaviors.  Table-level annotation overrides schema-level, server-level, or codebase behaviors.  Annotations on the column or foreign key reference levels override table-level, schema-level, server-level, or codebase behaviors.   2016 App Links \uf0c1  tag:isrd.isi.edu,2016:app-links  This key is allowed on any number of schemas or tables in the\nmodel. It is used to indicate which application in the Chaise suite\nshould be used for presentation in different context.  Supported JSON payload patterns:   {  ...  context   :   app name   ,  ...  } : An  app name  to be linked to in a different  context  name.  app name  is one of the following chaise apps:  tag:isrd.isi.edu,2016:chaise:record ,  tag:isrd.isi.edu,2016:chaise:record-two ,  tag:isrd.isi.edu,2016:chaise:viewer ,  tag:isrd.isi.edu,2016:chaise:search ,  tag:isrd.isi.edu,2016:chaise:recordset    {  ...  context1   :   context2   ,  ...  } : Configure  context1  to use the same  app name  configured for  context2 .   See  Context Names  section for the list of supported  context  names.  This annotation provides an override guidance for Chaise applications\nusing a hierarchical scoping mode:   Hard-coded default behavior in Chaise codebase:  detailed   :   tag:isrd.isi.edu,2016:chaise:record ,  compact   :   tag:isrd.isi.edu,2016:chaise:resultset  Server-level configuration in  chaise-config.js  on web server overrides hard-coded default.  Schema-level annotation overrides server-level or codebase behaviors.  Table-level annotation overrides schema-level, server-level, or codebase behaviors.   2016 Immutable \uf0c1  tag:isrd.isi.edu,2016:immutable  This key indicates that the values for a given model element may not be mutated\n(changed) once set. This key is allowed on any number of columns, tables, and schemas. There is no\ncontent for this key.  2016 Generated \uf0c1  tag:isrd.isi.edu,2016:generated  This key indicates that the values for a given model element will be generated by\nthe system. This key is allowed on any number of columns, tables and schemas.\nThere is no content for this key.  2016 Non Deletable \uf0c1  tag:isrd.isi.edu,2016:non-deletable  This key indicates that the schema or table is non-deletable. This key is allowed\non any number tables and schemas. There is no content for this key.  2016 Visible Columns \uf0c1  tag:isrd.isi.edu,2016:visible-columns  This key indicates that the presentation order and visibility for\ncolumns in a table, overriding the defined table structure.  Supported JSON payload pattern:   {  ...  context   :   columnlist   ,  ...  } : A separate  columnlist  can be specified for any number of  context  names.  {  ...  context1   :   context2   ,  ...  } : Configure  context1  to use the same  columnlist  configured for  context2 .  {  ...  \"filter\": { \"and\": [   facetlist   ,  ...  ]} }  : Configure list of facets to be displayed.   For presentation contexts which are not listed in the annotation, or when the annotation is entirely absent, all available columns SHOULD be presented in their defined order unless the application has guidance from other sources.  See  Context Names  section for the list of supported  context  names.  Supported  columnlist  patterns:   [  ...  columnentry   ,  ...  ] : Present content corresponding to each  columnentry , in the order specified in the list. Ignore listed  columnentry  values that do not correspond to content from the table. Do not present table columns that are not specified in the list.   Supported  columnentry  patterns:   columnname : A string literal  columnname  identifies a constituent column of the table. The value of the column SHOULD be presented, possibly with representation guided by other annotations or heuristics.  [   schemaname   ,   constraintname   ] : A two-element list of string literal  schemaname  and  constraintname  identifies a constituent foreign key of the table. The value of the external entity referenced by the foreign key SHOULD be presented, possibly with representation guided by other annotations or heuristics. If the foreginkey is representing an inbound relationship with the current table, it SHOULD be presented in a tabular format since it can represent multiple rows of data.  { \"source\":   sourceentry   } :  Defines a pseudo-column based on the given  sourceentry . For detailed explanation and examples please refer to  here . Other optional attributes that this JSON document can have are:  markdown_name : The markdown to use in place of the default heuristics for title of column.  comment : The tooltip to be used in place of the default heuristics for the column.  entity : If the  sourceentry  can be treated as entity (the source column is key of the table), setting this attribute to  false  will force the scalar mode.  aggregate : The aggregate function that should be used for getting an aggregated result. The available aggregate functions are  min ,  max ,  cnt ,  cnt_d , and  array .  array  will return ALL the values including duplicates associated with the specified columns. For data types that are sortable (e.g integer, text), the values will be sorted alphabetically or numerically. Otherwise, it displays values in the order that it receives from ERMrest. There is no paging mechanism to limit what's shown in the aggregate column, therefore please USE WITH CARE as it can incur performance overhead and ugly presentation.  Using  array  aggregate in entiy mode will provide an array of row-names instead of just they value of the column.     Supported  sourceentry  pattern:\n-  columnname : : A string literal.  columnname  identifies a constituent column of the table.\n-  path : An array of  foreign key path  that ends with a  columnname  that will be projected.  foreign key path  is in the following format:      \"`{` _direction_ `:[` *schema name*`,` *constraint name* `]}` \"\nWhere _direction_ is either `inbound`, or `outbound`.  Supported  facetlist  pattern:   [  ...  facetentry   ,  ...  ] : Present content corresponding to each  facetentry , in the order specified in the list. Ignore invalid listed  facetentry . Do not present other facets that are not specified in the list.   facetentry  must be a JSON payload with the following attributes:  Required attributes:\n-  source : Source of the filter. If it is not specified or is invalid the  facetentry  will be ignored. It has the same pattern as  sourceentry  defined above.  Constraint attributes (optional):  You can use these attributes to define default preselected facets (Combination of these attributes are not supported yet, you cannot have both  choices  and  ranges  specified on a facet).\n-  choices : Discrete choice e.g. maps to a checklist or similar UX. Its value MUST be an array of values.\n-  ranges : Half-open or closed intervals, e.g. maps to a slider or similar UX. Its value MUST be an array of JSON payload, with  min  and  max  attributes. The  min  and  max  values will translate into inclusive range filters. In order to force exclusive range, you can use  min_exclusive: true , or  max_exclusive: true .\n-  not_null : Match any record that has a value other than  null . Its value MUST be  true . If you have this constraint defined in your annotation, other constraints will be ignored (other than  \"choice\" : [null] . In this case both of the filters will be ignored). !-- - search`: Substring search, e.g. maps to a search box UX. --  Configuration attributes (optional):\n-  markdown_name : The markdown to use in place of the default heuristics for facet title.\n-  entity : If the facet can be treated as entity (the column that is being used for facet is key of the table), setting this attribute to  false  will force the facet to show scalar mode.\n-  open : Setting this attribute to  true , will force the facet to open by default.\n-  bar_plot : This attribute is meant to be an object of properties that control the display of the histogram. Setting this attribute to  false  will force the histogram to not be shown in the facet in the facet panel. If unspecified, default is  true  (or show the histogram).\n-  ux_mode :  choices  or  ranges . If a multi-modal facet control UX is available, it will specify the default UX mode that should be used (If  ux_mode  is defined, the other type of constraint will not be displayed even if you have defined it in the annotation).  bar_plot  attributes (optional):\n-  n_bins : Used to define the number of bins the histogram uses to fetch and display data. If undefined, default is 30 bins.  The following is an example of visible-columns annotation payload for defining facets. You can find more examples in  here .  filter : {\n     and  : [\n        { source :  column ,  ranges : [{ min : 1}, { min :5,  max :10}] , markdown_name :  **col** },\n        { source : [{ outbound : [ S ,  FK2 ]},  id ],  choices : [1, 2]},\n        { source : [{ inbound : [ S ,  FK1 ]}, { outbound : [ S ,  FK2 ]},  term ],  entity : false}\n    ]\n}  2017 Key Display \uf0c1  tag:isrd.isi.edu,2017:key-display  This key allows augmentation of a unique key constraint\nwith additional presentation information.  Supported JSON payload patterns:   {   context :   option  ... } : Apply each  option  to the presentation of referenced content for any number of  context  names.   Supported display  option  syntax:   \"markdown_pattern\":   pattern : The visual presentation of the key SHOULD be computed by performing  Pattern Expansion  on  pattern  to obtain a markdown-formatted text value which MAY be rendered using a markdown-aware renderer.  \"column_order\" :  [   columnorder_key  ...  ] : An alternative sort method to apply when a client wants to semantically sort by key values.  \"column_order\": false : Sorting by this key psuedo-column should not be offered.   Supported  columnorder_key  syntax:   { \"column\":   columnname   , \"descending\": true } : Sort according to the values in the  columnname  column opposite of the order of current sort. For instance if asked to sort the key in descending order, sorting will be based on the ascending values of  columnname  column.  { \"column\":   columnname   , \"descending\": false } : Sort according to the values in the  columnname  column.  { \"column\":   columnname   } : If omitted, the  \"descending\"  field defaults to  false  as per above.  columnname : A bare  columnname  is a short-hand for  { \"column\":   columnname   } .   Key pseudo-column-naming heuristics (use first applicable rule):   Use key name specified by  2015 Display  if  name  attribute is specified.  For simple keys, use effective name of sole constituent column considering  2015 Display  and column name from model.  Other application-specific defaults might be considered (non-normative examples):  Anonymous pseudo-column may be applicable in some presentations  A fixed name such as  Key  The effective table name  A composite name formed by joining the effective names of each constituent column of a composite key   Key sorting heuristics (use first applicable rule):   Use the key's display  column_order  option, if present.  Determine sort based on constituent column, only if key is non-composite.  Otherwise, disable sort for psuedo-column.   The first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.  2016 Foreign Key \uf0c1  tag:isrd.isi.edu,2016:foreign-key  This key allows augmentation of a foreign key reference constraint\nwith additional presentation information.  Supported JSON payload patterns:   {  ...  \"from_name\":   fname  ...  } : The  fname  string is a preferred name for the set of entities containing foreign key references described by this constraint.  {  ...  \"to_name\":   tname  ...  } : The  tname  string is a preferred name for the set of entities containing keys described by this constraint.  {  ...  \"display\": {   context :   option  ... }  ...  } : Apply each  option  to the presentation of referenced content for any number of  context  names.  {  ...  \"domain_filter_pattern\":   pattern  ... } : The  pattern  yields a  filter  via  Pattern Expansion . The  filter  is a URL substring using the ERMrest filter language, which can be applied to the referenced table. The  filter  MUST NOT use any   Supported display  option  syntax:   \"column_order\" :  [   columnorder_key  ...  ] : An alternative sort method to apply when a client wants to semantically sort by foreign key values.  \"column_order\": false : Sorting by this foreign key psuedo-column should not be offered.   Supported  columnorder_key  syntax:   { \"column\":   columnname   , \"descending\": true } : Sort according to the values in the  columnname  column opposite of the order of current sort.For instance if asked to sort the foreign key in descending order, sorting will be based on the ascending values of  columnname  column.  columnname  can be the name of any columns from the table that the foreign key is referring to.  { \"column\":   columnname   , \"descending\": false } : Sort according to the values in the  columnname  column.  { \"column\":   columnname   } : If omitted, the  \"descending\"  field defaults to  false  as per above.  columnname : A bare  columnname  is a short-hand for  { \"column\":   columnname   } .  columnname  can be the name of any columns from the table that the foreign key is referring to.   Set-naming heuristics (use first applicable rule):   A set of \"related entities\" make foreign key reference to a presentation context:  The  fname  is a preferred name for the related entity set.  The name of the table containing the related entities may be an appropriate name for the set, particularly if the table has no other relationship to the context.  The name of the table can be composed with other contextual information, e.g. \"Tablename having columnname = value\".  To name a set of \"related entities\" linked to a presentation context by an association table:  The  tname  of the foreign key from association table to related entities is a preferred name for the related entity set.  The name of the table containing the related entities may be an appropriate name for the set, particularly if the table has no other relationship to the context.   Foreign key sorting heuristics (use first applicable rule):   Use the foreign key's display  column_order  option, if present.  Use the referenced table display  row_order  option, if present.  Determine sort based on constituent column, only if foreign key is non-composite.  Otherwise, disable sort for psuedo-column.   The first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.  Domain value presentation heuristics:   If  pattern  expands to  filter  and forms a valid filter string, present filtered results as domain values.  With  filter   F , the effective domain query would be  GET /ermrest/catalog/N/entity/S:T/F  or equivalent.  The  filter  SHOULD be validated according to the syntax summary below.  If a server response suggests the filter is invalid, an application SHOULD retry as if the  pattern  is not present.    If  filter  is not a valid filter string, proceed as if  pattern  is not present.  If  pattern  is not present, present unfiltered results.   Supported  filter  language is the subset of ERMrest query path syntax\nallowed in a single path element:   Grouping:  (   filter   )  Disjunction:  filter   ;   filter  Conjunction:  filter     filter  Negation:  !   filter  Unary predicates:  column   ::null::  Binary predicates:  column   op   value  Equality:  =  Inequality:  ::gt:: ,  ::lt:: ,  ::geq:: ,  ::leq::  Regular expressions:  ::regexp:: ,  ::ciregexp::   Notably,  filters  MUST NOT contain the path divider  /  nor any other\nreserved syntax not summarized above. All  column  names and  value \nliterals MUST be URL-escaped to protect any special characters. All column  names MUST match columns in the referenced table and MUST NOT\nbe qualified with table instance aliases.  2016 Column Display \uf0c1  tag:isrd.isi.edu,2016:column-display  This key allows specification of column data presentation options at the column level of the model.  Supported JSON payload patterns:   {  ...  context   :   {   option  ...  }  ...  } : Apply each  option  to the presentation of column values in the given  context .  {  ...  context1   :   context2  ...  } : Short-hand to allow  context1  to use the same options configured for  context2 .   See  Context Names  section for the list of supported  context  names.  Supported  option  syntax:   \"pre_format\" :  format : The column value SHOULD be pre-formatted by evaluating the  format  string with the raw column value as its sole argument. Please refer to  Pre Format Annotation document  for detailed explanation of supported syntax.  \"markdown_pattern\":   pattern : The visual presentation of the column SHOULD be computed by performing  Pattern Expansion  on  pattern  to obtain a markdown-formatted text value which MAY be rendered using a markdown-aware renderer.  \"column_order\" :  [   columnorder_key  ...  ] : An alternative sort method to apply when a client wants to semantically sort by this column.  \"column_order\": false : Sorting by this column should not be offered.   Supported  columnorder_key  syntax:   { \"column\":   columnname   , \"descending\": true } : Sort according to the values in the  columnname  column opposite of the order of current sort. For instance if asked to sort the column in descending order, sorting will be based on the ascending values of  columnname  column.  { \"column\":   columnname   , \"descending\": false } : Sort according to the values in the  columnname  column.  { \"column\":   columnname   } : If omitted, the  \"descending\"  field defaults to  false  as per above.  columnname : A bare  columnname  is a short-hand for  { \"column\":   columnname   } .   All  pre_format  options for all columns in the table SHOULD be evaluated  prior  to any  markdown_pattern , thus allowing raw data values to be adjusted by each column's  format  option before they are substituted into any column's  pattern .  The  column_order  annotation SHOULD always provide a meaningful semantic sort for the presented column content.  column_order  MAY be present because the preferred semantic sort may differ from a lexicographic sort of the storage column, e.g. a secondary \"rank\" column might provide a better order for coded values in the annotated storage column.  Column sorting heuristics (use first applicable rule):   Use the column's display  column_order  option, if present.  Sort by presented column value.   The first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.  2016 Table Display \uf0c1  tag:isrd.isi.edu,2016:table-display  This key allows specification of table presentation options at the table or schema level of the model.   {  ...  context   :   {   option  ...  }  ...  } : Apply each  option  to the presentation of table content in the given  context .  {  ...  context1   :   context2  ...  } : Short-hand to allow  context1  to use the same options configured for  context2 .   See  Context Names  section for the list of supported  context  names.  Supported JSON  option  payload patterns:   \"row_order\":   [   sortkey  ...  ] : The list of one or more  sortkey  defines the preferred or default order to present rows from a table. The ordered list of sort keys starts with a primary sort and optionally continues with secondary, tertiary, etc. sort keys. The given  sortkey  s will be used as is ( columnorder  SHOULD not be applied recursivly to this).  \"page_size\":   _number_ : The default number of rows to be shown on a page.    \"row_markdown_pattern\":   rowpattern : Render the row by composing a markdown representation only when  row_markdown_pattern  is non-null.  Expand  rowpattern  to obtain a markdown representation of each row via  Pattern Expansion . The pattern has access to column values  after  any processing implied by  2016 Column Display .  \"separator_markdown\":   separator : Insert  separator  markdown text between each expanded  rowpattern  when presenting row sets. (Default new-line  \"\\n\" .)  Ignore if  \"row_markdown_pattern\"  is not also configured.  \"prefix_markdown\":   prefix : Insert  prefix  markdown before the first  rowpattern  expansion when presenting row sets. (Default empty string  \"\" .)  Ignore if  \"row_markdown_pattern\"  is not also configured.  \"suffix_markdown\":   suffix : Insert  suffix  markdown after the last  rowpattern  expansion when presenting row sets. (Default empty string  \"\" .)  Ignore if  \"row_markdown_pattern\"  is not also configured.  \"module\":   module : Activate  module  to present the entity set. The string literal  module  name SHOULD be one that Chaise associates with a table-presentation plug-in.  \"module_attribute_path\":   pathsuffix : Configure the data source for activated  module . Ignore if  module  is not configured or not understood.  If  pathsuffix  is omitted, use the ERMrest  /entity/  API and a data path denoting the desired set of entities.  If  pathsuffix  is specified, use the ERMrest  /attribute/  API and append  pathsuffix  to a data path denoting the desired set of entities and which binds  S  as the table alias for this entire entity set.  The provided  pathsuffix  MUST provide the appropriate projection-list to form a valid  /attribute/  API URI.  The  pathsuffix  MAY join additional tables to the path and MAY project from these tables as well as the table bound to the  S  table alias.  The  pathsuffix  SHOULD reset the path context to  $S  if it has joined other tables.     It is not meaningful to use both  row_markdown_pattern  and  module  in for the same  context . If both are specified, it is RECOMMENDED that the application prefer the  module  configuration and ignore the markdown instructions.  Supported JSON  sortkey  patterns:   { \"column\":   columnname   , \"descending\": true } : Sort according to the values in the  columnname  column in descending order. This is equivalent to the ERMrest sort specifier  @sort(   columnname   ::desc::   ) .  { \"column\":   columnname   , \"descending\": false } : Sort according to the values in the  columnname  column in ascending order. This is equivalent to the ERMrest sort specifier  @sort(   columnname   ) .  { \"column\":   columnname   } : If omitted, the  \"descending\"  field defaults to  false  as per above.  columnname : A bare  columnname  is a short-hand for  { \"column\":   columnname   } .   2016 Table Display Settings Hierarchy \uf0c1  The table display settings apply only to tables, but MAY be annotated at the schema level to set a schema-wide default, if appropriate in a particular model. Any table-level specification of these settings will override the behavior for that table. These settings on other model elements are meaningless and ignored.  For hierarchically inheritable settings, an explicit setting of  null  will turn  off  inheritence and restore default behavior for that model element and any of its nested elements.  2016 Visible Foreign Keys \uf0c1  tag:isrd.isi.edu,2016:visible-foreign-keys  This key indicates that the presentation order and visibility for\nforeign keys referencing a table, useful when presenting \"related entities\".  Supported JSON payload pattern:   {  ...  context   :   fkeylist   ,  ...  } : A separate  fkeylist  can be specified for any number of  context  names.  {  ...  context1   :   context2  ...  } : Short-hand to allow  context1  to use the same fkeylist configured for  context2 .   For presentation contexts which are not listed in the annotation, or when the annotation is entirely absent, all available foreign keys SHOULD be presented unless the application has guidance from other sources. See  Context Names  section for the list of supported  context  names.  Supported  fkeylist  patterns:   [   [   schema name ,   constraint name   ]   ,  ...  ] : Present foreign keys with matching  schema name  and  constraint name , in the order specified in the list. Ignore constraint names that do not correspond to foreign keys in the catalog. Do not present foreign keys that are not mentioned in the list. These 2-element lists use the same format as each element in the  names  property of foreign keys in the JSON model introspection output of ERMrest. The foreign keys MUST represent inbound relationships to the current table.  { \"source\":   sourceentry   } :  Defines a pseudo-column based on the given  sourceentry . For detailed explanation and examples please refer to  here . Other optional attributes that this JSON document can have are:  markdown_name : The markdown to use in place of the default heuristics for title of column.   Supported  sourceentry  pattern in here:\n  -  path : An array of  foreign key path  that ends with a  columnname  that will be projected.  foreign key path  is in the following format:        \"`{` _direction_ `:[` *schema name*`,` *constraint name* `]}` \"\n  Where _direction_ is either `inbound`, or `outbound`.  2016 Table Alternatives \uf0c1  tag:isrd.isi.edu,2016:table-alternatives  This key indicates that the annotated table (e.g. the base storage table) has abstracted views/tables that should be used as  alternataive  tables in different contexts. This means that they both represent the same  entity set  but\nthe alternative one has modified the representation of each entity in some way.  Supported JSON payload patterns:   {  ...  context   :  [  sname ,  tname ]  ,  ...  } : The table identified by  sname : tname  is an alternative table to be used instead of the annoted table in the specified context.   A alternative table or view which abstracts another table  SHOULD  have a non-null (psuedo) primary key which is also a foreign key to the base storage table. The base storage table is the one bearing this annotation. Otherwise, a consuming application would not know how to navigate from one abstracted representation of an entity to another representation from the base storage tables.  See  Context Names  section for the list of supported  context  names. It is assumed that any application context that is performing mutation (record creation, deletion, or editing) MUST use a base entity storage table that is not an abstraction over another table. However, the use of the  detailed  or  compact  context MAY offer an abstraction that augments the presentation of an existing record. An application offering mutation options while displaying an existing entity record might then present the data from the  detailed  or  compact  abstraction but only offer editing or data-entry controls on the fields available from the base storage table.  2017 Asset \uf0c1  tag:isrd.isi.edu,2017:asset  This key indicates that the annotated column stores asset locations. An  asset  is a generic, fixed-length octet-stream of data, i.e. a \"file\" or \"object\" which can be stored, retrieved, and interpreted by consumers.  An asset  location  is a  globally unique  and  resolvable  string, used to reference and retrieve the identified asset either directly or indirectly through a resolution service. For example, an HTTP URL is both globally unique and resolvable. In the case of a relative URL, the client should resolve the URL within the context from which it was retrieved. Persistent identifier schemes MAY be used such as MINID, DOI, ARK, or PURL. It is up to client tooling to recognize and resolve identifiers in such schemes.  A new asset location may be specified via a pattern to induce a prospective asset location based on known metadata values, i.e. to normalize where to upload and store a new asset in a data-submission process. Only meaningful where clients can request creation of new assets with a desired location.  Supported JSON payload patterns:   { ...  \"url_pattern\":   pattern  ... } : A desired upload location can be derived by  Pattern Expansion  on  pattern . This attribute is required for browser upload and if it is not specified the client will not provide the browser upload feature. See implementation notes below.  { ...  \"browser_upload\":   False  ...  } : If  url_pattern  is availale and valid browser upload feature will be enabled. If you want to force disabling this feature set it to  False .  { ...  \"filename_column\":   column  ... } : The  column  stores the filename of the asset.  { ...  \"byte_count_column\":   column  ... } : The  column  stores the file size in bytes of the asset. It SHOULD be an integer typed column.  { ...  \"md5\":   column  |  True  ... } : If  column , then the  column  stores the checksum generated by the 'md5' cryptographic hash function. It MUST be ASCII/UTF-8 hexadecimal encoded. If  True , then the client SHOULD generate a 'md5' checksum and communicate it to the asset storage service according to its protocol.  { ...  \"sha256\":   column  |  True  ... } : If  column , then the  column  stores the checksum generated by the 'sha256' cryptographic hash function. It MUST be ASCII/UTF-8 hexadecimal encoded. If  True , then the client SHOULD generate a 'sha256' checksum and communicate it to the asset storage service according to its protocol. See implementation notes below.  { ...  \"filename_ext_filter\": [  {  filename extension  [ ,   filename extension  ]* }  ]  ... } : This property specifies a set of  filename extension  filters for use by upload agents to indicate to the user the acceptable filename patterns ( .jpg ,  .png ,  .pdf , ...). For example,  .jpg  would indicate that only JPEG files should be selected by the user.   Default heuristics:\n- The  2017 Asset  annotation explicitly indicates that the associated column is the asset location.\n-  url_pattern  MUST be specified for browser upload. If it is not specified or if it produces a null value, the browser upload will be disabled.\n- Column MUST be  text  typed. Otherwise the asset annotation will be ignored.\n- In addition to native columns, the following properties are also available under the annotated column object and can be referred in the  pattern  e.g.  _URI.md5_hex  where  URI  is the annotated column (notice the  underscore before the column name ).\n  -  md5_hex  for hex \n  -  md5_base64  for base64\n  -  filename  for filename\n  -  size  for size in bytes\n- Nothing may be inferred without additional payload patterns present.  Protocol-specific metadata retrieval MAY be applied once an asset location is known. How to present or reconcile contradictions in metadata found in multiple sources is beyond the scope of this specification.\n- Some applications may treat ERMrest data as prefetched or cached metadata.\n- Some applications may treat ERMrest data as authoritative metadata registries.\n- Some location schemes may define authoritative metadata resolution procedures.  At present, the Chaise implementation of the asset annotation has the following limitations:\n1. 'generated' column(s) in the  url_pattern  are only supported in the  entry/edit  context and  not  in the  entry/create  context. If you wish to use 'generated' column(s) in the  url_pattern , you will need to use the  2016 Visible Columns  annotation and leave the asset column out of the list of visible columns for its  entry/create  context.\n2.  sha256  is not presently supported.\n3. If  url_pattern  is not available or  browser_upload  is  False  Chaise will show a disabled form field for the asset column. It will still provide the download button in read-only contexts.  Context Names \uf0c1  List of  context  names that are used in ermrest:\n-  \"compact\" : Any compact, tabular presentation of data from multiple entities.\n  -  \"compact/brief\" : A limited compact, tabular presentation of data from multiple entities to be shown under the  detailed  context. In this context, only a page of data will be shown with a link to the access the  compact  context for more detail. \n  -  \"compact/select\" : A sub-context of  compact  that is used for selecting entities, e.g. when prompting the user for choosing a foreign key value.\n-  \"detailed\" : Any detailed read-only, entity-level presentation context.\n-  \"entry\" : Any data-entry presentation context, i.e. when prompting the user for input column values.\n  -  \"entry/edit\" : A sub-context of  entry  that only applies to editing existing resources.\n  -  \"entry/create\" : A sub-context of  entry  that only applies to creating new resources.\n-  \"filter\" : Any data-filtering control context, i.e. when prompting the user for column constraints or facets.\n-  \"row_name\" : Any abbreviated title-like presentation context.\n  -  \"row_name/title\" : A sub-context of  row_name  that only applies to title of page.\n  -  \"row_name/compact\" : A sub-context of  row_name  that only applies to compact, tabluar presentation of a row (When a foreignkey value is displayed in a tabular presentation).\n  -  \"row_name/detailed\" : A sub-context of  row_name  that only applies to entity-level presentation of a row (When a foreignkey value is displayed in the entity-level page).\n-  \"*\" : A default to apply for any context not matched by a more specific context name.  If more than one  context  name in the annotation payload matches, the  options  should be combined in the following order (first occurrence wins):   Prefer  option  set in matching contexts with exact matching context name.  Prefer  option  set in matching contexts with longest matching prefix, e.g. an option for  entry  can match application context  entry/edit  or  entry/create .  Use default  option  set in context  * .   The following matrix illustrates which context is meaningful in which annotation.     Annotation  compact  compact/brief  compact/select  detailed  entry  entry/edit  entry/create  filter  row_name  *      2015 Display  X  -  X  X  X  X  X  X  -  X    2016 Ignore  X  -  X  X  X  X  X  X  -  X    2016 Visible Columns  X  -  X  X  X  X  X  X  -  X    2016 Column Display  X  -  X  X  X  X  X  X  -  X    2016 Table Display  X  X  X  X  -  -  -  X  X  X    2016 Visible Foreign Keys  X  -  -  X  X  X  X  X  -  X    2016 Table Alternatives  X  -  X  X  -  -  -  X  -  X", 
            "title": "Annotations"
        }, 
        {
            "location": "/user-doc/annotation/#pattern-expansion", 
            "text": "When deriving a field value from a  pattern , the  pattern  MAY contain markers for substring replacements of the form  {{column name}}  or  {{{ column name}}}  where  column name  MUST reference a column in the table. Any particular column name MAY be referenced and expanded zero or more times in the same  pattern .  For example, a  column  may have a  tag:isrd.isi.edu,2016:column-display  annotation containing the following payload:  {\n    *  : {\n        markdown_pattern :  [{{{title}}}](https://dev.isrd.isi.edu/chaise/search?name={{{_name}}}) \n   }\n}  A web user agent that consumes this annotation and the related table data would likely display the following as the value of the column:  p \n     img src= https://dev.isrd.isi.edu/chaise/search?name=col%20name  alt= Title of Image  /p   For detailed explanation on template and markdown language please refer to  Template and Markdown Guide .", 
            "title": "Pattern Expansion"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/", 
            "text": "ermrest-registry-purge\n\uf0c1\n\n\nermrest-registry-purge -- purge ERMrest catalogs\n\n\nSynopsis\n\uf0c1\n\n\nermrest-registry-purge [-dfh] [-a|i INTERVAL] [-z DIR]\n\n\n\n\nDescription\n\uf0c1\n\n\nermrest-registry-purge purges ERMrest catalogs. The command will run database\nutilities to drop databases and remove entries from the ERMrest registry of\ncatalogs. Optionally, it will force disconnect of client connections and/or\narchive databases before dropping them. By default, it purges any deleted\ndatabase, but it includes options to purge all catalogs or to purge only\ncatalogs that are at least as old as a given age.\n\n\nOptions\n\uf0c1\n\n\nermrest-registry-purge accepts the following command-line arguments: \n\n\n-a\n\n    Purges all catalogs, not just those that have been deleted.\n\n\n-d\n\n    Dry run. Identify but do not purge catalogs that match selection criteria.\n\n\n-f\n\n    Force disconnect of clients before attempting purges.\n\n\n-h\n\n    Show help about this command and exit.\n\n\n-i INTERVAL\n\n    Only purge catalogs that were deleted prior to \nINTERVAL\n, where \nINTERVAL\n\n    is a valid PostgreSQL timestamp interval such as '1 week', '2 years',\n    '24 hours', '31 days', etc.\n\n\n-q\n\n    Executes quietly. By default, the command prints a line for each catalog\n    that is being purged.\n\n\n-z DIR\n\n    Archive the catalog as a file in \nDIR\n. The archive filename includes the \n    catalog identifier, the database name, and the seconds since epoch. The\n    file contains the complete \nSQL\n commands required to recreate the catalog.\n    The format of the archive file is \ngzip\n compressed plain text.\n\n\nExit Status\n\uf0c1\n\n\nermrest-registry-purge returns 0 to the shell if it finished normally or 1 if a\nusage error occurs.\n\n\nExamples\n\uf0c1\n\n\nTo purge all deleted catalogs:\n\n\n# ermrest-registry-purge\n\n\n\n\nTo purge all deleted catalogs that were deleted at least 7 days ago:\n\n\n# ermrest-registry-purge -i '7 days'\n\n\n\n\nTo purge all deleted catalogs that were deleted at least 1 year ago and archive\nthem to /home/ermrest/backups:\n\n\n# ermrest-registry-purge -i '1 year' -z /home/ermrest/backups\n\n\n\n\nTo purge all deleted catalogs that were deleted at least 1 hour ago and\nforce client disconnect:\n\n\n# ermrest-registry-purge -f -i '1 hour'\n\n\n\n\nTo purge all catalogs, even those that have not been deleted, and force\ndisconnect:\n\n\n# ermrest-registry-purge -a -f\n\n\n\n\nTo do a \ndry run\n that will \nnot\n purge any catalogs:\n\n\n# ermrest-registry-purge -d", 
            "title": "ermrest-registry-purge"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#ermrest-registry-purge", 
            "text": "ermrest-registry-purge -- purge ERMrest catalogs", 
            "title": "ermrest-registry-purge"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#synopsis", 
            "text": "ermrest-registry-purge [-dfh] [-a|i INTERVAL] [-z DIR]", 
            "title": "Synopsis"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#description", 
            "text": "ermrest-registry-purge purges ERMrest catalogs. The command will run database\nutilities to drop databases and remove entries from the ERMrest registry of\ncatalogs. Optionally, it will force disconnect of client connections and/or\narchive databases before dropping them. By default, it purges any deleted\ndatabase, but it includes options to purge all catalogs or to purge only\ncatalogs that are at least as old as a given age.", 
            "title": "Description"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#options", 
            "text": "ermrest-registry-purge accepts the following command-line arguments:   -a \n    Purges all catalogs, not just those that have been deleted.  -d \n    Dry run. Identify but do not purge catalogs that match selection criteria.  -f \n    Force disconnect of clients before attempting purges.  -h \n    Show help about this command and exit.  -i INTERVAL \n    Only purge catalogs that were deleted prior to  INTERVAL , where  INTERVAL \n    is a valid PostgreSQL timestamp interval such as '1 week', '2 years',\n    '24 hours', '31 days', etc.  -q \n    Executes quietly. By default, the command prints a line for each catalog\n    that is being purged.  -z DIR \n    Archive the catalog as a file in  DIR . The archive filename includes the \n    catalog identifier, the database name, and the seconds since epoch. The\n    file contains the complete  SQL  commands required to recreate the catalog.\n    The format of the archive file is  gzip  compressed plain text.", 
            "title": "Options"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#exit-status", 
            "text": "ermrest-registry-purge returns 0 to the shell if it finished normally or 1 if a\nusage error occurs.", 
            "title": "Exit Status"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#examples", 
            "text": "To purge all deleted catalogs:  # ermrest-registry-purge  To purge all deleted catalogs that were deleted at least 7 days ago:  # ermrest-registry-purge -i '7 days'  To purge all deleted catalogs that were deleted at least 1 year ago and archive\nthem to /home/ermrest/backups:  # ermrest-registry-purge -i '1 year' -z /home/ermrest/backups  To purge all deleted catalogs that were deleted at least 1 hour ago and\nforce client disconnect:  # ermrest-registry-purge -f -i '1 hour'  To purge all catalogs, even those that have not been deleted, and force\ndisconnect:  # ermrest-registry-purge -a -f  To do a  dry run  that will  not  purge any catalogs:  # ermrest-registry-purge -d", 
            "title": "Examples"
        }, 
        {
            "location": "/user-doc/Chado-patterns/", 
            "text": "Chado Vocabulary Patterns\n\uf0c1\n\n\nThis page is to explore some possible use-case patterns for using\nChado schema for controlled vocabularies.\n\n\nAssumptions and conventions\n\uf0c1\n\n\n\n\nWe want to load ontologies easily, so being consistent with Chado is probably helpful.\n\n\nWe want to separate ontology/vocabulary preparation from normal data management operations\n\n\nVocabularies and terms are defined \nbefore\n use in data tables\n\n\nRestricted domain tables are used to present subsets of ontologies for use in data columns\n\n\nData serialization should not depend on order vocabularies are loaded\n\n\nWe will use the dbxref concept specifically with \nDB\n \n:\n \nACCESSION\n \n:\n \nVERSION\n textual formatted indentifiers as keys and foreign keys in vocabulary storage columns, e.g. \nOBO_REL:is_a:\n.\n\n\n\n\nChado-derived core tables\n\uf0c1\n\n\nAssume a basic ontology storage area similar to\n\nChado CV Module\n.  Here, we\nonly focus on the few tables that would affect normal data\nmanagement.\n\n\ndb\n\uf0c1\n\n\nThe \ndb\n table enumerates database authorities.\n\n\nCREATE TABLE db (\n  name text PRIMARY KEY,\n  description text,\n  urlprefix text,\n  url text\n  );\n\n\n\n\n\ncv\n\uf0c1\n\n\nThe \ncv\n table enumerates controlled vocabularies.\n\n\nCREATE TABLE cv (\n  name text PRIMARY KEY,\n  definition text\n);\n\n\n\n\n\ndbxref\n\uf0c1\n\n\nThe \ndbxref\n table enumerates global, unique, stable public identifiers. This table probably won't be used in day-to-day\nqueries because the db, accession, and version are included in denormalized form elsewhere; it's included in the model\nbecause this is the only place the dbxref \ndescription\n field exists.\n\n\nCREATE TABLE dbxref (\n  name text PRIMARY KEY,\n  db text NOT NULL REFERENCES db(name) DEFERRABLE,\n  accession text NOT NULL,\n  version text NOT NULL DEFAULT '',\n  description text,\n  UNIQUE(db, accession, version)\n);\n\n\n\n\ncvterm\n\uf0c1\n\n\nThe \ncvterm\n table enumerates all available terms. In addition to denormalizing the \ndbxref\n and \ncv\n fields, we've\nadded a \ndbxref_unversioned\n field (the dbxref without version information, which is likely to be searched for) and\narray fields for synonyms and alternate dbxrefs (derived from the chado \ncvtermsynonym\n and \ncvterm_dbxref\n tables).\n\n\ncreate table cvterm (\n  dbxref text PRIMARY KEY REFERENCES dbxref(name) DEFERRABLE,\n  dbxref_unversioned text NOT NULL,\n  cv text NOT NULL REFERENCES cv(name) DEFERRABLE,\n  name text NOT NULL,\n  definition text,\n  is_obsolete boolean NOT NULL,\n  is_relationshiptype boolean NOT NULL,\n  synonyms text[],\n  alternate_dbxrefs text[],\n  UNIQUE(cv, name, is_obsolete),\n  CHECK(dbxref LIKE dbxref_unversioned || ':%')\n);\n\n\n\n\ncvtermpath\n\uf0c1\n\n\nThe \ncvtermpath\n table stores transitive closures of term-to-term relationship graphs.\nThe \ncvtermpath_id\n field is present only because ermrest requires a single-valued unique key.\n\n\nCREATE TABLE cvtermpath (\n  cvtermpath_id bigserial PRIMARY KEY,\n  type_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  subject_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  object_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  pathdistance integer NOT NULL,\n  UNIQUE(type_dbxref, subject_dbxref, object_dbxref)\n);  \n\n\n\n\nWe constrain the path table:\n\n\n\n\nDon't allow NULL \ntype_dbxref\n which is a closure over multiple relationships\n\n\nDon't store multiple rows for same subject, relationship, object. Store \nminimum\n path distance.\n\n\n\n\nDomain tables\n\uf0c1\n\n\nWe can have any number of domain tables to enumerate a subset of\ncontrolled vocabulary terms. Each domain table is a filtered subset of\n\ncvterm\n with the same structure. A domain table could be implemented as\nmaterialized views defined with \ncreate materialized view mydomain1 as select * from cvterm where ...\n,\nas tables curated by hand, etc.\n\n\nCREATE TABLE mydomain1 (\n  cvtermpath_id bigserial PRIMARY KEY,\n  type_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  subject_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  object_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  pathdistance integer NOT NULL,\n  UNIQUE(type_dbxref, subject_dbxref, object_dbxref)\n);\n\n\n\n\nWe want a foreign key reference constraint to emphasize that the domain table is a proper subset of the core cvterm table.\n\n\nDomain path tables\n\uf0c1\n\n\nFor each domain table, we will have a corresponding table defined as a subset of\n\ncvtermpath\n with all records that include any term in the domain table. For example,\na domain path table could be defined with\n\n\ncreate materialized view mydomain1_path as\n  select * from cvtermpath p\n  join mydomain1 d on d.dbxref = p.subject_dbxref or d.dbxref = p.object_dbxref;\n\n\n\n\nData tables using controlled terms\n\uf0c1\n\n\nWe can use controlled vocabularies for any number of data columns by\nconfiguring a foreign key constraint to a domain table.\n\n\nCREATE TABLE mydata (\n   ...\n   myconcept text REFERENCES mydomain1 (dbxref),\n   ...\n);\n\n\n\n\nHeuristics and idioms\n\uf0c1\n\n\nBasic data access\n\uf0c1\n\n\nNaive access to data tables can completely ignore the connections to a\nvocabulary and just consume the stored data column as explicit dbxref\nstrings.\n\n\nData integrity and basic value enumeration\n\uf0c1\n\n\nAny consumer can introspect the data table and understand the foreign\nkey constraint to see which dbxref values are allows in a data\ncolumn. The database will enforce the foreign key integrity to prevent\nvalues from being added to a data column outside the configured domain\nterm set.\n\n\nPrettier term display\n\uf0c1\n\n\nBecause the domain table uses the same schema as the core cvterm table,\nit includes definitions and other metadata. Some presentation customization\ncan be done based on this information alone. However, there might be more\nvocabulary-aware UX features desired in some cases?\n\n\nOptions:\n\n\n\n\nUse normal Chaise/annotation features to adjust domain table \"row name\".\n\n\nDetect fkey chain to core cvterm table to enable special vocabulary functions?\n\n\nAnnotate domain tables to enable special vocabulary functions?\n\n\n\n\nSemantic search via transitive closures\n\uf0c1\n\n\nAny consumer can recognize the foreign key chain, through domain\ntable, to the \ncvterm\n table and the presence of the \ncvtermpath\n\ntable encoding inter-term relationships.\n\n\nA phase 1 joined query similar to this ERMrest URL can be used to\nsearch for a set of terms:\n\n\n/catalog/N/attribute/P:=cvtermpath/T:=(type_id)/dbxref=REL/pathdistance::lt::10/$P/O:=(object_id)/dbexref=BOUND/S:=(subject_id)/mydomain1/dbxref\n\n\n\n\nThis query would return a set of distinct dbxref values that are less\nthan \n10\n hops below an upper-bound dbxref \nBOUND\n in the graph of\n\nREL\n relationship (mixed-in with \nOBO_REL:is_a\n (subclass)\nrelationship but only if the output terms also appear in the term\ndomain \nmydomain1\n which is a subset of all possible terms in the\nsystem.\n\n\nA phase 2 search can express actual data column constraints to match\non a disjunctive list of terms found by the phase 1 search.  Even if\nwe implement this on the server, we'd probably do the same two-phase\nsearch, to in-line the bounded term set as a disjunction of constants\n(that's our experience with how to get high performance out of\nPostgres for complex analytic queries).\n\n\nOptions:\n\n\n\n\nDo both search phases on client side with no new ERMrest API\n   features.  Might hit some URL length limits eventually.\n\n\nAdd a filter syntax to ERMrest API to allow the query triplet of\n   (term domain, relationship, and boundary to be encoded as a direct\n   predicate on a data column.  E.g. \ncolumn::relationship::boundary\n\n\n\n\nDiscussion:\n\n\nTo add a query syntactic sugar to ERMrest, we'd need to hard-code a\nmapping of directed relationship terms, e.g. \nOBO_REL:is_a\n, to new\nERMrest predicate operators, e.g. \n::subclass_of::\n and\n\n::has_subclass::\n so we can express both upper and lower-bounded\nconstraints against a data column. The right-hand side of the\npredicate would specify the boundary value as a dbxref string\n(URL-encoded to escape the colon chars). With this sugar, the\n\npathdistance\n would not be able to be constrained since there is no\nreasonable binary predicate syntax to combine relationship type,\nboundary, and path-length.\n\n\nTo provide a GUI UX for semantic search, you probably need more than\nto choose a relationship and type in dbxref boundary values. You\nprobably need the equivalent of the phase 1 search to show the user\nhow the term space expands from a particular combination of boundary\nand relationship type while still being limited to the column's term\ndomain.  In order to present such a UX, you already have to have\nclient-side detection and awareness of when semantic search is\napplicable as well as how to retrieve and preview these term\nsub-graphs.\n\n\nAssuming all the client-side work for a semantic search UX, it is not\nclear what value the ERMrest syntactic sugar would add except\nrobustness against large term sets being encoded in URLs. The\nclient-side complexity does not change much as long as you need to\nguide users through a query-construction UX...\n\n\nOpen questions\n\uf0c1\n\n\nShould we differentiate between different types of synonyms?\n\uf0c1\n\n\nCurrently, all synonyms included in the \ncvtermsynonym\n table are included in the \nsynonyms\n field of \ncvterm\n.\nSynonyms can be of different types, however, and we may want to treat synonyms differently based on their type.\nTo facilitate discussion, I've included the \ncvtermsynonym\n table (denormalized for our-style foreign keys),\nwhich includes all synonyms and their types:\n\n\ncreate table cvtermsynonym (\n  cvtermsynonym_id bigserial PRIMARY KEY,\n  dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  synonym text NOT NULL,\n  synonym_type text,\n  UNIQUE (dbxref, synonym)\n);\n\n\n\n\nWhich alternate dbxrefs should be included in the cvterm table?\n\uf0c1\n\n\nChado has a table called \ncvterm_dbxref\n which includes both external\ndbxrefs and dbxrefs that are used for provenance\ninformation. Currently, we include both in the \nalternate_dbxrefs\n\nfield of the \ncvterm\n database. To facilitate discussion, I've\nincluded the \ncvterm_dbxref\n table (denormalized for our-style foreign\nkeys):\n\n\nCREATE TABLE cvterm_dbxref (\n  cvterm_dbxref_id bigserial PRIMARY KEY,\n  cvterm text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  alternate_dbxref text NOT NULL REFERENCES dbxref(name) DEFERRABLE,\n  is_for_definition boolean,\n  UNIQUE(primary_dbxref, alternate_dbxref)\n);\n\n\n\n\nWhat dbxrefs should appear in the domain table?\n\uf0c1\n\n\nOur current model specifies that domain tables should have the same format as \ncvterm\n tables, with the \ndbxref\n field a foreign\nkey to the \ncvterm\n table. For example, one entry from Uberon looks like this:\n\n\ndbxref              | UBERON:0000006:\ndbxref_unversioned  | UBERON:0000006\ncv                  | uberon\nname                | islet of Langerhans\ndefinition          | the clusters of hormone-producing cells that are scattered throughout the pancreas\nis_obsolete         | f\nis_relationshiptype | f\nsynonyms            | {\npancreatic islet\n,\npancreatic insula\n,\nislets of Langerhans\n,\nisland of pancreas\n,\nisland of Langerhans\n}\nalternate_dbxrefs   | {XAO:0000159:,VHOG:0000646:,UMLS:C0022131:,MIAA:0000076:,MESH:D007515:,MAT:0000076:,\n                       URL:http://linkedlifedata.com/resource/umls/id/C0022131:,\n               URL:http://en.wikipedia.org/wiki/Islets_of_Langerhans:,GAID:324:,FMA:16016:,EV:0100130:,EMAPA:32927:,\n               EFO:0000856:,CALOHA:TS-0741:,BTO:0000991:,AAO:0010406:,NULL:C12608:,MP:0005215:,MESH:A03.734.414:,MA:0000127:}\n\n\n\n\nA GUDMAP user is more likely to want to look for EMAPA:32927 than any\nof the dbxrefs in this entry (\nalternate_dbxrefs\n includes the\nversioned version EMAPA:32927:). It might make more sense for the\n\ndbxref_unversioned\n column of the domain table to include the\nunversioned dbxref that users are most likely to recognize, like this:\n\n\ndbxref              | UBERON:0000006:\ndbxref_unversioned  | EMAPA:32927\ncv                  | uberon\nname                | islet of Langerhans\ndefinition          | the clusters of hormone-producing cells that are scattered throughout the pancreas\nis_obsolete         | f\nis_relationshiptype | f\nsynonyms            | {\npancreatic islet\n,\npancreatic insula\n,\nislets of Langerhans\n,\nisland of pancreas\n,\nisland of Langerhans\n}\nalternate_dbxrefs   | {XAO:0000159:,VHOG:0000646:,UMLS:C0022131:,MIAA:0000076:,MESH:D007515:,MAT:0000076:,\n                       URL:http://linkedlifedata.com/resource/umls/id/C0022131:,\n               URL:http://en.wikipedia.org/wiki/Islets_of_Langerhans:,GAID:324:,FMA:16016:,EV:0100130:,EMAPA:32927:,\n               EFO:0000856:,CALOHA:TS-0741:,BTO:0000991:,AAO:0010406:,NULL:C12608:,MP:0005215:,MESH:A03.734.414:,MA:0000127:}\n\n\n\n\nIf we do this, we might want to change the name \ndbxref_unversioned\n to something like \ndbxref_common\n.\n\n\nSecond thoughts about arrays in cvterm\n\uf0c1\n\n\nIn Postgres, there are two equivalent ways to express \"'foo' is an element of the array bar\" in a query:\n\n\n'foo' = ANY(bar)\n\n\n\n\nor\n\n\n'{foo}' \n@ bar\n\n\n\n\nThe second form will take advantage of gin indexes; the first form will not. Pattern matching is also difficult on array elements.\nWe might want to consider dropping the array columns from \ncvterm\n and using \ncvtermsynonym\n and \ncvterm_dbxref\n instead.\n\n\nImplementation\n\uf0c1\n\n\nSee the \ndata commons chado directory\n for\nscripts to create a data_commons schema and pull data from chado into those tables. See the\n\ndata commons chado/obo directory\n\nfor information about reading obo files into standard chado tables.", 
            "title": "Chado Vocabulary Patterns"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#chado-vocabulary-patterns", 
            "text": "This page is to explore some possible use-case patterns for using\nChado schema for controlled vocabularies.", 
            "title": "Chado Vocabulary Patterns"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#assumptions-and-conventions", 
            "text": "We want to load ontologies easily, so being consistent with Chado is probably helpful.  We want to separate ontology/vocabulary preparation from normal data management operations  Vocabularies and terms are defined  before  use in data tables  Restricted domain tables are used to present subsets of ontologies for use in data columns  Data serialization should not depend on order vocabularies are loaded  We will use the dbxref concept specifically with  DB   :   ACCESSION   :   VERSION  textual formatted indentifiers as keys and foreign keys in vocabulary storage columns, e.g.  OBO_REL:is_a: .", 
            "title": "Assumptions and conventions"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#chado-derived-core-tables", 
            "text": "Assume a basic ontology storage area similar to Chado CV Module .  Here, we\nonly focus on the few tables that would affect normal data\nmanagement.  db \uf0c1  The  db  table enumerates database authorities.  CREATE TABLE db (\n  name text PRIMARY KEY,\n  description text,\n  urlprefix text,\n  url text\n  );  cv \uf0c1  The  cv  table enumerates controlled vocabularies.  CREATE TABLE cv (\n  name text PRIMARY KEY,\n  definition text\n);  dbxref \uf0c1  The  dbxref  table enumerates global, unique, stable public identifiers. This table probably won't be used in day-to-day\nqueries because the db, accession, and version are included in denormalized form elsewhere; it's included in the model\nbecause this is the only place the dbxref  description  field exists.  CREATE TABLE dbxref (\n  name text PRIMARY KEY,\n  db text NOT NULL REFERENCES db(name) DEFERRABLE,\n  accession text NOT NULL,\n  version text NOT NULL DEFAULT '',\n  description text,\n  UNIQUE(db, accession, version)\n);  cvterm \uf0c1  The  cvterm  table enumerates all available terms. In addition to denormalizing the  dbxref  and  cv  fields, we've\nadded a  dbxref_unversioned  field (the dbxref without version information, which is likely to be searched for) and\narray fields for synonyms and alternate dbxrefs (derived from the chado  cvtermsynonym  and  cvterm_dbxref  tables).  create table cvterm (\n  dbxref text PRIMARY KEY REFERENCES dbxref(name) DEFERRABLE,\n  dbxref_unversioned text NOT NULL,\n  cv text NOT NULL REFERENCES cv(name) DEFERRABLE,\n  name text NOT NULL,\n  definition text,\n  is_obsolete boolean NOT NULL,\n  is_relationshiptype boolean NOT NULL,\n  synonyms text[],\n  alternate_dbxrefs text[],\n  UNIQUE(cv, name, is_obsolete),\n  CHECK(dbxref LIKE dbxref_unversioned || ':%')\n);  cvtermpath \uf0c1  The  cvtermpath  table stores transitive closures of term-to-term relationship graphs.\nThe  cvtermpath_id  field is present only because ermrest requires a single-valued unique key.  CREATE TABLE cvtermpath (\n  cvtermpath_id bigserial PRIMARY KEY,\n  type_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  subject_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  object_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  pathdistance integer NOT NULL,\n  UNIQUE(type_dbxref, subject_dbxref, object_dbxref)\n);    We constrain the path table:   Don't allow NULL  type_dbxref  which is a closure over multiple relationships  Don't store multiple rows for same subject, relationship, object. Store  minimum  path distance.", 
            "title": "Chado-derived core tables"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#domain-tables", 
            "text": "We can have any number of domain tables to enumerate a subset of\ncontrolled vocabulary terms. Each domain table is a filtered subset of cvterm  with the same structure. A domain table could be implemented as\nmaterialized views defined with  create materialized view mydomain1 as select * from cvterm where ... ,\nas tables curated by hand, etc.  CREATE TABLE mydomain1 (\n  cvtermpath_id bigserial PRIMARY KEY,\n  type_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  subject_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  object_dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  pathdistance integer NOT NULL,\n  UNIQUE(type_dbxref, subject_dbxref, object_dbxref)\n);  We want a foreign key reference constraint to emphasize that the domain table is a proper subset of the core cvterm table.", 
            "title": "Domain tables"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#domain-path-tables", 
            "text": "For each domain table, we will have a corresponding table defined as a subset of cvtermpath  with all records that include any term in the domain table. For example,\na domain path table could be defined with  create materialized view mydomain1_path as\n  select * from cvtermpath p\n  join mydomain1 d on d.dbxref = p.subject_dbxref or d.dbxref = p.object_dbxref;", 
            "title": "Domain path tables"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#data-tables-using-controlled-terms", 
            "text": "We can use controlled vocabularies for any number of data columns by\nconfiguring a foreign key constraint to a domain table.  CREATE TABLE mydata (\n   ...\n   myconcept text REFERENCES mydomain1 (dbxref),\n   ...\n);", 
            "title": "Data tables using controlled terms"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#heuristics-and-idioms", 
            "text": "Basic data access \uf0c1  Naive access to data tables can completely ignore the connections to a\nvocabulary and just consume the stored data column as explicit dbxref\nstrings.  Data integrity and basic value enumeration \uf0c1  Any consumer can introspect the data table and understand the foreign\nkey constraint to see which dbxref values are allows in a data\ncolumn. The database will enforce the foreign key integrity to prevent\nvalues from being added to a data column outside the configured domain\nterm set.  Prettier term display \uf0c1  Because the domain table uses the same schema as the core cvterm table,\nit includes definitions and other metadata. Some presentation customization\ncan be done based on this information alone. However, there might be more\nvocabulary-aware UX features desired in some cases?  Options:   Use normal Chaise/annotation features to adjust domain table \"row name\".  Detect fkey chain to core cvterm table to enable special vocabulary functions?  Annotate domain tables to enable special vocabulary functions?   Semantic search via transitive closures \uf0c1  Any consumer can recognize the foreign key chain, through domain\ntable, to the  cvterm  table and the presence of the  cvtermpath \ntable encoding inter-term relationships.  A phase 1 joined query similar to this ERMrest URL can be used to\nsearch for a set of terms:  /catalog/N/attribute/P:=cvtermpath/T:=(type_id)/dbxref=REL/pathdistance::lt::10/$P/O:=(object_id)/dbexref=BOUND/S:=(subject_id)/mydomain1/dbxref  This query would return a set of distinct dbxref values that are less\nthan  10  hops below an upper-bound dbxref  BOUND  in the graph of REL  relationship (mixed-in with  OBO_REL:is_a  (subclass)\nrelationship but only if the output terms also appear in the term\ndomain  mydomain1  which is a subset of all possible terms in the\nsystem.  A phase 2 search can express actual data column constraints to match\non a disjunctive list of terms found by the phase 1 search.  Even if\nwe implement this on the server, we'd probably do the same two-phase\nsearch, to in-line the bounded term set as a disjunction of constants\n(that's our experience with how to get high performance out of\nPostgres for complex analytic queries).  Options:   Do both search phases on client side with no new ERMrest API\n   features.  Might hit some URL length limits eventually.  Add a filter syntax to ERMrest API to allow the query triplet of\n   (term domain, relationship, and boundary to be encoded as a direct\n   predicate on a data column.  E.g.  column::relationship::boundary   Discussion:  To add a query syntactic sugar to ERMrest, we'd need to hard-code a\nmapping of directed relationship terms, e.g.  OBO_REL:is_a , to new\nERMrest predicate operators, e.g.  ::subclass_of::  and ::has_subclass::  so we can express both upper and lower-bounded\nconstraints against a data column. The right-hand side of the\npredicate would specify the boundary value as a dbxref string\n(URL-encoded to escape the colon chars). With this sugar, the pathdistance  would not be able to be constrained since there is no\nreasonable binary predicate syntax to combine relationship type,\nboundary, and path-length.  To provide a GUI UX for semantic search, you probably need more than\nto choose a relationship and type in dbxref boundary values. You\nprobably need the equivalent of the phase 1 search to show the user\nhow the term space expands from a particular combination of boundary\nand relationship type while still being limited to the column's term\ndomain.  In order to present such a UX, you already have to have\nclient-side detection and awareness of when semantic search is\napplicable as well as how to retrieve and preview these term\nsub-graphs.  Assuming all the client-side work for a semantic search UX, it is not\nclear what value the ERMrest syntactic sugar would add except\nrobustness against large term sets being encoded in URLs. The\nclient-side complexity does not change much as long as you need to\nguide users through a query-construction UX...", 
            "title": "Heuristics and idioms"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#open-questions", 
            "text": "Should we differentiate between different types of synonyms? \uf0c1  Currently, all synonyms included in the  cvtermsynonym  table are included in the  synonyms  field of  cvterm .\nSynonyms can be of different types, however, and we may want to treat synonyms differently based on their type.\nTo facilitate discussion, I've included the  cvtermsynonym  table (denormalized for our-style foreign keys),\nwhich includes all synonyms and their types:  create table cvtermsynonym (\n  cvtermsynonym_id bigserial PRIMARY KEY,\n  dbxref text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  synonym text NOT NULL,\n  synonym_type text,\n  UNIQUE (dbxref, synonym)\n);  Which alternate dbxrefs should be included in the cvterm table? \uf0c1  Chado has a table called  cvterm_dbxref  which includes both external\ndbxrefs and dbxrefs that are used for provenance\ninformation. Currently, we include both in the  alternate_dbxrefs \nfield of the  cvterm  database. To facilitate discussion, I've\nincluded the  cvterm_dbxref  table (denormalized for our-style foreign\nkeys):  CREATE TABLE cvterm_dbxref (\n  cvterm_dbxref_id bigserial PRIMARY KEY,\n  cvterm text NOT NULL REFERENCES cvterm(dbxref) DEFERRABLE,\n  alternate_dbxref text NOT NULL REFERENCES dbxref(name) DEFERRABLE,\n  is_for_definition boolean,\n  UNIQUE(primary_dbxref, alternate_dbxref)\n);  What dbxrefs should appear in the domain table? \uf0c1  Our current model specifies that domain tables should have the same format as  cvterm  tables, with the  dbxref  field a foreign\nkey to the  cvterm  table. For example, one entry from Uberon looks like this:  dbxref              | UBERON:0000006:\ndbxref_unversioned  | UBERON:0000006\ncv                  | uberon\nname                | islet of Langerhans\ndefinition          | the clusters of hormone-producing cells that are scattered throughout the pancreas\nis_obsolete         | f\nis_relationshiptype | f\nsynonyms            | { pancreatic islet , pancreatic insula , islets of Langerhans , island of pancreas , island of Langerhans }\nalternate_dbxrefs   | {XAO:0000159:,VHOG:0000646:,UMLS:C0022131:,MIAA:0000076:,MESH:D007515:,MAT:0000076:,\n                       URL:http://linkedlifedata.com/resource/umls/id/C0022131:,\n               URL:http://en.wikipedia.org/wiki/Islets_of_Langerhans:,GAID:324:,FMA:16016:,EV:0100130:,EMAPA:32927:,\n               EFO:0000856:,CALOHA:TS-0741:,BTO:0000991:,AAO:0010406:,NULL:C12608:,MP:0005215:,MESH:A03.734.414:,MA:0000127:}  A GUDMAP user is more likely to want to look for EMAPA:32927 than any\nof the dbxrefs in this entry ( alternate_dbxrefs  includes the\nversioned version EMAPA:32927:). It might make more sense for the dbxref_unversioned  column of the domain table to include the\nunversioned dbxref that users are most likely to recognize, like this:  dbxref              | UBERON:0000006:\ndbxref_unversioned  | EMAPA:32927\ncv                  | uberon\nname                | islet of Langerhans\ndefinition          | the clusters of hormone-producing cells that are scattered throughout the pancreas\nis_obsolete         | f\nis_relationshiptype | f\nsynonyms            | { pancreatic islet , pancreatic insula , islets of Langerhans , island of pancreas , island of Langerhans }\nalternate_dbxrefs   | {XAO:0000159:,VHOG:0000646:,UMLS:C0022131:,MIAA:0000076:,MESH:D007515:,MAT:0000076:,\n                       URL:http://linkedlifedata.com/resource/umls/id/C0022131:,\n               URL:http://en.wikipedia.org/wiki/Islets_of_Langerhans:,GAID:324:,FMA:16016:,EV:0100130:,EMAPA:32927:,\n               EFO:0000856:,CALOHA:TS-0741:,BTO:0000991:,AAO:0010406:,NULL:C12608:,MP:0005215:,MESH:A03.734.414:,MA:0000127:}  If we do this, we might want to change the name  dbxref_unversioned  to something like  dbxref_common .  Second thoughts about arrays in cvterm \uf0c1  In Postgres, there are two equivalent ways to express \"'foo' is an element of the array bar\" in a query:  'foo' = ANY(bar)  or  '{foo}'  @ bar  The second form will take advantage of gin indexes; the first form will not. Pattern matching is also difficult on array elements.\nWe might want to consider dropping the array columns from  cvterm  and using  cvtermsynonym  and  cvterm_dbxref  instead.", 
            "title": "Open questions"
        }, 
        {
            "location": "/user-doc/Chado-patterns/#implementation", 
            "text": "See the  data commons chado directory  for\nscripts to create a data_commons schema and pull data from chado into those tables. See the data commons chado/obo directory \nfor information about reading obo files into standard chado tables.", 
            "title": "Implementation"
        }, 
        {
            "location": "/api-docs/", 
            "text": "ERMrest API\n\uf0c1\n\n\nERMrest\n (rhymes with \"earn rest\") is a general relational data storage service for web-based, data-oriented collaboration.  See the \nERMrest overview\n for a general description and motivation.\n\n\nThis technical document specifies the web service protocol in terms of resources, resource representations, resource naming, and operations.\n\n\nURL Conventions\n\uf0c1\n\n\nAny ERMrest URL is a valid HTTP URL and contains user-generated content which may need to be escaped. Several reserved characters from RFC 3986 are used as meta-syntax in ERMrest and MUST be escaped if they are meant to be part of a user-generated identifiers or literal data and MUST NOT be escaped if they are meant to indicate the ERMrest meta-syntax:\n\n\n\n\nThe \n/\n or forward-slash, used as a path separator character\n\n\nThe \n:\n or colon, used as a separator and in multi-character tokens\n\n\nThe \n;\n or semi-colon, used as a separator\n\n\nThe \n,\n or comma, used as a separator\n\n\nThe \n=\n or equals sign, used as an operator and as part of multi-character tokens\n\n\nThe \n?\n or question-mark, used to separate a resource name from query-parameters\n\n\nThe \n or ampersand, used as a separator\n\n\nThe \n(\n and \n)\n parentheses, used for nested grouping\n\n\nTODO: more syntax to list here\n\n\n\n\nAll other reserved characters should be escaped in user-generated content in URLs, but have no special meaning to ERMrest when appearing in unescaped form.\n\n\nResource and Service Model\n\uf0c1\n\n\nAt its core, ERMrest is a multi-tenant service that can host multiple datasets, each with its own entity-relationship model.  The dataset, model, and data are further decomposed into web resources to allow collaborative management and interaction with the data store.\n\n\nGraph of Web Resources\n\uf0c1\n\n\nThe ERMrest web service model exposes resources to support management of datasets, the entity-relationship model, and the actual data stored using that model:\n\n\n\n\nService: the entire multi-tenant service end-point\n\n\nCatalog\n: a particular dataset (in one service)\n\n\nSchema or model resources\n\n\nSchemata\n: entire data model of a dataset (in one catalog)\n\n\nSchema\n: a particular named subset of a dataset (in one catalog)\n\n\nSchema comment\n: human-readable documentation for a schema\n\n\nSchema annotation\n: machine-readable documentation for a schema\n\n\nTable definition\n: a particular named set of data tuples (in one schema)\n\n\nTable comment\n: human-readable documentation for a table\n\n\nTable annotation\n: machine-readable documentation for a table\n\n\nColumn definition\n: a particular named field of data tuples (in one table)\n\n\nColumn comment\n: human-readable documentation for a column\n\n\nColumn annotation\n: machine-readable documentation for a column\n\n\n\n\n\n\nKey definition\n: a composite key constraint (in one table)\n\n\nKey comment\n: human-readable documentation for a key constraint\n\n\nKey annotation\n: machine-readable documentation for a key constraint\n\n\n\n\n\n\nForeign key definition\n: a composite foreign key constraint (in one table)\n\n\nForeign key comment\n: human-readable documentation for a foreign key constraint\n\n\nForeign key annotation\n: machine-readable documentation for a foreign key constraint\n\n\n\n\n\n\n\n\n\n\nData resources\n\n\nEntity\n: a set of data tuples corresponding to a (possibly filtered) table\n\n\nAttribute\n: a set of data tuples corresponding to a (possibly filtered) projection of a table\n\n\nAttribute group\n: a set of data tuples corresponding to a (possibly filtered) projection of a table grouped by group keys\n\n\nAggregate\n: a data tuple summarizing a (possibly filtered) projection of a table\n\n\n\n\nRather than treating data resources as nested sub-resources of the model resources, ERMrest treats them as separate parallel resource spaces often thought of as separate APIs for model and data-level access.  The reality is that these resources have many possible semantic relationships in the form of a more general graph structure, and any attempt to normalize them into a hierarchical structure must emphasize some relationships at the detriment of others.  We group model elements hierarchically to assist in listing and to emphasize their nested lifecycle properties.  We split out data resources because they can have a more complex relationship to multiple model elements simultaneously.\n\n\nModel Annotations\n\uf0c1\n\n\nThe machine-readable annotation mechanism in ERMrest enables a three-level interpretation of datasets:\n\n\n\n\nThe tabular data itself, which can be processed by any client capable of understanding tabular data representations.\n\n\nThe relational meta-model describing the structure of the tabular data, which can be processed by or adapted for any client capable of introspecting on relational data structures.\n\n\nSemantic or presentation guidance, which can be processed by a client capable of augmenting the structural schemata with additional hints.\n\n\n\n\nAs an openly extensible, machine-readable interface, the annotations are keyed by globally unique identifiers (URIs) and contain arbitrary document content which can be understood according to rules associated with that key URI.  A client SHOULD ignore annotations stored using a key that the client does not understand.  A client MAY ignore all annotations and simply work with the underlying relational data based on its inherent structure with or without any additional contextual knowledge to guide its interpretation.\n\n\nData Resource Naming Language\n\uf0c1\n\n\nThe \ndata resources\n make use of a model-driven language for denoting sub-parts of an entity-relationship modeled dataset. The language has several main syntactic components:\n\n\n\n\nData Paths\n\n\nPath Root\n\n\nPath Filters\n\n\nEntity Links\n\n\nLinkage by Foriegn-Key Endpoint\n\n\nLinkage by Explicit Column Mapping\n\n\nOuter-Join Linkage by Column Mapping\n\n\n\n\n\n\nTable Instance Alias\n\n\nPath Context Reset\n\n\nFilter Language\n\n\nUnary Filter Predicate\n\n\nBinary Filter Predicate\n\n\nNegated Filter\n\n\nParenthetic Filter\n\n\nConjunctive Filter\n\n\nDisjunctive Filter\n\n\nConjunctive Normal Form\n\n\nDisjunctive Normal Form\n\n\nData Projection\n\n\nAttribute Projection\n\n\nAggregate Projection\n\n\nGrouped Attribute Projection\n\n\nAttribute Binning\n i.e. for histograms\n\n\nSort Modifer\n\n\nPaging Modifiers\n\n\nBefore Modifier\n\n\nAfter Modifier\n\n\nAccept Query Parameter\n\n\nDownload Query Parameter\n\n\nDefaults Query Parameter\n\n\nLimit Query Parameter\n\n\n\n\nThe sort, paging, and limit syntax together can support \npaged data access\n:\n  1. \nSimple Paging by Entity Key\n\n  1. \nPaging with Application Sort Order\n\n\nRESTful Operations Overview\n\uf0c1\n\n\nThe ERMrest interface supports typical HTTP operations to manage these different levels of resource:\n\n\n\n\nCatalog-level operations\n\n\nCatalog Creation\n\n\nCatalog Retrieval\n\n\nCatalog Deletion\n\n\nACL Retrieval\n\n\n\n\n\n\nModel-level operations\n\n\nSchemata Retrieval\n\n\nBulk Schemata and Table Creation\n\n\nSchema Creation\n\n\nSchema Retrieval\n\n\nSchema Deletion\n\n\nTable List Retrieval\n\n\nTable Creation\n\n\nTable Retrieval\n\n\nTable Deletion\n\n\nColumn List Retrieval\n\n\nColumn Creation\n\n\nColumn Retrieval\n\n\nColumn Deletion\n\n\nKey List Retrieval\n\n\nKey Creation\n\n\nKey Retrieval\n\n\nKey Deletion\n\n\nForeign Key List Retrieval\n\n\nForeign Key Creation\n\n\nForeign Key Retrieval\n\n\nForeign Key Deletion\n\n\n\n\n\n\nModel Annotations\n\n\nAnnotation List Retrieval\n\n\nAnnotation Creation\n\n\nAnnotation Bulk Update\n\n\nAnnotation Retrieval\n\n\nAnnotation Deletion\n\n\n\n\n\n\nModel Comments\n\n\nComment Creation\n\n\nComment Retrieval\n\n\nComment Deletion\n\n\n\n\n\n\nData operations\n\n\nEntity Creation\n\n\nEntity Creation with Defaults\n\n\n\n\n\n\nEntity Update\n\n\nEntity Retrieval\n\n\nEntity Delete\n\n\nAttribute Retrieval\n\n\nAttribute Delete\n\n\nAttribute Group Retrieval\n\n\nAttribute Group Update\n\n\nAttribute Group Update with Renaming\n\n\n\n\n\n\nAggregate Retrieval\n\n\n\n\nThese operations produce and/or consume representations of the resources. ERMrest defines its own JSON representations for catalog and model elements, and supports common representations of tabular data.\n\n\nHTTP Concurrency Control\n\uf0c1\n\n\nERMrest supports opportunistic concurrency control using an entity tag (\"ETag\") as per the HTTP standards to identify versions of web resources. The ETag is a version identifier that composes with a URL to fully identify a resource version. In other words, ETag strings are meaningless when separated from the resource address.\n\n\nPrecondition Processing\n\uf0c1\n\n\n\n\nA response header \nETag\n carries an ETag representing the resource version \nat the conclusion of request processing\n.\n\n\nA \nHEAD\n response with an ETag identifies the version of the resource currently present in the server.\n\n\nA \nGET\n response with an ETag identifies the version of the resource being represented in the output.\n\n\nA \nPUT\n, \nPOST\n, or \nDELETE\n response with an ETag identifies the version of the server-side resource after it was modified by the request.\n\n\nRequest headers \nIf-Match\n and \nIf-None-Match\n carry one or more ETags (or the wildcard \n*\n) specifying constraints on the resource version \nat the start of request processing\n.\n\n\nThe \nIf-Match\n header requires that the server-side resource match one of the specified ETag values in order to permit processing of the request.\n\n\nThe \nIf-None-Match\n header requires that the server-side resource \nnot\n match any of the specified ETag values in order to permit processing of the request.\n\n\nThe wildcard \n*\n in either header trivially matches any server-side resource version.\n\n\nThe combination of both headers is a logical conjunction of all constraints, meaning both headers' respective conditions must be met in order to permit processing of the request.\n\n\nHTTP methods conditionalize their behavior and response when precondition headers are present in requests.\n\n\nA \nPUT\n, \nPOST\n, or \nDELETE\n operation returns a normal \n200 OK\n or \n201 Created\n in the absence of preconditions or if preconditions are met. They return \n412 PreconditionFailed\n when preconditions are not met; in this case, the operation has no effect on server-side resource state.\n\n\nA \nGET\n operation returns a normal \n200 OK\n in the absence of preconditions or if preconditions are met. It returns \n304 Not Modified\n when preconditions are not met. This alternative status code is required by the HTTP standard due to its idiomatic use for cache-control of \nGET\n responses; the \"not modified\" status means the client can reuse a representation when an \nIf-None-Match\n header is used to specify the ETag associated with the representation previously retrieved by that client.\n\n\n\n\nAtomic Retrieval of Multiple Resources\n\uf0c1\n\n\nAn example of concurrency control is to dump a set of data values from several tables with confidence that they are transactionally consistent. ERMrest provides basic atomicity at the HTTP request level, but this is insufficient to guarantee consistency of several different requests. Instead, a client might follow this workflow:\n\n\n\n\nPlan the set of resources it needs to retrieve (e.g. a list of ERMrest URLs for schema and/or data resources).\n\n\nPre-fetch each resource using an unconditional \nGET\n request and save both the representation and corresponding ETag from the response.\n\n\nRe-probe each resource using a conditional \nGET\n request with \nIf-None-Match\n header specifying the ETag from the previous response for that URL.\n\n\nA \n304 Not Modified\n response indicates that the resource is still at the same version on the server.\n\n\nA \n200 OK\n response indicates that the server-side state has changed, so save both the representation and corresponding ETag from the response.\n\n\nRepeat step (3) until an entire cycle of visits to all resources yielded \n304 Not Modified\n, indicating that no resource changed state since their states were retrieved.\n\n\n\n\nAtomic Change of a Resource\n\uf0c1\n\n\nAnother example of concurrency control is to change a resource while ensuring that other clients' modifications are not clobbered:\n\n\n\n\nFetch a resource representation and its corresponding ETag.\n\n\nSend a revision of the data an appropriate \nPUT\n, \nPOST\n, or \nDELETE\n to the same URL including an \nIf-Match\n header with the previously retrieved ETag.\n\n\nA \n200 OK\n, \n201 Created\n, and/or \n204 No Content\n indicates that the mutation was performed safely.\n\n\nA \n412 Precondition Failed\n response indicates that someone else modified the resource since you last fetched it, so repeat the process from step (1).\n\n\n\n\nERMrest always makes an atomic change for one request, but the above workflow protects against concurrent access to the resource while the client is interpreting the first representation it retrieved, planning the mutation, and requesting that the change be applied. When an update hazard is identified by the \n412 Precondition Failed\n response, the client has avoided making an unsafe change and repeats the entire inspect, plan, execute cycle.\n\n\nAtomic Change of Multiple Resources\n\uf0c1\n\n\nThe two preceding workflows can be combined in order to determine consistent modification of multiple data or schema resources, with some caveats:\n\n\n\n\nPerform \natomic retrieval of multiple resources\n until a consistent set of \n triples are known.\n\n\nPlan a set of update operations for the same URLs.\n\n\nPerform a variant of \natomic change of a resource\n once for each URL.\n  A. Perform the mutation request immediately with an \nIf-Match\n header bearing the ETag obtained in step (1) of this bulk workflow.\n  B. Any \n200 OK\n, \n201 Created\n, and/or \n204 No Content\n response indicates that part of the update has completed. Save the update revision ETag associated with this response.\n  C. If any \n412 Precondition Failed\n response is encountered, a concurrent modification has been detected. The client should stop and analyze the situation!\n\n\n\n\nUnfortunately, a concurrent change detected in step (3.C.) above leaves the server in an inconsistent state. The client is aware that they have partially applied updates and they must now formulate a compensation action which depends on domain knowledge and more sophisticated client behaviors.  For example:\n\n\n\n\nA client might be able to restart the whole workflow, determine the new state of all resources, and reformulate or \"re-base\" its plan as a set of revised updates.\n\n\nIf a \nHEAD\n request to each resource successfully changed in step (3.B.) yield the same revision ETag that was returned in the mutation response, the client may be able to apply reverse operations to undo its changes. Whether practical reverse operations are available depends on the operation and size of affected data.\n\n\n\n\nAlternative ERMrest bulk-change APIs are under consideration to allow truly atomic change by sending a complete multi-resource request and allowing the server to process it under transaction control. Users interested in such features should contact the developers by filing an issue in our GitHub project.\n\n\nSet-based Data Resources and Representations\n\uf0c1\n\n\nERMrest presents a composite resource model for data as sets of tuples. Using different resource naming mechanisms, this allows reference to data at different granularities and levels of abstraction:\n\n\n\n\nAll entities in one table, or a filtered subset of those entities.\n\n\nA projection of attributes for all entities in one table or a filtered subset of those entities, possibly including additional attributes joined from other tables.\n\n\nA projection of attributes for all entities in one table or a filtered subset of those entities, grouped by grouping keys, possibly including additional attributes joined from other tables and possibly including computed aggregates over members of each group.\n\n\nOne entity (known by its key value).\n\n\nA projection of one entity.\n\n\nA projection of computed aggregates over all entities in one table or over a filtered subset of those entities.\n\n\n\n\nFor simplicity, ERMrest always uses data formats capable of representing a set of tuples, even if the particular named data resource is a degenerate case with set cardinality of one (single tuple) or zero (emtpy set). The currently supported MIME types for tabular data are:\n\n\n\n\napplication/json\n: a JSON array of objects where each object represents one tuple with named fields (the default representation).\n\n\ntext/csv\n: a comma-separated value table where each row represents one tuple and a header row specifies the field names.\n\n\napplication/x-json-stream\n: a stream of JSON objects, one per line, where each object represents one tuple with named fields.\n\n\n\n\nOther data formats may be supported in future revisions.\n\n\nScalar and Array Typed Attributes\n\uf0c1\n\n\nERMrest generically exposes a range of scalar and array-of-scalar attribute types, with names familiar to PostgreSQL users:\n\n\n\n\nboolean\n: Can be either \nTrue\n or \nFalse\n.\n\n\ndate\n: An ISO 8601 date such as \n2015-12-31\n.\n\n\ntimestamptz\n: An ISO 8601 timestamp with timezone such as \n2016-01-13T16:34:24-0800\n.\n\n\nfloat4\n and \nfloat8\n: Floating-point numbers in 4-byte (32-bit) or 8-byte (64-bit) precision, respectively.\n\n\nint2\n, \nint4\n, \nint8\n: Two's complement integers in 2-byte, 4-byte, or 8-byte widths, respectively.\n\n\nserial2\n, \nserial4\n, \nserial8\n: Corresponding to \nint2\n, \nint4\n, and \nint8\n with an auto-incremented default behavior on insertion.\n\n\ntext\n: Variable-length text containing Unicode characters, using UTF-8 encoding in all supported MIME types (currently CSV and JSON).\n\n\njsonb\n: JSON text strings parsed and stored in PostgreSQL's binary JSON variant.\n\n\n\n\nThe \nbinary filter predicate\n\nlanguage of ERMrest URIs compare a stored scalar column value (the\nleft-hand value) to a constant value supplied in the URI filter syntax\n(the right-hand value). In general, the core operators apply to all\nscalar types except the regular-expression matches which only apply to\n\ntext\n column type.\n\n\nArrays of Scalars\n\uf0c1\n\n\nERMrest supports columns storing arrays of the preceding scalar\ntypes. These arrays are encoded differently depending on the MIME type:\n\n\n\n\nAs native JSON array content in JSON input/output formats, e.g. \n{\"array_column_name\": [\"value1\", \"value2\"], \"scalar_column_name\": \"value3\"}\n\n\nAs PostgreSQL-formatted arrays in CSV input/output formats, e.g. \n\"{value1,value2,value3}\",value3\n\n\n\n\nThe \nbinary filter predicate\n\nlanguage of ERMrest URIs compare each scalar element in a stored array\ncolumn using \nexistential qualification\n. The array elements are used\nas left-hand values and individually compared with the constant\nright-hand value from the URI filter syntax. The predicate is\nconsidered to match if \nany\n contained array element individually\nmatches using the scalar comparison.\n\n\nA column storing an array of scalars MAY be used as a unique key or foreign key, subject to PostgreSQL native interpretation of array equality. However, it is RECOMMENDED that data modelers consider normalizing their schema to avoid such constructs.\n\n\nExperimental Types\n\uf0c1\n\n\nERMrest makes a best-effort attempt to support additional attribute\ntypes when exposing legacy database schema. These types MAY support\nvalue storage and exchange to varying degrees but support for filter\npredicates and other niceties are lacking or we discourage their use\nfor other reasons:\n\n\n\n\nuuid\n: Universally Unique Identifiers, e.g. \na0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\n.\n\n\nnumeric\n: Arbitrary-precision decimal numerical data.\n\n\ntime\n and \ntimetz\n: Time values lacking date information.\n\n\ntimestamp\n: Timestamps lacking timezone information.\n\n\njson\n: JSON text strings.\n\n\nvarious \ntext\n and \ncharacter\n types with length constraints: No\n  length constraints or padding are considered or enforced by ERMrest\n  and for the most part these map to variable-length \ntext\n storage\n  with additional constraints that MAY be enforced by PostgreSQL.\n\n\n\n\nIn a normal ERMrest configuration, these types are not supported when\ndefining new columns or tables, and only mapped from existing\ndatabases for legacy support.\n\n\nCSV Format\n\uf0c1\n\n\nERMrest supports the \ntext/csv\n MIME type for tabular input or output,\nas described in \nRFC 4180\n. If\ndeviation between the RFC and ERMrest are found, please report them as\na bug in the ERMrest issue tracker.\n\n\nRefer to the RFC for full CSV format details, but here are a few\npoints worth noting:\n\n\n\n\nEach row (record) is terminated with a carriage-return, linefeed (CRLF) byte pair.\n\n\nFields are separated by the comma (\n,\n) character. The final field MUST NOT have a trailing comma, as that would be interpreted as one more empty field before the record terminator.\n\n\nThe first row is a header with column names in each field.\n\n\nAll records MUST have the same number of fields.\n\n\nFields MAY be surrounded by the double-quotation character (\n\"\n) to allow embedding of field separators, record terminators, or whitespace.\n\n\nEven a newline or CRLF pair may appear in the quoted field.\n\n\nTo embed a literal double-quotation character in a quoted field, escape it by preceding with a second copy of the same byte, e.g. \n\"This \"\" sentence has one double-quote character in it.\"\n.\n\n\nAll whitespace between field separators is significant.\n\n\nA quoted record SHOULD NOT be preceded or followed by whitespace, e.g. \n...,\" a b \",...\n is preferred to \n..., \"a b\" ,...\n. The RFC does not allow the latter form. ERMrest MAY interpret both as equivalent but this behavior SHOULD NOT be relied upon by clients.\n\n\n\n\nNULL values\n\uf0c1\n\n\nAs a further note, ERMrest interprets quoted and unquoted empty fields distinctly:\n\n\n\n\n...,,...\n: NULL value\n\n\n...,\"\",...\n: empty string\n\n\n\n\nExample CSV Content\n\uf0c1\n\n\nIn this example, we include the literal \nCRLF\n to emphasize the record terminator that would not be visually appreciable otherwise:\n\n\nrow #,column A,column B,column C,column D\nCRLF\n\n1,a,b,c,d\nCRLF\n\n2,A,B,C,D\nCRLF\n\n3, A, B, C, D\nCRLF\n\n4, A , B , C , D \nCRLF\n\n5,\" A \",\" B \",\" C \",\" D \"\nCRLF\n\n6,\" \"\"A\"\" \",\" \"\"B\"\" \",\" \"\"C\"\" \",\" \"\"D\"\" \"\nCRLF\n\n7,\"A\nCRLF\n\nA\",\"B\nCRLF\n\nB\",\"C\nCRLF\n\nC\",\"D\nCRLF\n\nD\"\nCRLF\n\n8,,,,\nCRLF\n\n9,\"\",\"\",\"\",\"\"\nCRLF\n\n\n\n\nThe preceding example has nine total rows with a column containing an\nexplicit row number \n1\n through \n9\n and four addition columns named\n\ncolumn A\n through \ncolumn D\n with the following values encoded in the\nCSV records:\n\n\n\n\nFour literals \na\n through \nd\n\n\nFour literals \nA\n through \nD\n\n\nFour literals \nA\n through \nD\n, i.e. alphabetic character preceded by space character.\n\n\nFour literals \nA\n through \nD\n, i.e. alphabetic character surrounded by space characters on both sides.\n\n\nSame literals as row (4).\n\n\nFour literals \n\"A\"\n through \n\"D\"\n, i.e. alphabetic character surrounded by quotes and then surrounded by space characters on both sides.\n\n\nFour literals \nA\nCRLF\nA\n through \nD\nCRLF\nD\n, i.e. one carriage-return linefeed pair surrounded by alphabetic characters on both sides.\n\n\nFour NULL values.\n\n\nFour literal empty strings.", 
            "title": "Guide to the ERMrest API"
        }, 
        {
            "location": "/api-docs/#ermrest-api", 
            "text": "ERMrest  (rhymes with \"earn rest\") is a general relational data storage service for web-based, data-oriented collaboration.  See the  ERMrest overview  for a general description and motivation.  This technical document specifies the web service protocol in terms of resources, resource representations, resource naming, and operations.", 
            "title": "ERMrest API"
        }, 
        {
            "location": "/api-docs/#url-conventions", 
            "text": "Any ERMrest URL is a valid HTTP URL and contains user-generated content which may need to be escaped. Several reserved characters from RFC 3986 are used as meta-syntax in ERMrest and MUST be escaped if they are meant to be part of a user-generated identifiers or literal data and MUST NOT be escaped if they are meant to indicate the ERMrest meta-syntax:   The  /  or forward-slash, used as a path separator character  The  :  or colon, used as a separator and in multi-character tokens  The  ;  or semi-colon, used as a separator  The  ,  or comma, used as a separator  The  =  or equals sign, used as an operator and as part of multi-character tokens  The  ?  or question-mark, used to separate a resource name from query-parameters  The   or ampersand, used as a separator  The  (  and  )  parentheses, used for nested grouping  TODO: more syntax to list here   All other reserved characters should be escaped in user-generated content in URLs, but have no special meaning to ERMrest when appearing in unescaped form.", 
            "title": "URL Conventions"
        }, 
        {
            "location": "/api-docs/#resource-and-service-model", 
            "text": "At its core, ERMrest is a multi-tenant service that can host multiple datasets, each with its own entity-relationship model.  The dataset, model, and data are further decomposed into web resources to allow collaborative management and interaction with the data store.  Graph of Web Resources \uf0c1  The ERMrest web service model exposes resources to support management of datasets, the entity-relationship model, and the actual data stored using that model:   Service: the entire multi-tenant service end-point  Catalog : a particular dataset (in one service)  Schema or model resources  Schemata : entire data model of a dataset (in one catalog)  Schema : a particular named subset of a dataset (in one catalog)  Schema comment : human-readable documentation for a schema  Schema annotation : machine-readable documentation for a schema  Table definition : a particular named set of data tuples (in one schema)  Table comment : human-readable documentation for a table  Table annotation : machine-readable documentation for a table  Column definition : a particular named field of data tuples (in one table)  Column comment : human-readable documentation for a column  Column annotation : machine-readable documentation for a column    Key definition : a composite key constraint (in one table)  Key comment : human-readable documentation for a key constraint  Key annotation : machine-readable documentation for a key constraint    Foreign key definition : a composite foreign key constraint (in one table)  Foreign key comment : human-readable documentation for a foreign key constraint  Foreign key annotation : machine-readable documentation for a foreign key constraint      Data resources  Entity : a set of data tuples corresponding to a (possibly filtered) table  Attribute : a set of data tuples corresponding to a (possibly filtered) projection of a table  Attribute group : a set of data tuples corresponding to a (possibly filtered) projection of a table grouped by group keys  Aggregate : a data tuple summarizing a (possibly filtered) projection of a table   Rather than treating data resources as nested sub-resources of the model resources, ERMrest treats them as separate parallel resource spaces often thought of as separate APIs for model and data-level access.  The reality is that these resources have many possible semantic relationships in the form of a more general graph structure, and any attempt to normalize them into a hierarchical structure must emphasize some relationships at the detriment of others.  We group model elements hierarchically to assist in listing and to emphasize their nested lifecycle properties.  We split out data resources because they can have a more complex relationship to multiple model elements simultaneously.  Model Annotations \uf0c1  The machine-readable annotation mechanism in ERMrest enables a three-level interpretation of datasets:   The tabular data itself, which can be processed by any client capable of understanding tabular data representations.  The relational meta-model describing the structure of the tabular data, which can be processed by or adapted for any client capable of introspecting on relational data structures.  Semantic or presentation guidance, which can be processed by a client capable of augmenting the structural schemata with additional hints.   As an openly extensible, machine-readable interface, the annotations are keyed by globally unique identifiers (URIs) and contain arbitrary document content which can be understood according to rules associated with that key URI.  A client SHOULD ignore annotations stored using a key that the client does not understand.  A client MAY ignore all annotations and simply work with the underlying relational data based on its inherent structure with or without any additional contextual knowledge to guide its interpretation.  Data Resource Naming Language \uf0c1  The  data resources  make use of a model-driven language for denoting sub-parts of an entity-relationship modeled dataset. The language has several main syntactic components:   Data Paths  Path Root  Path Filters  Entity Links  Linkage by Foriegn-Key Endpoint  Linkage by Explicit Column Mapping  Outer-Join Linkage by Column Mapping    Table Instance Alias  Path Context Reset  Filter Language  Unary Filter Predicate  Binary Filter Predicate  Negated Filter  Parenthetic Filter  Conjunctive Filter  Disjunctive Filter  Conjunctive Normal Form  Disjunctive Normal Form  Data Projection  Attribute Projection  Aggregate Projection  Grouped Attribute Projection  Attribute Binning  i.e. for histograms  Sort Modifer  Paging Modifiers  Before Modifier  After Modifier  Accept Query Parameter  Download Query Parameter  Defaults Query Parameter  Limit Query Parameter   The sort, paging, and limit syntax together can support  paged data access :\n  1.  Simple Paging by Entity Key \n  1.  Paging with Application Sort Order  RESTful Operations Overview \uf0c1  The ERMrest interface supports typical HTTP operations to manage these different levels of resource:   Catalog-level operations  Catalog Creation  Catalog Retrieval  Catalog Deletion  ACL Retrieval    Model-level operations  Schemata Retrieval  Bulk Schemata and Table Creation  Schema Creation  Schema Retrieval  Schema Deletion  Table List Retrieval  Table Creation  Table Retrieval  Table Deletion  Column List Retrieval  Column Creation  Column Retrieval  Column Deletion  Key List Retrieval  Key Creation  Key Retrieval  Key Deletion  Foreign Key List Retrieval  Foreign Key Creation  Foreign Key Retrieval  Foreign Key Deletion    Model Annotations  Annotation List Retrieval  Annotation Creation  Annotation Bulk Update  Annotation Retrieval  Annotation Deletion    Model Comments  Comment Creation  Comment Retrieval  Comment Deletion    Data operations  Entity Creation  Entity Creation with Defaults    Entity Update  Entity Retrieval  Entity Delete  Attribute Retrieval  Attribute Delete  Attribute Group Retrieval  Attribute Group Update  Attribute Group Update with Renaming    Aggregate Retrieval   These operations produce and/or consume representations of the resources. ERMrest defines its own JSON representations for catalog and model elements, and supports common representations of tabular data.  HTTP Concurrency Control \uf0c1  ERMrest supports opportunistic concurrency control using an entity tag (\"ETag\") as per the HTTP standards to identify versions of web resources. The ETag is a version identifier that composes with a URL to fully identify a resource version. In other words, ETag strings are meaningless when separated from the resource address.  Precondition Processing \uf0c1   A response header  ETag  carries an ETag representing the resource version  at the conclusion of request processing .  A  HEAD  response with an ETag identifies the version of the resource currently present in the server.  A  GET  response with an ETag identifies the version of the resource being represented in the output.  A  PUT ,  POST , or  DELETE  response with an ETag identifies the version of the server-side resource after it was modified by the request.  Request headers  If-Match  and  If-None-Match  carry one or more ETags (or the wildcard  * ) specifying constraints on the resource version  at the start of request processing .  The  If-Match  header requires that the server-side resource match one of the specified ETag values in order to permit processing of the request.  The  If-None-Match  header requires that the server-side resource  not  match any of the specified ETag values in order to permit processing of the request.  The wildcard  *  in either header trivially matches any server-side resource version.  The combination of both headers is a logical conjunction of all constraints, meaning both headers' respective conditions must be met in order to permit processing of the request.  HTTP methods conditionalize their behavior and response when precondition headers are present in requests.  A  PUT ,  POST , or  DELETE  operation returns a normal  200 OK  or  201 Created  in the absence of preconditions or if preconditions are met. They return  412 PreconditionFailed  when preconditions are not met; in this case, the operation has no effect on server-side resource state.  A  GET  operation returns a normal  200 OK  in the absence of preconditions or if preconditions are met. It returns  304 Not Modified  when preconditions are not met. This alternative status code is required by the HTTP standard due to its idiomatic use for cache-control of  GET  responses; the \"not modified\" status means the client can reuse a representation when an  If-None-Match  header is used to specify the ETag associated with the representation previously retrieved by that client.   Atomic Retrieval of Multiple Resources \uf0c1  An example of concurrency control is to dump a set of data values from several tables with confidence that they are transactionally consistent. ERMrest provides basic atomicity at the HTTP request level, but this is insufficient to guarantee consistency of several different requests. Instead, a client might follow this workflow:   Plan the set of resources it needs to retrieve (e.g. a list of ERMrest URLs for schema and/or data resources).  Pre-fetch each resource using an unconditional  GET  request and save both the representation and corresponding ETag from the response.  Re-probe each resource using a conditional  GET  request with  If-None-Match  header specifying the ETag from the previous response for that URL.  A  304 Not Modified  response indicates that the resource is still at the same version on the server.  A  200 OK  response indicates that the server-side state has changed, so save both the representation and corresponding ETag from the response.  Repeat step (3) until an entire cycle of visits to all resources yielded  304 Not Modified , indicating that no resource changed state since their states were retrieved.   Atomic Change of a Resource \uf0c1  Another example of concurrency control is to change a resource while ensuring that other clients' modifications are not clobbered:   Fetch a resource representation and its corresponding ETag.  Send a revision of the data an appropriate  PUT ,  POST , or  DELETE  to the same URL including an  If-Match  header with the previously retrieved ETag.  A  200 OK ,  201 Created , and/or  204 No Content  indicates that the mutation was performed safely.  A  412 Precondition Failed  response indicates that someone else modified the resource since you last fetched it, so repeat the process from step (1).   ERMrest always makes an atomic change for one request, but the above workflow protects against concurrent access to the resource while the client is interpreting the first representation it retrieved, planning the mutation, and requesting that the change be applied. When an update hazard is identified by the  412 Precondition Failed  response, the client has avoided making an unsafe change and repeats the entire inspect, plan, execute cycle.  Atomic Change of Multiple Resources \uf0c1  The two preceding workflows can be combined in order to determine consistent modification of multiple data or schema resources, with some caveats:   Perform  atomic retrieval of multiple resources  until a consistent set of   triples are known.  Plan a set of update operations for the same URLs.  Perform a variant of  atomic change of a resource  once for each URL.\n  A. Perform the mutation request immediately with an  If-Match  header bearing the ETag obtained in step (1) of this bulk workflow.\n  B. Any  200 OK ,  201 Created , and/or  204 No Content  response indicates that part of the update has completed. Save the update revision ETag associated with this response.\n  C. If any  412 Precondition Failed  response is encountered, a concurrent modification has been detected. The client should stop and analyze the situation!   Unfortunately, a concurrent change detected in step (3.C.) above leaves the server in an inconsistent state. The client is aware that they have partially applied updates and they must now formulate a compensation action which depends on domain knowledge and more sophisticated client behaviors.  For example:   A client might be able to restart the whole workflow, determine the new state of all resources, and reformulate or \"re-base\" its plan as a set of revised updates.  If a  HEAD  request to each resource successfully changed in step (3.B.) yield the same revision ETag that was returned in the mutation response, the client may be able to apply reverse operations to undo its changes. Whether practical reverse operations are available depends on the operation and size of affected data.   Alternative ERMrest bulk-change APIs are under consideration to allow truly atomic change by sending a complete multi-resource request and allowing the server to process it under transaction control. Users interested in such features should contact the developers by filing an issue in our GitHub project.  Set-based Data Resources and Representations \uf0c1  ERMrest presents a composite resource model for data as sets of tuples. Using different resource naming mechanisms, this allows reference to data at different granularities and levels of abstraction:   All entities in one table, or a filtered subset of those entities.  A projection of attributes for all entities in one table or a filtered subset of those entities, possibly including additional attributes joined from other tables.  A projection of attributes for all entities in one table or a filtered subset of those entities, grouped by grouping keys, possibly including additional attributes joined from other tables and possibly including computed aggregates over members of each group.  One entity (known by its key value).  A projection of one entity.  A projection of computed aggregates over all entities in one table or over a filtered subset of those entities.   For simplicity, ERMrest always uses data formats capable of representing a set of tuples, even if the particular named data resource is a degenerate case with set cardinality of one (single tuple) or zero (emtpy set). The currently supported MIME types for tabular data are:   application/json : a JSON array of objects where each object represents one tuple with named fields (the default representation).  text/csv : a comma-separated value table where each row represents one tuple and a header row specifies the field names.  application/x-json-stream : a stream of JSON objects, one per line, where each object represents one tuple with named fields.   Other data formats may be supported in future revisions.  Scalar and Array Typed Attributes \uf0c1  ERMrest generically exposes a range of scalar and array-of-scalar attribute types, with names familiar to PostgreSQL users:   boolean : Can be either  True  or  False .  date : An ISO 8601 date such as  2015-12-31 .  timestamptz : An ISO 8601 timestamp with timezone such as  2016-01-13T16:34:24-0800 .  float4  and  float8 : Floating-point numbers in 4-byte (32-bit) or 8-byte (64-bit) precision, respectively.  int2 ,  int4 ,  int8 : Two's complement integers in 2-byte, 4-byte, or 8-byte widths, respectively.  serial2 ,  serial4 ,  serial8 : Corresponding to  int2 ,  int4 , and  int8  with an auto-incremented default behavior on insertion.  text : Variable-length text containing Unicode characters, using UTF-8 encoding in all supported MIME types (currently CSV and JSON).  jsonb : JSON text strings parsed and stored in PostgreSQL's binary JSON variant.   The  binary filter predicate \nlanguage of ERMrest URIs compare a stored scalar column value (the\nleft-hand value) to a constant value supplied in the URI filter syntax\n(the right-hand value). In general, the core operators apply to all\nscalar types except the regular-expression matches which only apply to text  column type.  Arrays of Scalars \uf0c1  ERMrest supports columns storing arrays of the preceding scalar\ntypes. These arrays are encoded differently depending on the MIME type:   As native JSON array content in JSON input/output formats, e.g.  {\"array_column_name\": [\"value1\", \"value2\"], \"scalar_column_name\": \"value3\"}  As PostgreSQL-formatted arrays in CSV input/output formats, e.g.  \"{value1,value2,value3}\",value3   The  binary filter predicate \nlanguage of ERMrest URIs compare each scalar element in a stored array\ncolumn using  existential qualification . The array elements are used\nas left-hand values and individually compared with the constant\nright-hand value from the URI filter syntax. The predicate is\nconsidered to match if  any  contained array element individually\nmatches using the scalar comparison.  A column storing an array of scalars MAY be used as a unique key or foreign key, subject to PostgreSQL native interpretation of array equality. However, it is RECOMMENDED that data modelers consider normalizing their schema to avoid such constructs.  Experimental Types \uf0c1  ERMrest makes a best-effort attempt to support additional attribute\ntypes when exposing legacy database schema. These types MAY support\nvalue storage and exchange to varying degrees but support for filter\npredicates and other niceties are lacking or we discourage their use\nfor other reasons:   uuid : Universally Unique Identifiers, e.g.  a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11 .  numeric : Arbitrary-precision decimal numerical data.  time  and  timetz : Time values lacking date information.  timestamp : Timestamps lacking timezone information.  json : JSON text strings.  various  text  and  character  types with length constraints: No\n  length constraints or padding are considered or enforced by ERMrest\n  and for the most part these map to variable-length  text  storage\n  with additional constraints that MAY be enforced by PostgreSQL.   In a normal ERMrest configuration, these types are not supported when\ndefining new columns or tables, and only mapped from existing\ndatabases for legacy support.  CSV Format \uf0c1  ERMrest supports the  text/csv  MIME type for tabular input or output,\nas described in  RFC 4180 . If\ndeviation between the RFC and ERMrest are found, please report them as\na bug in the ERMrest issue tracker.  Refer to the RFC for full CSV format details, but here are a few\npoints worth noting:   Each row (record) is terminated with a carriage-return, linefeed (CRLF) byte pair.  Fields are separated by the comma ( , ) character. The final field MUST NOT have a trailing comma, as that would be interpreted as one more empty field before the record terminator.  The first row is a header with column names in each field.  All records MUST have the same number of fields.  Fields MAY be surrounded by the double-quotation character ( \" ) to allow embedding of field separators, record terminators, or whitespace.  Even a newline or CRLF pair may appear in the quoted field.  To embed a literal double-quotation character in a quoted field, escape it by preceding with a second copy of the same byte, e.g.  \"This \"\" sentence has one double-quote character in it.\" .  All whitespace between field separators is significant.  A quoted record SHOULD NOT be preceded or followed by whitespace, e.g.  ...,\" a b \",...  is preferred to  ..., \"a b\" ,... . The RFC does not allow the latter form. ERMrest MAY interpret both as equivalent but this behavior SHOULD NOT be relied upon by clients.   NULL values \uf0c1  As a further note, ERMrest interprets quoted and unquoted empty fields distinctly:   ...,,... : NULL value  ...,\"\",... : empty string   Example CSV Content \uf0c1  In this example, we include the literal  CRLF  to emphasize the record terminator that would not be visually appreciable otherwise:  row #,column A,column B,column C,column D CRLF \n1,a,b,c,d CRLF \n2,A,B,C,D CRLF \n3, A, B, C, D CRLF \n4, A , B , C , D  CRLF \n5,\" A \",\" B \",\" C \",\" D \" CRLF \n6,\" \"\"A\"\" \",\" \"\"B\"\" \",\" \"\"C\"\" \",\" \"\"D\"\" \" CRLF \n7,\"A CRLF \nA\",\"B CRLF \nB\",\"C CRLF \nC\",\"D CRLF \nD\" CRLF \n8,,,, CRLF \n9,\"\",\"\",\"\",\"\" CRLF   The preceding example has nine total rows with a column containing an\nexplicit row number  1  through  9  and four addition columns named column A  through  column D  with the following values encoded in the\nCSV records:   Four literals  a  through  d  Four literals  A  through  D  Four literals  A  through  D , i.e. alphabetic character preceded by space character.  Four literals  A  through  D , i.e. alphabetic character surrounded by space characters on both sides.  Same literals as row (4).  Four literals  \"A\"  through  \"D\" , i.e. alphabetic character surrounded by quotes and then surrounded by space characters on both sides.  Four literals  A CRLF A  through  D CRLF D , i.e. one carriage-return linefeed pair surrounded by alphabetic characters on both sides.  Four NULL values.  Four literal empty strings.", 
            "title": "Resource and Service Model"
        }, 
        {
            "location": "/api-docs/model/naming/", 
            "text": "ERMrest Model Resource Naming\n\uf0c1\n\n\nUnlike general web architecture, \nERMrest\n expects clients to understand the URL internal structure and permits (or even encourages) reflection on URL content to understand how one resource name relates to another. To support introspection and management, the data model of a catalog is exposed as a set of model-level resources. These model elements also influence the \nnaming of data resources\n.\n\n\nCatalog Names\n\uf0c1\n\n\nThe ERMrest model resources belong to a catalog resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n\n\n\n\nwhere the components of this root path are:\n\n\n\n\nservice\n: the ERMrest service endpoint such as \nhttps://www.example.com/ermrest\n.\n\n\ncid\n: the catalog identifier for one dataset such as \n42\n.\n\n\n\n\nThe catalog resource has a representation which provides basic information about it including access control lists.\n\n\nCatalog Annotations\n\uf0c1\n\n\nEach catalog annotation is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/annotation/\n \nannotation key\n\n\n\n\nThis keyed annotation has a simple representation which is a machine-readable document in \napplication/json\n format. The expected content and interpretation of the JSON document is externally defined and associated with the \nannotation key\n which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the \nannotation key\n is to allow different user communities to organize their own annotation standards without ambiguity.\n\n\nAdditionally, a composite resource summarizes all existing annotations on one catalog for convenient discovery and bulk retrieval:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/annotation\n\n\nservice\n \n/catalog/\n \ncid\n \n/annotation/\n\n\n\n\nSchemata Names\n\uf0c1\n\n\nThe ERMrest model resources are named under a root collection of schemata for a particular catalog:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n\n\n\n\nwhere the components of this root path are:\n\n\n\n\nservice\n: the ERMrest service endpoint such as \nhttps://www.example.com/ermrest\n.\n\n\ncid\n: the catalog identifier for one dataset such as \n42\n.\n\n\n\n\nThis root schemata resource has a representation which summarizes the entire data model of the catalog as a single document.\n\n\nSchema Names\n\uf0c1\n\n\nEach schema or namespace of tables in a particular catalog is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n\n\n\n\nThis named schema resource has a representation which summarizes the data model of all tables qualified by the \nschema name\n namespace.\n\n\nSchema Comments\n\uf0c1\n\n\nEach schema comment is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/comment\n\n\n\n\nThis named resource has a simple representation which is just human readable text in \ntext/plain\n format.\n\n\nSchema Annotations\n\uf0c1\n\n\nEach schema annotation is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/annotation/\n \nannotation key\n\n\n\n\nThis keyed annotation has a simple representation which is a machine-readable document in \napplication/json\n format. The expected content and interpretation of the JSON document is externally defined and associated with the \nannotation key\n which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the \nannotation key\n is to allow different user communities to organize their own annotation standards without ambiguity.\n\n\nAdditionally, a composite resource summarizes all existing annotations on one schema for convenient discovery and bulk retrieval:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/annotation\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/annotation/\n\n\n\n\nTable Names\n\uf0c1\n\n\nEach table is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n\n\n\n\nThis named table resource has a representation which summarizes its data model including columns, keys, and foreign keys. Within data resource names, a table may be referenced by \ntable name\n only if that name is unique within the catalog or by a fully qualified \nschema name\n \n:\n \ntable name\n. Concrete examples of such names might be \ntable1\n or \nschema1:table1\n.\n\n\nTable Comments\n\uf0c1\n\n\nEach table comment is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/comment\n\n\n\n\nThis named resource has a simple representation which is just human readable text in \ntext/plain\n format.\n\n\nTable Annotations\n\uf0c1\n\n\nEach table annotation is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/annotation/\n \nannotation key\n\n\n\n\nThis keyed annotation has a simple representation which is a machine-readable document in \napplication/json\n format. The expected content and interpretation of the JSON document is externally defined and associated with the \nannotation key\n which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the \nannotation key\n is to allow different user communities to organize their own annotation standards without ambiguity.\n\n\nAdditionally, a composite resource summarizes all existing annotations on one table for convenient discovery and bulk retrieval:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/annotation\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/annotation/\n\n\n\n\nColumn Names\n\uf0c1\n\n\nEach column is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n\n\n\n\nThis named column resource has a representation which summarizes its data model including name and type. Within data resource names, a column may be referenced by:\n\n\n\n\ncolumn name\n when resolving within an implicit table context;\n\n\ntable alias\n : \ncolumn name\n when resolving against a context where \ntable alias\n has been bound as an alias to a specific table instance;\n\n\ntable name\n : \ncolumn name\n when resolving against the model and \ntable name\n is unique within the catalog;\n\n\nschema name\n : \ntable name\n : \ncolumn name\n when resolving against the model and \ntable name\n might otherwise be ambiguous.\n\n\n\n\nColumn Comments\n\uf0c1\n\n\nEach column comment is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n/comment\n\n\n\n\nThis named resource has a simple representation which is just human readable text in \ntext/plain\n format.\n\n\nColumn Annotations\n\uf0c1\n\n\nEach column annotation is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n/annotation/\n \nannotation key\n\n\n\n\nThis keyed annotation has a simple representation which is a machine-readable document in \napplication/json\n format. The expected content and interpretation of the JSON document is externally defined and associated with the \nannotation key\n which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the \nannotation key\n is to allow different user communities to organize their own annotation standards without ambiguity.\n\n\nAdditionally, a composite resource summarizes all existing annotations on one column for convenient discovery and bulk retrieval:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n/annotation\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n/annotation/\n\n\n\n\nKey Names\n\uf0c1\n\n\nEach (composite) key constraint is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ...\n\n\n\n\nThis named constraint has a representation which summarizes its set of constituent key columns. The meaning of a key constraint is that the combination of listed columns must be a unique identifier for rows in the table, i.e. no two rows can share the same combination of values for those columns.\n\n\nERMrest also supports pseudo-keys on views, which allow the uniqueness properties of views to be asserted both for clients introspecting the catalog model and for ERMrest itself to reason about queries on the view. Psuedo-keys are chosen automatically when an authorized client creates a key constraint on a view, while real database constraints are used when the client creates a key constraint on a table.\n\n\n\n\nNOTE\n pseudo-keys are advisory, \nnot enforced\n in the database, and \nnot validated\n by ERMrest. A client SHOULD NOT assert inaccurate psuedo-key constraints as it could mislead other clients who introspect the schema or lead to unexpected query results as ERMrest formulates relational queries assuming the constraints are true.\n\n\nFuture ERMrest releases MAY enforce validation on psuedo-keys so clients SHOULD NOT depend on the ability to create inaccurate psuedo-constraints.\n\n\n\n\nAdditionally, a composite resource summarizes all existing key constraints on one table for convenient discovery and bulk retrieval:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n\n\n\n\nKey Comments\n\uf0c1\n\n\nEach key comment is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ... \n/comment\n\n\n\n\nThis named resource has a simple representation which is just human readable text in \ntext/plain\n format.\n\n\nKey Annotations\n\uf0c1\n\n\nEach key annotation is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ... \n/annotation/\n \nannotation key\n\n\n\n\nThis keyed annotation has a simple representation which is a machine-readable document in \napplication/json\n format. The expected content and interpretation of the JSON document is externally defined and associated with the \nannotation key\n which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the \nannotation key\n is to allow different user communities to organize their own annotation standards without ambiguity.\n\n\nAdditionally, a composite resource summarizes all existing annotations on one key for convenient discovery and bulk retrieval:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ... \n/annotation\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ... \n/annotation/\n\n\n\n\nForeign Key Names\n\uf0c1\n\n\nEach (composite) foreign key constraint is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ...\n\n\n\n\nThis named constraint has a representation which summarizes its set of constituent foreign key columns, another referenced table, and the set of key columns that form the composite key being referenced in that other table, including the mapping of each foreign key \ncolumn name\n to each composite key \nkey column\n. The \ntable reference\n can be a qualified table name, e.g. \nschema1:table1\n or an unqualified table name, e.g. \ntable1\n.  The meaning of this constraint is that each combination of non-NULL values in \nschema name\n:\ntable name\n MUST reference an existing combination of values forming a composite key for a row in \ntable reference\n.\n\n\nERMrest also supports pseudo-foreign keys on views, which allow the reference links of views to be asserted both for clients introspecting the catalog model and for ERMrest itself to reason about queries on the view. Psuedo-foreign keys are chosen automatically when an authorized client creates a foreign key constraint on a view or referencing a view, while real database constraints are used when the client creates a foreign key constraint on a table referencing another table.\n\n\n\n\nNOTE\n pseudo-foreign keys are advisory, \nnot enforced\n in the database, and \nnot validated\n by ERMrest. A client SHOULD NOT assert inaccurate psuedo-foreign key constraints as it could mislead other clients who introspect the schema or lead to unexpected query results as ERMrest formulates relational queries assuming the constraints are true.\n\n\nFuture ERMrest releases MAY enforce validation on psuedo-foreign keys so clients SHOULD NOT depend on the ability to create inaccurate psuedo-constraints.\n\n\n\n\nAdditionally, a composite resource summarizes all foreign key constraints on one table for discovery and bulk retrieval purposes:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n\n\n\n\nAdditionally, a composite resource summarizes all foreign key constraints involving one composite foreign key \ncolumn name\n list:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ...\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n\n\n\n\nFinally, a composite resource summarizes all foreign key constraints involving one composite foreign key \ncolumn name\n list and one \ntable reference\n:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n\n\n\n\n(While highly unusual, it is possible to express more than one foreign key constraint from the same composite foreign key \ncolumn name\n list to different composite key \nkey column\n lists in the same or different \ntable reference\n tables.)\n\n\nForeign Key Comments\n\uf0c1\n\n\nEach foreign-key comment is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ... \n/comment\n\n\n\n\nThis named resource has a simple representation which is just human readable text in \ntext/plain\n format.\n\n\nForeign Key Annotations\n\uf0c1\n\n\nEach foreign-key annotation is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ... \n/annotation/\n \nannotation key\n\n\n\n\nThis keyed annotation has a simple representation which is a machine-readable document in \napplication/json\n format. The expected content and interpretation of the JSON document is externally defined and associated with the \nannotation key\n which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the \nannotation key\n is to allow different user communities to organize their own annotation standards without ambiguity.\n\n\nAdditionally, a composite resource summarizes all existing annotations on one foreign-key for convenient discovery and bulk retrieval:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ... \n/annotation\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ... \n/annotation/", 
            "title": "ERMrest Model Resource Naming"
        }, 
        {
            "location": "/api-docs/model/naming/#ermrest-model-resource-naming", 
            "text": "Unlike general web architecture,  ERMrest  expects clients to understand the URL internal structure and permits (or even encourages) reflection on URL content to understand how one resource name relates to another. To support introspection and management, the data model of a catalog is exposed as a set of model-level resources. These model elements also influence the  naming of data resources .", 
            "title": "ERMrest Model Resource Naming"
        }, 
        {
            "location": "/api-docs/model/naming/#catalog-names", 
            "text": "The ERMrest model resources belong to a catalog resource:   service   /catalog/   cid   where the components of this root path are:   service : the ERMrest service endpoint such as  https://www.example.com/ermrest .  cid : the catalog identifier for one dataset such as  42 .   The catalog resource has a representation which provides basic information about it including access control lists.  Catalog Annotations \uf0c1  Each catalog annotation is reified as a model-level resource:   service   /catalog/   cid   /annotation/   annotation key   This keyed annotation has a simple representation which is a machine-readable document in  application/json  format. The expected content and interpretation of the JSON document is externally defined and associated with the  annotation key  which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the  annotation key  is to allow different user communities to organize their own annotation standards without ambiguity.  Additionally, a composite resource summarizes all existing annotations on one catalog for convenient discovery and bulk retrieval:   service   /catalog/   cid   /annotation  service   /catalog/   cid   /annotation/", 
            "title": "Catalog Names"
        }, 
        {
            "location": "/api-docs/model/naming/#schemata-names", 
            "text": "The ERMrest model resources are named under a root collection of schemata for a particular catalog:   service   /catalog/   cid   /schema/   where the components of this root path are:   service : the ERMrest service endpoint such as  https://www.example.com/ermrest .  cid : the catalog identifier for one dataset such as  42 .   This root schemata resource has a representation which summarizes the entire data model of the catalog as a single document.", 
            "title": "Schemata Names"
        }, 
        {
            "location": "/api-docs/model/naming/#schema-names", 
            "text": "Each schema or namespace of tables in a particular catalog is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   This named schema resource has a representation which summarizes the data model of all tables qualified by the  schema name  namespace.  Schema Comments \uf0c1  Each schema comment is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /comment   This named resource has a simple representation which is just human readable text in  text/plain  format.  Schema Annotations \uf0c1  Each schema annotation is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /annotation/   annotation key   This keyed annotation has a simple representation which is a machine-readable document in  application/json  format. The expected content and interpretation of the JSON document is externally defined and associated with the  annotation key  which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the  annotation key  is to allow different user communities to organize their own annotation standards without ambiguity.  Additionally, a composite resource summarizes all existing annotations on one schema for convenient discovery and bulk retrieval:   service   /catalog/   cid   /schema/   schema name   /annotation  service   /catalog/   cid   /schema/   schema name   /annotation/", 
            "title": "Schema Names"
        }, 
        {
            "location": "/api-docs/model/naming/#table-names", 
            "text": "Each table is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   This named table resource has a representation which summarizes its data model including columns, keys, and foreign keys. Within data resource names, a table may be referenced by  table name  only if that name is unique within the catalog or by a fully qualified  schema name   :   table name . Concrete examples of such names might be  table1  or  schema1:table1 .  Table Comments \uf0c1  Each table comment is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /comment   This named resource has a simple representation which is just human readable text in  text/plain  format.  Table Annotations \uf0c1  Each table annotation is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /annotation/   annotation key   This keyed annotation has a simple representation which is a machine-readable document in  application/json  format. The expected content and interpretation of the JSON document is externally defined and associated with the  annotation key  which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the  annotation key  is to allow different user communities to organize their own annotation standards without ambiguity.  Additionally, a composite resource summarizes all existing annotations on one table for convenient discovery and bulk retrieval:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /annotation  service   /catalog/   cid   /schema/   schema name   /table/   table name   /annotation/   Column Names \uf0c1  Each column is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   column name   This named column resource has a representation which summarizes its data model including name and type. Within data resource names, a column may be referenced by:   column name  when resolving within an implicit table context;  table alias  :  column name  when resolving against a context where  table alias  has been bound as an alias to a specific table instance;  table name  :  column name  when resolving against the model and  table name  is unique within the catalog;  schema name  :  table name  :  column name  when resolving against the model and  table name  might otherwise be ambiguous.   Column Comments \uf0c1  Each column comment is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   column name   /comment   This named resource has a simple representation which is just human readable text in  text/plain  format.  Column Annotations \uf0c1  Each column annotation is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   column name   /annotation/   annotation key   This keyed annotation has a simple representation which is a machine-readable document in  application/json  format. The expected content and interpretation of the JSON document is externally defined and associated with the  annotation key  which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the  annotation key  is to allow different user communities to organize their own annotation standards without ambiguity.  Additionally, a composite resource summarizes all existing annotations on one column for convenient discovery and bulk retrieval:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   column name   /annotation  service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   column name   /annotation/   Key Names \uf0c1  Each (composite) key constraint is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   column name   ,  ...   This named constraint has a representation which summarizes its set of constituent key columns. The meaning of a key constraint is that the combination of listed columns must be a unique identifier for rows in the table, i.e. no two rows can share the same combination of values for those columns.  ERMrest also supports pseudo-keys on views, which allow the uniqueness properties of views to be asserted both for clients introspecting the catalog model and for ERMrest itself to reason about queries on the view. Psuedo-keys are chosen automatically when an authorized client creates a key constraint on a view, while real database constraints are used when the client creates a key constraint on a table.   NOTE  pseudo-keys are advisory,  not enforced  in the database, and  not validated  by ERMrest. A client SHOULD NOT assert inaccurate psuedo-key constraints as it could mislead other clients who introspect the schema or lead to unexpected query results as ERMrest formulates relational queries assuming the constraints are true.  Future ERMrest releases MAY enforce validation on psuedo-keys so clients SHOULD NOT depend on the ability to create inaccurate psuedo-constraints.   Additionally, a composite resource summarizes all existing key constraints on one table for convenient discovery and bulk retrieval:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key  service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   Key Comments \uf0c1  Each key comment is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   column name   ,  ...  /comment   This named resource has a simple representation which is just human readable text in  text/plain  format.  Key Annotations \uf0c1  Each key annotation is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   column name   ,  ...  /annotation/   annotation key   This keyed annotation has a simple representation which is a machine-readable document in  application/json  format. The expected content and interpretation of the JSON document is externally defined and associated with the  annotation key  which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the  annotation key  is to allow different user communities to organize their own annotation standards without ambiguity.  Additionally, a composite resource summarizes all existing annotations on one key for convenient discovery and bulk retrieval:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   column name   ,  ...  /annotation  service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   column name   ,  ...  /annotation/   Foreign Key Names \uf0c1  Each (composite) foreign key constraint is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...   This named constraint has a representation which summarizes its set of constituent foreign key columns, another referenced table, and the set of key columns that form the composite key being referenced in that other table, including the mapping of each foreign key  column name  to each composite key  key column . The  table reference  can be a qualified table name, e.g.  schema1:table1  or an unqualified table name, e.g.  table1 .  The meaning of this constraint is that each combination of non-NULL values in  schema name : table name  MUST reference an existing combination of values forming a composite key for a row in  table reference .  ERMrest also supports pseudo-foreign keys on views, which allow the reference links of views to be asserted both for clients introspecting the catalog model and for ERMrest itself to reason about queries on the view. Psuedo-foreign keys are chosen automatically when an authorized client creates a foreign key constraint on a view or referencing a view, while real database constraints are used when the client creates a foreign key constraint on a table referencing another table.   NOTE  pseudo-foreign keys are advisory,  not enforced  in the database, and  not validated  by ERMrest. A client SHOULD NOT assert inaccurate psuedo-foreign key constraints as it could mislead other clients who introspect the schema or lead to unexpected query results as ERMrest formulates relational queries assuming the constraints are true.  Future ERMrest releases MAY enforce validation on psuedo-foreign keys so clients SHOULD NOT depend on the ability to create inaccurate psuedo-constraints.   Additionally, a composite resource summarizes all foreign key constraints on one table for discovery and bulk retrieval purposes:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   Additionally, a composite resource summarizes all foreign key constraints involving one composite foreign key  column name  list:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   Finally, a composite resource summarizes all foreign key constraints involving one composite foreign key  column name  list and one  table reference :   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   (While highly unusual, it is possible to express more than one foreign key constraint from the same composite foreign key  column name  list to different composite key  key column  lists in the same or different  table reference  tables.)  Foreign Key Comments \uf0c1  Each foreign-key comment is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...  /comment   This named resource has a simple representation which is just human readable text in  text/plain  format.  Foreign Key Annotations \uf0c1  Each foreign-key annotation is reified as a model-level resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...  /annotation/   annotation key   This keyed annotation has a simple representation which is a machine-readable document in  application/json  format. The expected content and interpretation of the JSON document is externally defined and associated with the  annotation key  which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the  annotation key  is to allow different user communities to organize their own annotation standards without ambiguity.  Additionally, a composite resource summarizes all existing annotations on one foreign-key for convenient discovery and bulk retrieval:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...  /annotation  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...  /annotation/", 
            "title": "Table Names"
        }, 
        {
            "location": "/api-docs/model/rest/", 
            "text": "ERMrest Model Operations\n\uf0c1\n\n\nThe model operations configure the entity-relationship model that will be used to structure tabular data in the \nERMrest\n catalog.  The model must be configured before use, but it may continue to be adjusted throughout the lifecycle of the catalog, interleaved with data operations.\n\n\nSchemata Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing the entire catalog data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation as other content types MAY be returned, including HTML-based user interfaces:\n\n\nGET /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"schemas\": {\n    schema name: schema representation, ...\n  }\n}\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is a single field \nschemas\n which in turn is a sub-object used as a dictionary mapping. Each field name of the sub-object is a \nschema name\n and its corresponding value is a \nschema representation\n as described in \nSchema Retrieval\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nBulk Schemata and Table Creation\n\uf0c1\n\n\nThe POST operation can be used to create multiple named schemata and/or tables in a single request by posting a complex JSON document to the same resource used for retrieving all schemata:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema\n\n\n\n\nIn this operation, \napplication/json\n content MUST be provided. The same format returned in schemata retrieval is supported:\n\n\nPOST /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"schemas\": {\n    schema name: schema representation, ...\n  }\n}\n\n\n\nwith this form, each \nschema name\n MUST be distinct and available for use as a new schema in the catalog. Each \nschema representation\n MAY include multiple fields as described in the \nSchema Retrieval\n documentation. If present, the \n\"schema_name\"\n field MUST match the \nschema name\n key of the enclosing document. If present, the \n\"tables\"\n field MAY describe new tables which will also be created as part of the same request.\n\n\nOptionally, a batch request list document is also supported:\n\n\nPOST /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n[\n   schema or table representation, ...\n]\n\n\n\nIn this form, each \nschema representation\n is handled as in the preceding form, creating both schema and any nested tables. Each \ntable representation\n is handled similar to the \nTable Creation\n API, allowing multiple tables to be added to existing schemata. The list of schema and table representations are processed in document order.  With both forms, a set of tables with interdependent foreign key constraints MAY be specified and the service will first create all requested schemata, then all tables, then all foreign key constraints.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 201 Created\nContent-Type: application/json\n\n...new resource representation...\n\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 403 Forbidden\n- 409 Conflict\n- 401 Unauthorized\n\n\nThe request effects are atomic, either applying all elements of the batch change to the catalog model or making no changes at all in the case of failures.\n\n\nSchema Creation\n\uf0c1\n\n\nThe POST operation is used to create new, empty schemata, using a model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n\n\n\n\nIn this operation, no input is required:\n\n\nPOST /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 201 Created\n\n\n\nBUG: should be 204 No Content and/or should include Location header for new schema?\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nSchema Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing the one schema in the data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"schema_name\": schema name,\n  \"comment\": comment,\n  \"annotations\": {\n     annotation key: annotation document, ...\n  }\n  \"tables\": {\n     table name: table representation, ...\n  }\n}\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:\n\n\n\n\nschema_name\n: whose value is the \nschema name\n addressed in the retrieval request\n\n\ncomment\n: whose value is a human-readable \ncomment\n for the schema\n\n\nannotations\n: whose value is a sub-object use as a dictionary where each field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\ntables\n: which is a sub-object used as a dictionary mapping. Each field name of the sub-object is a \ntable name\n and its corresponding value is a \ntable representation\n as described in \nTable Creation\n.\n\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nSchema Deletion\n\uf0c1\n\n\nThe DELETE method is used to delete a schema:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nTable List Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a list of tables in one schema using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation as other content types MAY be returned, including HTML-based user interfaces:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  table representation, ...\n]\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a \ntable representation\n as described in \nTable Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nTable Creation\n\uf0c1\n\n\nThe POST operation is used to add a table to an existing schema's table list resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n\n\n\n\nIn this operation, the \napplication/json\n \ntable representation\n is supplied as input:\n\n\nPOST /ermrest/catalog/42/schema/schema_name/table HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"schema_name\": schema name,\n  \"table_name\": table name,\n  \"comment\": table comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  },\n  \"column_definitions\": [ column representation, ... ],\n  \"keys\": [ key representation, ... ],\n  \"foreign_keys\": [ foreign key representation, ... ],\n  \"kind\": \"table\"\n}\n\n\n\nThe input \ntable representation\n is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:\n\n\n\n\nschema_name\n: whose value is the same \nschema name\n addressed in the request URL (optional content in this request)\n\n\ntable_name\n: whose value is the \ntable name\n string for the new table\n\n\ncomment\n: whose value is the human-readable comment string for the new table\n\n\nannotations\n: whose value is a sub-object use as a dictionary where each field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\ncolumn_definitions\n: an array of \ncolumn representation\n as described in \nColumn Creation\n, interpreted as an ordered list of columns\n\n\nkeys\n: an array of \nkey representation\n as described in \nKey Creation\n, interpreted as an unordered set of keys\n\n\nforeign_keys\n: an array of \nforeign key representation\n as described in \nForeign Key Creation\n, interpreted as an unordered set of foreign keys\n\n\nkind\n: a string indicating the kind of table\n\n\nnormally \ntable\n for a regular mutable table\n\n\nthe value \nview\n MAY be encountered when introspecting existing ERMrest catalogs which may have extended data models not created through the standard ERMrest model management interface; the \nview\n kind of table supports data retrieval operations but does not support data creation, update, nor deletion;\n\n\nthis mechanism MAY be used for future extension so other values SHOULD be detected and the enclosing \ntable representation\n ignored if a client does not know how to interpret that table kind.\n\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\ntable representation\n\n\n\nwhere the body content is the same \ntable representation\n as the request input content, representing the table as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created table, and this result MAY differ from the request input.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict\n\n\nTable Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing one table in the data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\ntable representation\n\n\n\nThe response body is a \ntable representation\n as described in \nTable Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict\n\n\nTable Deletion\n\uf0c1\n\n\nThe DELETE method is used to delete a table and all its content:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name/table/table_name HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict\n\n\nColumn List Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a list of columns in one table using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/column HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  column representation, ...\n]\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a \ncolumn representation\n as described in \nColumn Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nColumn Creation\n\uf0c1\n\n\nThe POST operation is used to add a column to an existing table's column list resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n\n\n\n\nIn this operation, the \napplication/json\n \ncolumn representation\n is supplied as input:\n\n\nPOST /ermrest/catalog/42/schema/schema_name/table/table_name/column HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"name\": column name,\n  \"type\": column type,\n  \"default\": default value,\n  \"nullok\": boolean,\n  \"comment\": column comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  }\n}\n\n\n\nThe input \ncolumn representation\n is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:\n\n\n\n\nname\n: whose value is the \ncolumn name\n string for the new column which must be distinct from all existing columns in the table\n\n\ntype\n: whose value is the \ncolumn type\n drawn from a limited set of supported types in ERMrest\n\n\ndefault\n: whose value is an appropriate default value consistent with the \ncolumn type\n or the JSON \nnull\n value to indicate that NULL values should be used (the default when \ndefault\n is omitted from the \ncolumn representation\n)\n\n\nnullok\n: JSON \ntrue\n if NULL values are allowed or \nfalse\n if NULL values are disallowed in this column (default \ntrue\n if this field is absent in the input column representation)\n\n\ncomment\n: whose value is the human-readable comment string for the column\n\n\nannotations\n: whose value is a sub-object use as a dictionary where each field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\ncolumn representation\n\n\n\nwhere the body content is the same \ncolumn representation\n as the request input content, representing the column  as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created column, and this result MAY differ from the request input.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nColumn Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing one column in the data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/column/column_name HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\ncolumn representation\n\n\n\nThe response body is a \ncolumn representation\n as described in \nColumn Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nColumn Deletion\n\uf0c1\n\n\nThe DELETE method is used to remove a column and all its content from a table:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name/table/table_name/column/column_name HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nKey List Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a list of keys in one table using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/key HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  key representation, ...\n]\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a \nkey representation\n as described in \nKey Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nKey Creation\n\uf0c1\n\n\nThe POST operation is used to add a key constraint to an existing table's key list resource, or a pseudo-key constraint to a view's key list resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n\n\n\n\nIn this operation, the \ntable name\n MAY be an existing table or view in the named schema, and the \napplication/json\n \nkey representation\n is supplied as input:\n\n\nPOST /ermrest/catalog/42/schema/schema_name/table/table_name/key HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"names\": [\n    [ schema name, constraint name ], ...\n   ],\n   \"unique_columns\": [ column name, ... ],\n   \"comment\": comment,\n   \"annotations\": {\n      annotation key: annotation document, ...\n   }\n}\n\n\n\nThe input \nkey representation\n is a JSON document with one object with the following fields:\n\n\n\n\nnames\n: an array of \n[\n \nschema name\n \n,\n \nconstraint name\n \n]\n pairs representing names of underlying constraints that enforce this unique key reference pattern.\n\n\nunique_columns\n has an array value listing the individual columns that comprise the composite key. The constituent columns are listed by their basic \ncolumn name\n strings.\n\n\ncomment\n: whose value is the human-readable comment string for the key\n\n\nannotations\n: whose value is a sub-object use as a dictionary where each field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\n\n\nDuring key creation, the \nnames\n field SHOULD have at most one name pair. Other \nnames\n inputs MAY be ignored by the server. When the \nnames\n field is omitted, the server MUST assign constraint names of its own choosing. In introspection, the \nnames\n field represents the actual state of the database and MAY include generalities not controlled by the key creation API:\n\n\n\n\nRedundant constraints MAY exist in the RDBMS for the same unique key constraint, and hence \nnames\n MAY list more than one existing constraint.\n\n\nThe chosen \nschema name\n for a newly created constraint MAY differ from the one requested by the client.\n\n\nThe server MAY create the constraint in the same schema as the constrained table\n\n\nPseudo keys are qualified by a special \nschema name\n of \n\"\"\n which is not a valid SQL schema name.\n\n\nPseudo keys MAY have an integer \nconstraint name\n assigned by the server.\n\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nkey representation\n\n\n\nwhere the body content is the same \nkey representation\n as the request input content, representing the key as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created key, and this result MAY differ from the request input.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nKey Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing one key in the data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ...\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,... HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nkey representation\n\n\n\nThe response body is a \nkey representation\n as described in \nKey Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nKey Deletion\n\uf0c1\n\n\nThe DELETE method is used to remove a key constraint from a table or a pseudo-key constraint from a view:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,... HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nForeign Key List Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a list of foreign key references in one table using\na model-level resource name of the following forms:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ...\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n\n\n\n\nThese names differ in how many constraints are applied to filter the set of retrieved foreign key references:\n1. The list is always constrained to foreign keys stored in \nschema name\n : \ntable name\n\n1. The list MAY be constrained by the composite foreign key \ncolumn name\n list of its constituent keys, interpreted as a set of columns\n1. The list MAY be constrained by the \ntable reference\n of the table containing the composite key or keys referenced by the composite foreign key\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  foreign key reference representation, ...\n]\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a \nforeign key reference representation\n as described in \nForeign Key Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nForeign Key Creation\n\uf0c1\n\n\nThe POST operation is used to add a foreign key reference constraint or pseudo-constraint to an existing table's or view's foreign key list resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n\n\n\n\nIn this operation, the \napplication/json\n \nforeign key reference representation\n is supplied as input:\n\n\nPOST /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"names\": [\n    [ schema name, constraint name ], ...\n  ]\n  \"foreign_key_columns\": [\n    {\n      \"schema_name\": schema name,\n      \"table_name\": table name,\n      \"column_name\": column name\n    }, ...\n  ]\n  \"referenced_columns\": [\n    {\n      \"schema_name\": schema name,\n      \"table_name\": table name,\n      \"column_name\": column name\n    }\n  ],\n  \"comment\": comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  }\n}\n\n\n\nThe input \nforeign key reference representation\n is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:\n\n\n\n\nnames\n: an array of \n[\n \nschema name\n \n,\n \nconstraint name\n \n]\n pairs representing names of underlying constraints that enforce this foreign key reference pattern.\n\n\nforeign_key_columns\n: an array of column reference objects comprising the composite foreign key, each consisting of a sub-object with the fields:\n\n\nschema_name\n: whose value is the same \nschema name\n addressed in the request URL (optional content in this request)\n\n\ntable_name\n: whose value is the same \ntable name\n addressed in the request URL (optional content in this request)\n\n\ncolumn_name\n: whose value names the constituent column of the composite foreign key\n\n\nreferenced_columns\n: an array of column reference objects comprising the referenced composite key, each consisting of a sub-object with the fields:\n\n\nschema_name\n: whose value names the schema in which the referenced table resides\n\n\ntable_name\n: whose value names the referenced table\n\n\ncolumn_name\n: whose value names the constituent column of the referenced key\n\n\ncomment\n: whose value is the human-readable comment string for the foreign key reference constraint\n\n\nannotations\n: whose value is a sub-object used as a dictionary where each field field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\n\n\nDuring foreign key creation, the \nnames\n field SHOULD have at most one name pair. Other \nnames\n inputs MAY be ignored by the server. When the \nnames\n field is omitted, the server MUST assign constraint names of its own choosing. In introspection, the \nnames\n field represents the actual state of the database and MAY include generalities not controlled by the foreign key creation REST API:\n\n\n\n\nRedundant constraints MAY exist in the RDBMS for the same foreign key mapping constraint, and hence the \nnames\n list MAY list more than one existing constraint. This can happen when the catalog database is manipulated directly in SQL by the local operator.\n\n\nThe chosen \nschema name\n for a newly created constraint MAY differ from the one requested by the client.\n\n\nThe server MAY create the constraint in the same schema as the referencing table, regardless of client request.\n\n\nPseudo foreign keys are qualified by a special \nschema name\n of \n\"\"\n which is not a valid SQL schema name.\n\n\nPseudo foreign keys MAY have an integer \nconstraint name\n assigned by the server.\n\n\n\n\nThe two column arrays MUST have the same length and the order is important in that the two composite keys are mapped to one another element-by-element, so the first column of the composite foreign key refers to the first column of the composite referenced key, etc. In the \nreferenced_columns\n list, the \nschema name\n and \ntable name\n values MUST be identical for all referenced columns. If both referencing and referenced \ntable name\n refer to tables, a real constraint is created; if either referencing or referenced \ntable name\n refer to a view, a pseudo-constraint is created instead.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nforeign key reference representation\n\n\n\nwhere the body content is the same \nforeign key reference representation\n as the request input content, representing the constraint as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created constraint, and this result MAY differ from the request input.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nForeign Key Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing one foreign key constraint in the data model using a model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ...\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey/column_name,.../reference/table-reference/key_column,... HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nforeign key reference representation\n\n\n\nThe response body is a \nforeign key reference representation\n as described in \nForeign Key Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nForeign Key Deletion\n\uf0c1\n\n\nThe DELETE method is used to remove a foreign key constraint from a table using any of the foreign key list or foreign key resource name forms:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ...\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ...\n\n\n\n\nThese names differ in how many constraints are applied to filter the set of retrieved foreign key references:\n\n\n\n\nThe list is always constrained to foreign keys stored in \nschema name\n : \ntable name\n\n\nThe list MAY be constrained by the composite foreign key \ncolumn name\n list of its constituent keys, interpreted as a set of columns\n\n\nThe list MAY be constrained by the \ntable reference\n of the table containing the composite key or keys referenced by the composite foreign key\n\n\nThe list MAY be constrained by the composite referenced key \nkey column\n list\n\n\n\n\nThis example uses a completely specified foreign key constraint name:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,.../reference/table_reference/key_column,... HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nThe effect is to delete all foreign key constraints from the table matching the resource name used in the request.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nModel Annotations\n\uf0c1\n\n\nAnnotations are generic sub-resources available within multiple \nsubject\n resources. The possible \nsubject\n resources are:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ... \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n\n\n\n\nAnd the annotation sub-resources are named by appending \n/annotation/\n to the \nsubject\n resource as described in the following operations.\n\n\nAnnotation List Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing a set of annotations on one subject resource:\n\n\n\n\nsubject\n \n/annotation/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET subject/annotation/ HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  annotation key: annotation document, ...\n}\n\n\n\nIts general structure is a single object containing the \nannotations\n dictionary from the enclosing \nsubject\n resource. Each field of the object is an \nannotation key\n and its corresponding value is the nested \nannotation document\n content.\n\n\nTypical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotation Creation\n\uf0c1\n\n\nThe PUT operation is used to add or replace a single annotation:\n\n\n\n\nsubject\n \n/annotation/\n \nannotation key\n\n\n\n\nIn this operation, the \napplication/json\n \nannotation document\n is supplied as input:\n\n\nPUT subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\nannotation document\n\n\n\nThe input \nannotation document\n is a arbitrary JSON payload appropriate to the chosen \nannotation key\n.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 201 Created\n\n\n\nor:\n\n\nHTTP/1.1 200 OK\n\n\n\nwithout any response body. The \n200\n response indicates the \nannotation document\n replaces a previous one, while \n201\n responses indicate that a new \nannotation key\n has been added to the parent resource.\n\n\nTypical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotation Bulk Update\n\uf0c1\n\n\nThe PUT operation can also replace the whole annotation list at once:\n\n\n\n\nsubject\n \n/annotation\n\n\n\n\nIn this operation, the \napplication/json\n \nannotation list\n is supplied as input to specify all \nannotation key\n and \nannotation document\n values at once:\n\n\nPUT subject/annotation HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  annotation key: annotation document, ...\n}\n\n\n\nThis operation completely replaces any existing annotations, including dropping any which were present under an \nannotation key\n not specified in the bulk input list. This is most useful to an administrator who is intentionally clearing stale annotation content.\n\n\nTypical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotation Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing one annotation using a model-level resource name of the form:\n\n\n\n\nsubject\n \n/annotation/\n \nannotation key\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nannotation document\n\n\n\nIts general structure is a single object containing \nannotation document\n content associated with \nannotation key\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotation Deletion\n\uf0c1\n\n\nThe DELETE method is used to delete an annotation using a model-level resource name of the form:\n\n\n\n\nsubject\n \n/annotation/\n \nannotation key\n\n\n\n\nThe request does not require content-negotiation since there is no response representation:\n\n\nDELETE subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nModel Comments\n\uf0c1\n\n\nComments are generic sub-resources available within multiple \nsubject\n resources. The possible \nsubject\n resources are:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ... \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n\n\n\n\nAnd the comment sub-resources are named by appending \n/comment\n to the \nsubject\n resource as described in the following operations.\n\n\nComment Creation\n\uf0c1\n\n\nThe PUT operation is used to add or replace a single comment:\n\n\n\n\nsubject\n \n/comment\n\n\nsubject\n \n/comment/\n\n\n\n\nIn this operation, the \ntext/plain\n \ncomment text\n is supplied as input:\n\n\nPOST subject/comment/ HTTP/1.1\nHost: www.example.com\nContent-Type: text/plain\n\ncomment text\n\n\n\nThe input \ncomment text\n is a arbitrary UTF-8 text payload.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\n\n\n\nwithout any response body.\n\n\nTypical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized\n\n\nComment Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve a document describing one comment using a model-level resource name of the form:\n\n\n\n\nsubject\n \n/comment\n\n\n\n\nIn this operation, content-negotiation is not necessary:\n\n\nGET subject/comment HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/plain\n\ncomment text\n\n\n\nIts general structure is raw \ncomment text\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nComment Deletion\n\uf0c1\n\n\nThe DELETE method is used to delete an comment using a model-level resource name of the form:\n\n\n\n\nsubject\n \n/comment\n\n\n\n\nThe request does not require content-negotiation since there is no response representation:\n\n\nDELETE subject/comment HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "ERMrest Model Operations"
        }, 
        {
            "location": "/api-docs/model/rest/#ermrest-model-operations", 
            "text": "The model operations configure the entity-relationship model that will be used to structure tabular data in the  ERMrest  catalog.  The model must be configured before use, but it may continue to be adjusted throughout the lifecycle of the catalog, interleaved with data operations.", 
            "title": "ERMrest Model Operations"
        }, 
        {
            "location": "/api-docs/model/rest/#schemata-retrieval", 
            "text": "The GET operation is used to retrieve a document describing the entire catalog data model using\na model-level resource name of the form:   service   /catalog/   cid   /schema  service   /catalog/   cid   /schema/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation as other content types MAY be returned, including HTML-based user interfaces:  GET /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"schemas\": {\n    schema name: schema representation, ...\n  }\n}  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is a single field  schemas  which in turn is a sub-object used as a dictionary mapping. Each field name of the sub-object is a  schema name  and its corresponding value is a  schema representation  as described in  Schema Retrieval .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Schemata Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#bulk-schemata-and-table-creation", 
            "text": "The POST operation can be used to create multiple named schemata and/or tables in a single request by posting a complex JSON document to the same resource used for retrieving all schemata:   service   /catalog/   cid   /schema   In this operation,  application/json  content MUST be provided. The same format returned in schemata retrieval is supported:  POST /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"schemas\": {\n    schema name: schema representation, ...\n  }\n}  with this form, each  schema name  MUST be distinct and available for use as a new schema in the catalog. Each  schema representation  MAY include multiple fields as described in the  Schema Retrieval  documentation. If present, the  \"schema_name\"  field MUST match the  schema name  key of the enclosing document. If present, the  \"tables\"  field MAY describe new tables which will also be created as part of the same request.  Optionally, a batch request list document is also supported:  POST /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n[\n   schema or table representation, ...\n]  In this form, each  schema representation  is handled as in the preceding form, creating both schema and any nested tables. Each  table representation  is handled similar to the  Table Creation  API, allowing multiple tables to be added to existing schemata. The list of schema and table representations are processed in document order.  With both forms, a set of tables with interdependent foreign key constraints MAY be specified and the service will first create all requested schemata, then all tables, then all foreign key constraints.  On success, the response is:  HTTP/1.1 201 Created\nContent-Type: application/json\n\n...new resource representation...  Typical error response codes include:\n- 400 Bad Request\n- 403 Forbidden\n- 409 Conflict\n- 401 Unauthorized  The request effects are atomic, either applying all elements of the batch change to the catalog model or making no changes at all in the case of failures.", 
            "title": "Bulk Schemata and Table Creation"
        }, 
        {
            "location": "/api-docs/model/rest/#schema-creation", 
            "text": "The POST operation is used to create new, empty schemata, using a model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   In this operation, no input is required:  POST /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com  On success, the response is:  HTTP/1.1 201 Created  BUG: should be 204 No Content and/or should include Location header for new schema?  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Schema Creation"
        }, 
        {
            "location": "/api-docs/model/rest/#schema-retrieval", 
            "text": "The GET operation is used to retrieve a document describing the one schema in the data model using\na model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"schema_name\": schema name,\n  \"comment\": comment,\n  \"annotations\": {\n     annotation key: annotation document, ...\n  }\n  \"tables\": {\n     table name: table representation, ...\n  }\n}  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:   schema_name : whose value is the  schema name  addressed in the retrieval request  comment : whose value is a human-readable  comment  for the schema  annotations : whose value is a sub-object use as a dictionary where each field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)  tables : which is a sub-object used as a dictionary mapping. Each field name of the sub-object is a  table name  and its corresponding value is a  table representation  as described in  Table Creation .   Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Schema Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#schema-deletion", 
            "text": "The DELETE method is used to delete a schema:  DELETE /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Schema Deletion"
        }, 
        {
            "location": "/api-docs/model/rest/#table-list-retrieval", 
            "text": "The GET operation is used to retrieve a list of tables in one schema using\na model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   /table  service   /catalog/   cid   /schema/   schema name   /table/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation as other content types MAY be returned, including HTML-based user interfaces:  GET /ermrest/catalog/42/schema/schema_name/table HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  table representation, ...\n]  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a  table representation  as described in  Table Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Table List Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#table-creation", 
            "text": "The POST operation is used to add a table to an existing schema's table list resource:   service   /catalog/   cid   /schema/   schema name   /table  service   /catalog/   cid   /schema/   schema name   /table/   In this operation, the  application/json   table representation  is supplied as input:  POST /ermrest/catalog/42/schema/schema_name/table HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"schema_name\": schema name,\n  \"table_name\": table name,\n  \"comment\": table comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  },\n  \"column_definitions\": [ column representation, ... ],\n  \"keys\": [ key representation, ... ],\n  \"foreign_keys\": [ foreign key representation, ... ],\n  \"kind\": \"table\"\n}  The input  table representation  is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:   schema_name : whose value is the same  schema name  addressed in the request URL (optional content in this request)  table_name : whose value is the  table name  string for the new table  comment : whose value is the human-readable comment string for the new table  annotations : whose value is a sub-object use as a dictionary where each field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)  column_definitions : an array of  column representation  as described in  Column Creation , interpreted as an ordered list of columns  keys : an array of  key representation  as described in  Key Creation , interpreted as an unordered set of keys  foreign_keys : an array of  foreign key representation  as described in  Foreign Key Creation , interpreted as an unordered set of foreign keys  kind : a string indicating the kind of table  normally  table  for a regular mutable table  the value  view  MAY be encountered when introspecting existing ERMrest catalogs which may have extended data models not created through the standard ERMrest model management interface; the  view  kind of table supports data retrieval operations but does not support data creation, update, nor deletion;  this mechanism MAY be used for future extension so other values SHOULD be detected and the enclosing  table representation  ignored if a client does not know how to interpret that table kind.   On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\ntable representation  where the body content is the same  table representation  as the request input content, representing the table as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created table, and this result MAY differ from the request input.  Typical error response codes include:\n- 400 Bad Request\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict", 
            "title": "Table Creation"
        }, 
        {
            "location": "/api-docs/model/rest/#table-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one table in the data model using\na model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   /table/   table name   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\ntable representation  The response body is a  table representation  as described in  Table Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict", 
            "title": "Table Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#table-deletion", 
            "text": "The DELETE method is used to delete a table and all its content:  DELETE /ermrest/catalog/42/schema/schema_name/table/table_name HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict", 
            "title": "Table Deletion"
        }, 
        {
            "location": "/api-docs/model/rest/#column-list-retrieval", 
            "text": "The GET operation is used to retrieve a list of columns in one table using\na model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /column  service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/column HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  column representation, ...\n]  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a  column representation  as described in  Column Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Column List Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#column-creation", 
            "text": "The POST operation is used to add a column to an existing table's column list resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /column  service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   In this operation, the  application/json   column representation  is supplied as input:  POST /ermrest/catalog/42/schema/schema_name/table/table_name/column HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"name\": column name,\n  \"type\": column type,\n  \"default\": default value,\n  \"nullok\": boolean,\n  \"comment\": column comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  }\n}  The input  column representation  is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:   name : whose value is the  column name  string for the new column which must be distinct from all existing columns in the table  type : whose value is the  column type  drawn from a limited set of supported types in ERMrest  default : whose value is an appropriate default value consistent with the  column type  or the JSON  null  value to indicate that NULL values should be used (the default when  default  is omitted from the  column representation )  nullok : JSON  true  if NULL values are allowed or  false  if NULL values are disallowed in this column (default  true  if this field is absent in the input column representation)  comment : whose value is the human-readable comment string for the column  annotations : whose value is a sub-object use as a dictionary where each field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)   On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\ncolumn representation  where the body content is the same  column representation  as the request input content, representing the column  as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created column, and this result MAY differ from the request input.  Typical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Column Creation"
        }, 
        {
            "location": "/api-docs/model/rest/#column-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one column in the data model using\na model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   column name   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/column/column_name HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\ncolumn representation  The response body is a  column representation  as described in  Column Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Column Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#column-deletion", 
            "text": "The DELETE method is used to remove a column and all its content from a table:  DELETE /ermrest/catalog/42/schema/schema_name/table/table_name/column/column_name HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Column Deletion"
        }, 
        {
            "location": "/api-docs/model/rest/#key-list-retrieval", 
            "text": "The GET operation is used to retrieve a list of keys in one table using\na model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key  service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/key HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  key representation, ...\n]  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a  key representation  as described in  Key Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Key List Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#key-creation", 
            "text": "The POST operation is used to add a key constraint to an existing table's key list resource, or a pseudo-key constraint to a view's key list resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key  service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   In this operation, the  table name  MAY be an existing table or view in the named schema, and the  application/json   key representation  is supplied as input:  POST /ermrest/catalog/42/schema/schema_name/table/table_name/key HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"names\": [\n    [ schema name, constraint name ], ...\n   ],\n   \"unique_columns\": [ column name, ... ],\n   \"comment\": comment,\n   \"annotations\": {\n      annotation key: annotation document, ...\n   }\n}  The input  key representation  is a JSON document with one object with the following fields:   names : an array of  [   schema name   ,   constraint name   ]  pairs representing names of underlying constraints that enforce this unique key reference pattern.  unique_columns  has an array value listing the individual columns that comprise the composite key. The constituent columns are listed by their basic  column name  strings.  comment : whose value is the human-readable comment string for the key  annotations : whose value is a sub-object use as a dictionary where each field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)   During key creation, the  names  field SHOULD have at most one name pair. Other  names  inputs MAY be ignored by the server. When the  names  field is omitted, the server MUST assign constraint names of its own choosing. In introspection, the  names  field represents the actual state of the database and MAY include generalities not controlled by the key creation API:   Redundant constraints MAY exist in the RDBMS for the same unique key constraint, and hence  names  MAY list more than one existing constraint.  The chosen  schema name  for a newly created constraint MAY differ from the one requested by the client.  The server MAY create the constraint in the same schema as the constrained table  Pseudo keys are qualified by a special  schema name  of  \"\"  which is not a valid SQL schema name.  Pseudo keys MAY have an integer  constraint name  assigned by the server.   On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nkey representation  where the body content is the same  key representation  as the request input content, representing the key as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created key, and this result MAY differ from the request input.  Typical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Key Creation"
        }, 
        {
            "location": "/api-docs/model/rest/#key-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one key in the data model using\na model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   column name   ,  ...   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,... HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nkey representation  The response body is a  key representation  as described in  Key Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Key Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#key-deletion", 
            "text": "The DELETE method is used to remove a key constraint from a table or a pseudo-key constraint from a view:  DELETE /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,... HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Key Deletion"
        }, 
        {
            "location": "/api-docs/model/rest/#foreign-key-list-retrieval", 
            "text": "The GET operation is used to retrieve a list of foreign key references in one table using\na model-level resource name of the following forms:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey    service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/    service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   These names differ in how many constraints are applied to filter the set of retrieved foreign key references:\n1. The list is always constrained to foreign keys stored in  schema name  :  table name \n1. The list MAY be constrained by the composite foreign key  column name  list of its constituent keys, interpreted as a set of columns\n1. The list MAY be constrained by the  table reference  of the table containing the composite key or keys referenced by the composite foreign key  In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  foreign key reference representation, ...\n]  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a  foreign key reference representation  as described in  Foreign Key Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Foreign Key List Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#foreign-key-creation", 
            "text": "The POST operation is used to add a foreign key reference constraint or pseudo-constraint to an existing table's or view's foreign key list resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   In this operation, the  application/json   foreign key reference representation  is supplied as input:  POST /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"names\": [\n    [ schema name, constraint name ], ...\n  ]\n  \"foreign_key_columns\": [\n    {\n      \"schema_name\": schema name,\n      \"table_name\": table name,\n      \"column_name\": column name\n    }, ...\n  ]\n  \"referenced_columns\": [\n    {\n      \"schema_name\": schema name,\n      \"table_name\": table name,\n      \"column_name\": column name\n    }\n  ],\n  \"comment\": comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  }\n}  The input  foreign key reference representation  is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:   names : an array of  [   schema name   ,   constraint name   ]  pairs representing names of underlying constraints that enforce this foreign key reference pattern.  foreign_key_columns : an array of column reference objects comprising the composite foreign key, each consisting of a sub-object with the fields:  schema_name : whose value is the same  schema name  addressed in the request URL (optional content in this request)  table_name : whose value is the same  table name  addressed in the request URL (optional content in this request)  column_name : whose value names the constituent column of the composite foreign key  referenced_columns : an array of column reference objects comprising the referenced composite key, each consisting of a sub-object with the fields:  schema_name : whose value names the schema in which the referenced table resides  table_name : whose value names the referenced table  column_name : whose value names the constituent column of the referenced key  comment : whose value is the human-readable comment string for the foreign key reference constraint  annotations : whose value is a sub-object used as a dictionary where each field field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)   During foreign key creation, the  names  field SHOULD have at most one name pair. Other  names  inputs MAY be ignored by the server. When the  names  field is omitted, the server MUST assign constraint names of its own choosing. In introspection, the  names  field represents the actual state of the database and MAY include generalities not controlled by the foreign key creation REST API:   Redundant constraints MAY exist in the RDBMS for the same foreign key mapping constraint, and hence the  names  list MAY list more than one existing constraint. This can happen when the catalog database is manipulated directly in SQL by the local operator.  The chosen  schema name  for a newly created constraint MAY differ from the one requested by the client.  The server MAY create the constraint in the same schema as the referencing table, regardless of client request.  Pseudo foreign keys are qualified by a special  schema name  of  \"\"  which is not a valid SQL schema name.  Pseudo foreign keys MAY have an integer  constraint name  assigned by the server.   The two column arrays MUST have the same length and the order is important in that the two composite keys are mapped to one another element-by-element, so the first column of the composite foreign key refers to the first column of the composite referenced key, etc. In the  referenced_columns  list, the  schema name  and  table name  values MUST be identical for all referenced columns. If both referencing and referenced  table name  refer to tables, a real constraint is created; if either referencing or referenced  table name  refer to a view, a pseudo-constraint is created instead.  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nforeign key reference representation  where the body content is the same  foreign key reference representation  as the request input content, representing the constraint as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created constraint, and this result MAY differ from the request input.  Typical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Foreign Key Creation"
        }, 
        {
            "location": "/api-docs/model/rest/#foreign-key-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one foreign key constraint in the data model using a model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey/column_name,.../reference/table-reference/key_column,... HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nforeign key reference representation  The response body is a  foreign key reference representation  as described in  Foreign Key Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Foreign Key Retrieval"
        }, 
        {
            "location": "/api-docs/model/rest/#foreign-key-deletion", 
            "text": "The DELETE method is used to remove a foreign key constraint from a table using any of the foreign key list or foreign key resource name forms:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey    service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/    service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...   These names differ in how many constraints are applied to filter the set of retrieved foreign key references:   The list is always constrained to foreign keys stored in  schema name  :  table name  The list MAY be constrained by the composite foreign key  column name  list of its constituent keys, interpreted as a set of columns  The list MAY be constrained by the  table reference  of the table containing the composite key or keys referenced by the composite foreign key  The list MAY be constrained by the composite referenced key  key column  list   This example uses a completely specified foreign key constraint name:  DELETE /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,.../reference/table_reference/key_column,... HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  The effect is to delete all foreign key constraints from the table matching the resource name used in the request.  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Foreign Key Deletion"
        }, 
        {
            "location": "/api-docs/model/rest/#model-annotations", 
            "text": "Annotations are generic sub-resources available within multiple  subject  resources. The possible  subject  resources are:   service   /catalog/   cid  service   /catalog/   cid   /schema/   schema name    service   /catalog/   cid   /schema/   schema name   /table/   table name    service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   column name    service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   column name   ,  ...   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...    And the annotation sub-resources are named by appending  /annotation/  to the  subject  resource as described in the following operations.  Annotation List Retrieval \uf0c1  The GET operation is used to retrieve a document describing a set of annotations on one subject resource:   subject   /annotation/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET subject/annotation/ HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  annotation key: annotation document, ...\n}  Its general structure is a single object containing the  annotations  dictionary from the enclosing  subject  resource. Each field of the object is an  annotation key  and its corresponding value is the nested  annotation document  content.  Typical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized  Annotation Creation \uf0c1  The PUT operation is used to add or replace a single annotation:   subject   /annotation/   annotation key   In this operation, the  application/json   annotation document  is supplied as input:  PUT subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\nannotation document  The input  annotation document  is a arbitrary JSON payload appropriate to the chosen  annotation key .  On success, the response is:  HTTP/1.1 201 Created  or:  HTTP/1.1 200 OK  without any response body. The  200  response indicates the  annotation document  replaces a previous one, while  201  responses indicate that a new  annotation key  has been added to the parent resource.  Typical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized  Annotation Bulk Update \uf0c1  The PUT operation can also replace the whole annotation list at once:   subject   /annotation   In this operation, the  application/json   annotation list  is supplied as input to specify all  annotation key  and  annotation document  values at once:  PUT subject/annotation HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  annotation key: annotation document, ...\n}  This operation completely replaces any existing annotations, including dropping any which were present under an  annotation key  not specified in the bulk input list. This is most useful to an administrator who is intentionally clearing stale annotation content.  Typical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized  Annotation Retrieval \uf0c1  The GET operation is used to retrieve a document describing one annotation using a model-level resource name of the form:   subject   /annotation/   annotation key   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nannotation document  Its general structure is a single object containing  annotation document  content associated with  annotation key .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized  Annotation Deletion \uf0c1  The DELETE method is used to delete an annotation using a model-level resource name of the form:   subject   /annotation/   annotation key   The request does not require content-negotiation since there is no response representation:  DELETE subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Model Annotations"
        }, 
        {
            "location": "/api-docs/model/rest/#model-comments", 
            "text": "Comments are generic sub-resources available within multiple  subject  resources. The possible  subject  resources are:   service   /catalog/   cid   /schema/   schema name    service   /catalog/   cid   /schema/   schema name   /table/   table name    service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   column name    service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   column name   ,  ...   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...    And the comment sub-resources are named by appending  /comment  to the  subject  resource as described in the following operations.  Comment Creation \uf0c1  The PUT operation is used to add or replace a single comment:   subject   /comment  subject   /comment/   In this operation, the  text/plain   comment text  is supplied as input:  POST subject/comment/ HTTP/1.1\nHost: www.example.com\nContent-Type: text/plain\n\ncomment text  The input  comment text  is a arbitrary UTF-8 text payload.  On success, the response is:  HTTP/1.1 200 OK  without any response body.  Typical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized  Comment Retrieval \uf0c1  The GET operation is used to retrieve a document describing one comment using a model-level resource name of the form:   subject   /comment   In this operation, content-negotiation is not necessary:  GET subject/comment HTTP/1.1\nHost: www.example.com  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/plain\n\ncomment text  Its general structure is raw  comment text .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized  Comment Deletion \uf0c1  The DELETE method is used to delete an comment using a model-level resource name of the form:   subject   /comment   The request does not require content-negotiation since there is no response representation:  DELETE subject/comment HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Model Comments"
        }, 
        {
            "location": "/api-docs/data/naming/", 
            "text": "ERMrest Data Resource Naming\n\uf0c1\n\n\nThe \nERMrest\n data resource names always have a common structure:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/\n \napi\n \n/\n \npath\n\n\nservice\n \n/catalog/\n \ncid\n \n/\n \napi\n \n/\n \npath\n \nsuffix\n\n\nservice\n \n/catalog/\n \ncid\n \n/\n \napi\n \n/\n \npath\n \nsuffix\n \n?\n \nquery parameters\n\n\n\n\nwhere the components in this structure are:\n\n\n\n\nservice\n: the ERMrest service endpoint such as \nhttps://www.example.com/ermrest\n.\n\n\ncid\n: the catalog identifier for one dataset such as \n42\n.\n\n\napi\n: the API or data resource space identifier such as \nentity\n, \nattribute\n, \nattributegroup\n, or \naggregate\n.\n\n\npath\n: the data path which identifies one filtered entity set with optional joined context.\n\n\nsuffix\n: additional content that depends on the \napi\n\n\nthe group keys associated with \nattributegroup\n resources\n\n\nthe projection associated with \nattribute\n, \nattributegroup\n, and \naggregate\n resources\n\n\nquery parameters\n: optional parameters which may affect interpretation of the data name\n\n\n\n\nEntity Names\n\uf0c1\n\n\nThe \nentity\n resource space denotes whole entities using names of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n\n\n\n\nThe primary naming convention, without query parameters, denotes the final entity set referenced by \npath\n, as per the \ndata path rules\n. The denoted entity set has the same tuple structure as the final table instance in \npath\n and may be a subset of the entities based on joining and filtering criteria encoded in \npath\n. The set of resulting tuples are distinct according to the key definitions of that table instance, i.e. any joins in the path may be used to filter out rows but do not cause duplicate rows.\n\n\nAttribute Names\n\uf0c1\n\n\nThe \nattribute\n resource space denotes projected attributes of entities using names of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \ncolumn reference\n \n,\n ...\n\n\n\n\nThe \npath\n is interpreted identically to the \nentity\n resource space. However, rather than denoting a set of whole entities, the \nattribute\n resource space denotes specific fields \nprojected\n from that set of entities.  The projected \ncolumn reference\n list elements can be in one of several forms:\n\n\n\n\n[ \nout alias\n \n:=\n ] \ncolumn name\n\n\nA field is projected from the final table instance of \npath\n.\n\n\nAn optional \nout alias\n can be assigned to rename the output column, and by default the output column will be named by the unqualified \ncolumn name\n.\n\n\n*\n\n\nA wildcard that expands to all of the columns from the final table instance of \npath\n.\n\n\nThe output columns are automatically named by their unqualified column names.\n\n\n[ \nout alias\n \n:=\n ] \nalias\n \n:\n \ncolumn name\n\n\nA field is projected from a table instance bound to \nalias\n in \npath\n.\n\n\nAn optional \nout alias\n can be assigned to rename the output column, and by default the output column will be named by the unqualified \ncolumn name\n.\n\n\nalias\n \n:\n \n*\n\n\nA wildcard that expands to all of the columns from a table instance bound to \nalias\n in \npath\n.\n\n\nThe output columns are automatically named by their \nalias\n qualified column names to prevent collisions between the multiple wildcard-expansions that are possible within one complex \npath\n. If a projection \nA:*\n is used for a table instance with a column named \nfoo\n in it, the output data will then have a column with the literal name \nA:foo\n. Special attention must be paid when trying to reference such columns using the \nsort modifier\n, as this modifier uses the output name \nA:foo\n as a user-supplied literal and therefore the \n:\n must be escaped as in \n@sort(A%3Afoo)\n.\n\n\n\n\nLike in the \nentity\n resource space, joined tables may cause filtering but not duplication of rows in the final entity set. Thus, when projecting fields from aliased table instances in \npath\n, values are arbitrarily selected from one of the joined contextual rows if more than one such row was joined to the same final entity.\n\n\nAggregate Names\n\uf0c1\n\n\nThe \naggregate\n resource space denotes computed (global) aggregates using names of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/aggregate/\n \npath\n \n/\n \naggregate\n \n,\n ...\n\n\n\n\nThe \npath\n is interpreted slightly differently than in the \nattribute\n resource space. Rather than denoting a set of entities drawn from the final table instance in \npath\n, it denotes a set of entity combinations, meaning that there is a potential for a combinatoric number of intermediate records depending on how path entity elements are linked. This denoted set of entity combinations is reduced to a single \naggregate\n tuple. The computed \naggregate\n tuple elements can be in one of several forms:\n\n\n\n\nout alias\n \n:=\n \nfunction\n \n(\n \ncolumn name\n \n)\n\n\nout alias\n \n:=\n \nfunction\n \n(*)\n\n\nout alias\n \n:=\n \nfunction\n \n(\n \nin alias\n \n:\n \ncolumn name\n \n)\n\n\nout alias\n \n:=\n \nfunction\n \n(\n \nin alias\n \n:\n \n*\n \n)\n\n\n\n\nThe \nout alias\n is the name given to the computed field. The \nfunction\n is one of a limited set of aggregate functions supported by ERMrest:\n\n\n\n\nmin\n: the minimum non-NULL value (or NULL)\n\n\nmax\n: the maximum non-NULL value (or NULL)\n\n\ncnt_d\n: the count of distinct non-NULL values\n\n\ncnt\n: the count of non-NULL values\n\n\narray\n: an array containing all values (including NULL)\n\n\n\n\nThese aggregate functions are evaluated over the set of values projected from the entity set denoted by \npath\n. The same column resolution rules apply as in other projection lists: a bare \ncolumn name\n MUST reference a column of the final entity set while an alias-qualified column name MUST reference a column of a table instance bound to \nalias\n in the \npath\n.\n\n\nAs a special case, the psuedo-column \n*\n can be used in several idiomatic forms:\n\n\n\n\ncnt(*)\n: a count of entities rather than of non-NULL values is computed\n\n\narray(\nalias\n:*)\n: an array of records rather than an array of values is computed\n\n\n\n\nTODO: document other variants?\n\n\nAttribute Group Names\n\uf0c1\n\n\nThe \nattributegroup\n resource space denotes groups of entities by arbitrary grouping keys and computed (group-level) aggregates using names of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ...\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \naggregate\n \n,\n ...\n\n\n\n\nThe \npath\n is interpreted slightly differently than in the \nattribute\n resource space. Rather than denoting a set of entities drawn from the final table instance in \npath\n, it denotes a set of entity combinations, meaning that there is a potential for a combinatoric number of records depending on how path entity elements are linked. This denoted set of entity combinations is reduced to groups where each group represents a set of entities sharing the same \ngroup key\n tuple, and optional \naggregate\n list elements are evaluated over this set of entities to produce a group-level aggregate value.\n\n\nThe \ngroup key\n list elements use the same notation as the \ncolumn reference\n elements in the \nattribute\n resource space. The \naggregate\n list elements use the same notation as the \naggregate\n elements in the \naggregate\n resource space or the \ncolumn reference\n elements in the \nattribute\n resource space. An \naggregate\n using \ncolumn reference\n notation denotes an example value chosen from an arbitrary member of each group.\n\n\nAttribute Binning\n\uf0c1\n\n\nIn order to group numerical values into bins, e.g. for histogram presentation, a special \nbinning\n operator is allowed in attribute or group key projections in place of a bare column reference:\n\n\n\n\nbin(\n \ncolumn name\n \n;\n \nnbins\n \n;\n \nminval\n \n;\n \nmaxval\n \n)\n\n\nbin(\n \nin alias\n \n:\n \ncolumn name\n \n;\n \nnbins\n \n;\n \nminval\n \n;\n \nmaxval\n \n)\n\n\n\n\nThe binning operator determines which bucket the value in \ncolumn name\n belongs to, dividing the requested range from \nminval\n (inclusive) to \nmaxval\n (exclusive) into \nnbins\n equal-width intervals. The result is always a three-element JSON array \n[\n \nbucket\n \n,\n \nlower\n \n,\n \nupper\n \n]\n describing the bucket.\n\n\n\n\nbucket\n: The bin number which the value falls into.\n\n\nnull\n: The \nnull\n bin captures all NULL values.\n\n\n0: The zero bin captures all values below the requested range.\n\n\n1: The first bin in the requested range.\n\n\nnbins\n: The last bin in the requested range.\n\n\nbins\n + 1: The final bin captures all values above the requested range.\n\n\n\n\n\n\nlower\n: The lower bound (inclusive) of the bin, or \nnull\n.\n\n\nupper\n: The upper bound (exclusive) of the bin, or \nnull\n.\n\n\n\n\nIf the client does not wish to consider NULL or out-of-range values, they MAY include an appropriate filter to exclude those rows from the query.\n\n\nA useful idiom is to use binning as a group-key in the \nattributegroup\n API with \ncnt(*)\n to count all matching rows within each bin. The results will be sparse: only bins with a non-zero row count will appear as grouped output rows. The sort modifier MAY be applied to the binning group key.\n\n\nSupported Column Types for Binning\n\uf0c1\n\n\nThe binning operator is only supported for certain basic column storage types:\n\n\n\n\ndate\n\n\nfloat4\n, \nfloat8\n\n\nint2\n, \nint4\n, \nint8\n\n\nnumeric\n\n\ntimestamptz\n, \ntimestamp\n\n\n\n\nData Paths\n\uf0c1\n\n\nERMrest introduces a general path-based syntax for naming data resources with idioms for navigation and filtering of entity sets. The \npath\n element of the data resource name always denotes a set of entities or joined entities.  The path must be interpreted from left to right in order to understand its meaning. The denoted entity set is understood upon reaching the right-most element of the path and may be modified by the resource space or \napi\n under which the path occurs.\n\n\nPath Root\n\uf0c1\n\n\nA path always starts with a direct table reference:\n\n\n\n\ntable name\n\n\nschema name\n \n:\n \ntable name\n\n\n\n\nwhich must already be defined in the catalog under the corresponding model resource:\n\n\n\n\n/schema/\n \nschema name\n \n/table/\n \ntable name\n\n\n\n\nThe unqualified \ntable name\n MAY be used in a path if it is the only occurrence of that table name across all schemata in the catalog, i.e. only if it is unambiguous.\n\n\nA path consisting of only one table reference denotes the entities within that table.\n\n\nPath Filters\n\uf0c1\n\n\nA filter element can augment a path with a filter expression:\n\n\n\n\nparent path\n \n/\n \nfilter\n\n\n\n\nafter which the combined path denotes a filtered subset of the entities denoted by \nparent path\n where the \nfilter\n expressed in the \nfilter language\n evaluates to a true value.  The accumulative affect of several filter path elements is a logical conjunction of all the filtering criteria in those elements. It is also intuitive to think of a chain of filter elements as a filtering pipeline or sieve, each eliminating data which does not match the filter criteria.\n\n\nEntity Links\n\uf0c1\n\n\nAn entity link element can augment a path with an additional related or joined table:\n\n\n\n\nparent path\n \n/\n \ntable name\n\n\nparent path\n \n/\n \nschema name\n \n:\n \ntable name\n\n\n\n\nas in the path root, \ntable name\n may be explicitly schema qualified or left unqualified if it is unambiguous within the catalog. In order for this basic table link element to be valid, there must be at least one foreign-key relationship linking the entity set denoted by \nparent path\n and the table denoted by \ntable name\n. The links may point in either direction, i.e. the \nparent path\n entity set may contain foreign keys which reference \ntable name\n or \ntable name\n may contain foreign keys which reference the \nparent path\n entities.\n\n\nWhen there are multiple possible linkages to choose from, the link is formed using the disjunction of all applicable link conditions.\n\n\nLinkage by Foreign-Key Endpoint\n\uf0c1\n\n\nA more precise entity link element can choose one link condition by identifying an endpoint of the linkage as a set of columns:\n\n\n\n\nparent path\n \n/(\n \ncolumn name\n \n,\n ... \n)\n\n\nparent path\n \n/(\n \ntable name\n \n:\n \ncolumn name\n \n,\n ... \n)\n\n\nparent path\n \n/(\n \nschema name\n \n:\n \ntable name\n \n:\n \ncolumn name\n \n,\n ... \n)\n\n\n\n\nThis set of columns MUST comprise either a primary key or a foreign key which unambiguously identifies a single possible linkage between the \nparent path\n and a single possible linked entity table. As a convenience, the \nschema name\n and \ntable name\n need not be repeated for additional \ncolumn name\n elements in the list after the first one; each unqualified \ncolumn name\n will be resolved against the same table as the first \ncolumn name\n in the sequence.\n\n\nThe resolution procedure for these column sets is as follows:\n\n\n\n\nFirst column resolution:\n\n\nEach bare \ncolumn name\n MUST be a column of the entity set denoted by \nparent path\n;\n\n\nEach qualified name pair \ntable name\n \n:\n \ncolumn name\n MUST be a column in a table instance within \nparent path\n if \ntable name\n is bound as an alias in \nparent path\n (see following sub-section on table instance aliases);\n\n\nEach qualified name pair \ntable name\n \n:\n \ncolumn name\n MUST be a column in a table known unambiguously by \ntable name\n if \ntable name\n is not bound as an alias in \nparent path\n;\n\n\nEach qualified name triple \nschema name\n \n:\n \ntable name\n \n:\n \ncolumn name\n MUST be a column within a table in the catalog.\n\n\nEndpoint resolution:\n\n\nAll columns in the column set MUST resolve to the same table in the catalog or the same table instance in the \nparent path\n;\n\n\nWhen a sequence of more than one \ncolumn name\n is presented, the second and subsequent column names MAY be unqualified and are resolved first to the table associated with the first (possibly qualified) \ncolumn name\n in the sequence.\n\n\nThe set of columns MUST comprise either a foreign key or a key in their containing table but not both.\n\n\nLink resolution:\n\n\nIf the endpoint is a key or foreign key in a table in the catalog, that endpoint MUST unambiguously participate in exactly one link between that table and the entity set denoted by \nparent path\n;\n\n\nIf the endpoint is a key or foreign key of a table instance in \nparent path\n (whether referenced by alias-qualified or unqualified column names), that endpoint MUST unambiguously participate in exactly one link between that table instance and exactly one table in the catalog.\n\n\n\n\nThe path extended with an entity link element denotes the entities of a new table drawn from the catalog and joined to the existing entities in \nparent path\n, with the default entity context of the extended path being the newly joined (i.e. right-most) table instance.\n\n\nLinkage by Explicit Column Mapping\n\uf0c1\n\n\nWhen one endpoint is not sufficient to unambiguously select path linkage, a fully explicit join condition can be specified as a sequence of left-hand columns which are equated to a corresponding sequence of right-hand columns:\n\n\n\n\nparent path\n \n/(\n \nleft column name\n \n,\n ... \n)=(\n \nright table name\n \n:\n \nright column name\n \n,\n ... \n)\n\n\nparent path\n \n/(\n \nleft column name\n \n,\n ... \n)=(\n \nright schema name\n \n:\n \nright table name\n \n:\n \nright column name\n \n,\n ... \n)\n\n\n\n\nThis notation requires that the \nleft hand column\n list resolve from \nparent path\n and the \nright hand column\n list resolve from a table found in the model. This notation resolves the first and subsequent columns of each list as per the preceding column resolution rule. However, it relaxes the other endpoint and link resolution rules. Because it fully expresses an unambiguous join condition, it does not require a corresponding foreign key reference link to be found in the catalog model.  For a hypothetical join condition:\n\n\n\n\nparent path\n \n/(L1,L2,L3)=(T:R1,R2,R3)\n\n\n\n\nThe indicated join condition corresponds to the SQL \nL1 = T.R1 AND L2 = T.R2 AND L3 = T.R3\n. Each positional \nleft column\n and \nright column\n MUST have compatible types in order for their values to be tested for equality.\n\n\nOuter-Join Linkage by Column Mapping\n\uf0c1\n\n\nWith the preceding notation, an optional join type is also allowed as a prefix to the column mapping notation:\n\n\n\n\nparent path\n \n/left(\n \nleft columns\n ... \n)=(\n \nright columns\n ... \n)\n\n\nparent path\n \n/right(\n \nleft columns\n ... \n)=(\n \nright columns\n ... \n)\n\n\nparent path\n \n/full(\n \nleft columns\n ... \n)=(\n \nright columns\n ... \n)\n\n\n\n\nThese three keywords \nleft\n, \nright\n, and \nfull\n denote a \"left outer join\", \"right outer join\", or \"full outer join\", respectively. When no such keyword is present, the default join type is an \"inner join\". Presently, the outer-join modes are only available with fully explicit column mapping notation.\n\n\nTable Instance Aliases\n\uf0c1\n\n\nThe root element or an entity link element may be decorated with an alias prefix:\n\n\n\n\nalias\n \n:=\n \ntable name\n\n\nparent path\n \n/\n \nalias\n \n:=\n \ntable name\n\n\nparent path\n \n/\n \nalias\n \n:=(\n \ncolumn name\n, ... \n)\n\n\n\n\nThis denotes the same entity set as the plain element but also binds the \nalias\n as a way to reference a particular table instance from other path elements to the right of the alias binding. All aliases bound in a single path must be distinct. The alias can form a convenient short-hand to avoid repeating long table names, and also enables expression of more complex concepts not otherwise possible.\n\n\nPath Context Reset\n\uf0c1\n\n\nA path can be modified by resetting its denoted entity context:\n\n\n\n\nparent path\n \n/$\n \nalias\n\n\n\n\nwhere \nalias name\n MUST be a table instance alias already bound by an element within \nparent path\n.\n\n\nThis has no effect on the overall joining structure nor filtering of the \nparent path\n but changes the denoted entity set to be that of the aliased table instance. It also changes the column resolution logic to attempt to resolve unqualified column names within the aliased table instance rather than right-most entity link element within \nparent path\n.\n\n\nA path can chain a number of entity link elements from left to right to form long, linear joining structures. With the use of path context resets, a path can also form tree-shaped joining structures, i.e. multiple chains of links off a single ancestor table instance within the \nparent path\n.  It can also be used to \"invert\" a tree to have several joined structures augmenting the final entity set denoted by the whole path.\n\n\nFilter Language\n\uf0c1\n\n\nThe \nfilter element\n of data paths uses a general filter language described here. There are unary and binary filter predicates, logical combinations, negation, and parenthetic grouping. Together, these language elements allow arbitrarily complex boolean logic functions to be expressed directly, in \nconjunctive normal form\n, or in \ndisjunctive normal form\n.\n\n\nThe operator precedence is as follows:\n\n\n\n\nParenthetic grouping overrides precedence, causing the expression inside the parenthetic group to be evaluated and its result used as the value of the parenthetic group.\n\n\nNegation has the highest precedence, negating the immediately following predicate or parenthetic group.\n\n\nConjunction using the \n operator has the next highest precedence, combining adjacent parenthetic groups, negated predicates, predicates, and conjunctions.\n\n\nDisjunction using the \n;\n operator has the next highest precedence, combining adjacent parenthetic groups, negated predicates, predicated, conjunctions, and disjunctions.\n\n\nThe path separator \n/\n has the lowest precedence, adding complete logical expressions to a path.\n\n\n\n\nUnary Filter Predicate\n\uf0c1\n\n\nA unary predicate has the form:\n\n\n\n\ncolumn reference\n \noperator\n\n\n\n\nThere is currently only one unary operator, \n::null::\n, which evaluates True if and only if the column is NULL for the row being tested.\n\n\nBinary Filter Predicate\n\uf0c1\n\n\nA binary predicate as the form:\n\n\n\n\ncolumn reference\n \noperator\n \nliteral value\n\n\n\n\n\n\n\n\n\n\noperator\n\n\nmeaning\n\n\nnotes\n\n\n\n\n\n\n\n\n\n\n=\n\n\ncolumn equals value\n\n\n\n\n\n\n\n\n::lt::\n\n\ncolumn less than value\n\n\n\n\n\n\n\n\n::leq::\n\n\ncolumn less than or equal to value\n\n\n\n\n\n\n\n\n::gt::\n\n\ncolumn greater than value\n\n\n\n\n\n\n\n\n::geq::\n\n\ncolumn greater than or equal to value\n\n\n\n\n\n\n\n\n::regexp::\n\n\ncolumn matches regular expression value\n\n\nalso allowed on \n*\n free-text psuedo column\n\n\n\n\n\n\n::ciregexp::\n\n\ncolumn matches regular expression value case-insensitively\n\n\nalso allowed on \n*\n free-text psuedo column\n\n\n\n\n\n\n::ts::\n\n\ncolumn matches text-search query value\n\n\nalso allowed on \n*\n free-text psuedo column\n\n\n\n\n\n\n\n\nNegated Filter\n\uf0c1\n\n\nAny predicate or parenthetic filter may be prefixed with the \n!\n negation operator to invert its logical value:\n\n\n\n\n!\n \npredicate\n\n\n!\n \n(\n \nlogical expression\n \n)\n\n\n\n\nThe negation operator has higher precedence than conjunctive or disjunctive operators, meaning it negates the nearest predicate or parenthetic expression on the right-hand side before logical operators apply.\n\n\nParenthetic Filter\n\uf0c1\n\n\nAny predicate, conjunction, or disjunction may be wrapped in parentheses to override any implicit precedence for logical composition:\n\n\n\n\n(\n \nlogical expression\n \n)\n\n\n\n\nConjunctive Filter\n\uf0c1\n\n\nA conjunction (logical AND) uses the \n separator: \n\n\n\n\npredicate\n \n \nconjunction\n\n\npredicate\n \n \npredicate\n\n\npredicate\n \n \n!\n \npredicate\n\n\npredicate\n \n \n(\n \nlogical expression\n \n)\n\n\npredicate\n \n \n!\n \n(\n \nlogical expression\n \n)\n\n\n\n\nIndividual filter elements in the path are also conjoined (logical AND), but the path separator \n/\n cannot appear in a parenthetic group. \n\n\nDisjunctive Filter\n\uf0c1\n\n\nA disjunction (logical OR) uses the \n;\n separator:\n\n\n\n\npredicate\n \n;\n \ndisjunction\n\n\npredicate\n \n;\n \nconjunction\n\n\npredicate\n \n;\n \npredicate\n\n\npredicate\n \n;\n \n!\n \npredicate\n\n\npredicate\n \n;\n \n(\n \nlogical expression\n \n)\n\n\npredicate\n \n;\n \n!\n \n(\n \nlogical expression\n \n)\n\n\n\n\nConjunctive Normal Form\n\uf0c1\n\n\nA filter in conjunctive normal form (CNF) is a conjunction of disjunctions over a set of possibly negated predicate terms. To write a CNF filter in a data resource name, use a sequence of filter path elements, separated by \n/\n, to express the top-level conjunction.  Use the disjunction separator \n;\n and optional negation prefix \n!\n on individual predicate terms in each disjunctive clause.\n\n\nDisjunctive Normal Form\n\uf0c1\n\n\nA filter in disjunctive normall form (DNF) is a disjunction of conjunctions over a set of possibly negated predicate terms. To write a DNF filter in a data resource name, use a single filter path element using the \n;\n separator to express the top-level disjunction. Use the conjunction separator \n and optional negation prefix \n!\n on individual predicate terms in each conjunctive clause.\n\n\nSort Modifier\n\uf0c1\n\n\nAn optional sorting modifier can modify the ordering of elements in the set-based resources denoted by \nentity\n, \nattribute\n, and \nattributegroup\n resource names. This modifier applies sorting based on output columns available in the set-based resource representation and may increase service cost significantly. The modifier has the form:\n\n\n\n\n@sort(\n \noutput column\n \n,\n ... \n)\n\n\n@sort(\n \noutput column\n \n::desc::\n \n,\n ... \n)\n\n\n\n\nwhere the optional \n::desc::\n direction indicator can apply a descending sort to that sort key to override the default ascending sort order. ERMrest by default sorts equivalently to the SQL sort order \nASC NULLS LAST\n (ascending, with NULLs after non-NULLs) and switches to \nDESC NULLS FIRST\n (descending, with NULLs before non-NULLs) when the \n::desc::\n direction is selected.\n\n\nThe list of sort keys goes left-to-right from primary to secondary etc.  The individual \noutput column\n names are user-supplied values and therefore must be URL-escaped if they contain any special characters, including the \n:\n character in implicitly named output columns introduced using the \nalias\n \n:\n \n*\n wildcard syntax in projected \nattribute names\n or \naggregate names\n.\n\n\nThe modifier appears as an optional suffix to data names, but before any query parameters in the URL:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n\n\nEach \nsort key\n MUST be a column name in the denoted entities since no column renaming is supported in \nentity\n resources.\n\n\nThe sort modifies the order of the entity records in the external representation.\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \nprojection\n \n,\n ... \n@sort(\n \nsort key\n \n,\n ... \n)\n\n\nEach \nsort key\n MUST refer to a column in the external representation, i.e. after any renaming has been applied.\n\n\nThe sort modifies the order of the entity records in the external representation.\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \nprojection\n \n,\n ... \n@sort(\n \nsort key\n \n,\n ... \n)\n\n\nEach \nsort key\n MUST refer to a column in the external representation, i.e. after any renaming has been applied.\n\n\nThe sort modifies the order of the group records in the external representation, i.e. groups are sorted after aggregation has occurred. Sorting by a \nprojection\n value means sorting by a computed aggregate or an arbitrarily chosen example value when projecting bare columns.\n\n\n\n\nThe sort modifier is only meaningful on retrieval requests using the \nGET\n method described in \nData Operations\n.\n\n\nPaging Modifiers\n\uf0c1\n\n\nOptional paging modifiers can designate results that come \nbefore\n or \nafter\n a designated page key in a sorted sequence. A page key is a vector of values taken from a row that falls outside the page, with one component per field in the sort modifier.\n\n\nThe modifier MUST be accompanied by a sort modifier to define the ordering of rows in the result set as well as the ordering of fields of the page key vector. The paging modifiers support a special symbol \n::null::\n to represent a NULL column value in a page key. For determinism, page keys SHOULD include a non-null, unique key as the least significant key.\n\n\nSupported combinations:\n\n\n\n\n\n\n\n\n@after(...)\n\n\n@before(...)\n\n\n?limit\n\n\nResult set\n\n\n\n\n\n\n\n\n\n\nK1\n\n\nabsent\n\n\nabsent\n\n\nAll records \nafter\n \nK1\n\n\n\n\n\n\nK1\n\n\nabsent\n\n\nN\n\n\nFirst records \nafter\n \nK1\n limited by page size\n\n\n\n\n\n\nK1\n\n\nK2\n\n\nN\n\n\nFirst records \nafter\n \nK1\n limited by page size or \nK2\n whichever is smaller\n\n\n\n\n\n\nK1\n\n\nK2\n\n\nabsent\n\n\nAll records \nbetween\n \nK1\n and \nK2\n\n\n\n\n\n\nabsent\n\n\nK2\n\n\nN\n\n\nLast records \nbefore\n \nK2\n limited by page size\n\n\n\n\n\n\n\n\nBefore Modifier\n\uf0c1\n\n\nThe \n@before\n modifier designates a result set of rows immediately antecedent to the encoded page key, unless combined with the \n@after\n modifier:\n\n\n\n\n@sort(\n \noutput column\n ...\n)@before(\n \n,\n ... \n)\n (i.e. empty string)\n\n\n@sort(\n \noutput column\n ...\n)@before(\n \nvalue\n \n,\n ... \n)\n (i.e. literal string)\n\n\n@sort(\n \noutput column\n ...\n)@before(\n \n::null::\n \n,\n ... \n)\n (i.e. NULL)\n\n\n\n\nFor each comma-separated output column named in the sort modifier, the corresponding comma-separated value represents a component in the page key vector. The denoted result MUST only include rows which come \nimmediately before\n the page key according to the sorted sequence semantics (including ascending/descending direction). This means that at the time of evaluation, no rows exist between the returned set and the row identified by the page key vector.\n\n\nThe \n@before\n modifier MUST be combined with the \n@after\n modifier and/or the \n?limit=N\n query parameter.\n\n\nAfter Modifier\n\uf0c1\n\n\nThe \n@after\n modifier designates a result set of rows immediately subsequent to the encoded page key:\n\n\n\n\n@sort(\n \noutput column\n ...\n)@after(\n \n,\n ... \n)\n (i.e. empty string)\n\n\n@sort(\n \noutput column\n ...\n)@after(\n \nvalue\n \n,\n ... \n)\n (i.e. literal string)\n\n\n@sort(\n \noutput column\n ...\n)@after(\n \n::null::\n \n,\n ... \n)\n (i.e. NULL)\n\n\n\n\nFor each comma-separated output column named in the sort modifier, the corresponding comma-separated value represents a component in the page key vector. The denoted result MUST only include rows which come \nimmediately after\n the page key according to the sorted sequence semantics (including ascending/descending direction). This means that at the time of evaluation, no rows exist between the returned set and the row identified by the page key vector.\n\n\nThe \n@after\n modifier MAY be combined with the \n@before\n modifier and/or the \n?limit=N\n query parameter.\n\n\nAccept Query Parameter\n\uf0c1\n\n\nAn optional \naccept\n query parameter can override the \nAccept\n HTTP header and content-negotiation in data access:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n ... \n?accept=\n \nt\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \nprojection\n  ... \n?accept=\n \nt\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n  \n;\n \nprojection\n  ... \n?accept=\n \nt\n\n\nservice\n \n/catalog/\n \ncid\n \n/aggregate/\n \npath\n \n/\n \nprojection\n ... \n?accept=\n \nt\n\n\n\n\nIf the specified MIME content-type \nt\n is one of those supported by the data API, it is selected in preference to normal content-negotiation rules. Otherwise, content-negotiation proceeds as usual. Two short-hand values are recognized:\n\n\n\n\naccept=csv\n is interpreted as \naccept=text%2Fcsv\n\n\naccept=json\n is interpreted as \naccept=application%2Fjson\n\n\n\n\nNote that the content-type \nt\n MUST be URL-escaped to protect the \n/\n character unless using the short-hands above.\n\n\nDownload Query Parameter\n\uf0c1\n\n\nAn optional \ndownload\n query parameter can activate a \nContent-Disposition: attachment\n response header for GET operations on data resources.\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n ... \n?download=\n \nbn\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \nprojection\n  ... \n?download=\n \nbn\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n  \n;\n \nprojection\n  ... \n?download=\n \nbn\n\n\nservice\n \n/catalog/\n \ncid\n \n/aggregate/\n \npath\n \n/\n \nprojection\n ... \n?download=\n \nbn\n\n\n\n\nThe specified file base-name \nbn\n MUST be non-empty and SHOULD NOT include a file-extension suffix to indicate the download file type. The \nbn\n, when URL-decoded, MUST be a valid UTF-8 string. The service SHOULD append an appropriate suffix based on the negotiated response content type, e.g. \n.json' or\n.csv`.\n\n\nAs an example:\n\n\nGET /ermrest/catalog/1/entity/MyTable?download=My%20File\n\n\n\nwill produce a response like:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: 3\nContent-Disposition: attachment; download*=UTF-8''My%20File.json\n\n[]\n\n\n\nwhich the browser will interpret to suggest a local filename such as \nMy File.json\n.\n\n\nDefaults Query Parameter\n\uf0c1\n\n\nAn optional \ndefaults\n query parameter can be used with the \nPOST\n operation on the \nentity\n API:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \nschema name\n \n:\n \ntable name\n \n?defaults=\n \ncolumn name\n \n,\n ...\n\n\n\n\nA list of one or more \ncolumn name\n indicates columns of the target table which should be populated using server-assigned defaults values, ignoring any values provided by the client. See the \nEntity Creation with Defaults\n operation documentation for more explanation.\n\n\nLimit Query Parameter\n\uf0c1\n\n\nAn optional \nlimit\n query parameter can truncate the length of set-based resource representations denoted by \nentity\n, \nattribute\n, and \nattributegroup\n resource names:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \nprojection\n \n,\n ... \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \nprojection\n \n,\n ... \n@sort(\n \nsort key\n \n,\n ... \n)\n \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \nprojection\n \n,\n ... \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \nprojection\n \n,\n ... \n@sort(\n \nsort key\n \n,\n ... \n)\n \n?limit=\n \nn\n\n\n\n\nIf the set denoted by the resource name (without the limit modifier) has \nk\n elements, the denoted limited subset will have \nn\n members if \nn\n \n \nk\n and will otherwise have all \nk\n members. When combined with a sort modifier, the first \nn\n members will be returned, otherwise an arbitrary subset will be chosen.\n\n\nThe \nlimit\n query parameter is only meaningful on retrieval requests using the \nGET\n method described in \nData Operations\n.\n\n\nData Paging\n\uf0c1\n\n\nThe \nsort modifier\n, \nlimit parameter\n, and \npaging modifers\n can be combined to express paged access to set-based data resources:\n\n\n\n\nThe sort order defines a stable sequence of set elements.\n\n\nThe paging modifiers select set elements following (or preceding) the last-visited element.\n\n\nThe limit parameter defines the number of set elements in the retrieved page.\n\n\n\n\nThis allows sequential paging or scrolling of large result sets with reversing/rewind to earlier pages. Because ERMrest supports concurrent retrieval and modification of data resources by multiple clients, it is not sensible to randomly access set elements by stream position offsets (whether by element or page count) because you might skip or repeat elements if preceding elements have been inserted or removed from the sequence in between page requests. \n\n\nA client can choose an arbitrary application-oriented sort order with paging. However, the client SHOULD include row-level unique key material in the sort and page key to avoid hazards of missing rows that have identical sorting rank due to non-unique page keys. This can be achieved by appending unique key columns to the application sort as the lowest precedence sort criteria, i.e. sort first by an interesting but non-unique property and then finally break ties by a unique serial ID or similar property.\n\n\n\n\nFetch first page:\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n \n?limit=\n \nn\n\n\nFetch subsequent page by encoding a page key projected from the \nlast\n row of the preceding page:\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n \n@after(\n \nlimit value\n \n,\n ...\n)\n \n?limit=\n \nn\n\n\nFetch antecedent page by encoding a page key projected from the \nfirst\n row of the subsequent page:\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n \n@before(\n \nlimit value\n \n,\n ...\n)\n \n?limit=\n \nn\n\n\n\n\nRealize that a sequence of forward and backward page requests through a dataset might not land on the same page boundaries on both visits!\n\n\n\n\nRows might be inserted during a traversal. An inserted row MAY appear in the traversal or MAY be skipped depending on where it falls in the sorted sequence.\n\n\nRows might be deleted during a traversal. A deleted row MAY appear in the traversal or MAY be skipped depending on where it falls in the sorted sequence.\n\n\nRows might be mutated such that they change positions in the sorted sequence during a traversal. A mutated table row contains one tuple of data before the mutation and another tuple of data after. A single traversal concurrent with that mutation MAY encounter zero, one, or two copies of the row depending on where they fall in the sorted sequence.", 
            "title": "ERMrest Data Resource Naming"
        }, 
        {
            "location": "/api-docs/data/naming/#ermrest-data-resource-naming", 
            "text": "The  ERMrest  data resource names always have a common structure:   service   /catalog/   cid   /   api   /   path  service   /catalog/   cid   /   api   /   path   suffix  service   /catalog/   cid   /   api   /   path   suffix   ?   query parameters   where the components in this structure are:   service : the ERMrest service endpoint such as  https://www.example.com/ermrest .  cid : the catalog identifier for one dataset such as  42 .  api : the API or data resource space identifier such as  entity ,  attribute ,  attributegroup , or  aggregate .  path : the data path which identifies one filtered entity set with optional joined context.  suffix : additional content that depends on the  api  the group keys associated with  attributegroup  resources  the projection associated with  attribute ,  attributegroup , and  aggregate  resources  query parameters : optional parameters which may affect interpretation of the data name", 
            "title": "ERMrest Data Resource Naming"
        }, 
        {
            "location": "/api-docs/data/naming/#entity-names", 
            "text": "The  entity  resource space denotes whole entities using names of the form:   service   /catalog/   cid   /entity/   path   The primary naming convention, without query parameters, denotes the final entity set referenced by  path , as per the  data path rules . The denoted entity set has the same tuple structure as the final table instance in  path  and may be a subset of the entities based on joining and filtering criteria encoded in  path . The set of resulting tuples are distinct according to the key definitions of that table instance, i.e. any joins in the path may be used to filter out rows but do not cause duplicate rows.", 
            "title": "Entity Names"
        }, 
        {
            "location": "/api-docs/data/naming/#attribute-names", 
            "text": "The  attribute  resource space denotes projected attributes of entities using names of the form:   service   /catalog/   cid   /attribute/   path   /   column reference   ,  ...   The  path  is interpreted identically to the  entity  resource space. However, rather than denoting a set of whole entities, the  attribute  resource space denotes specific fields  projected  from that set of entities.  The projected  column reference  list elements can be in one of several forms:   [  out alias   :=  ]  column name  A field is projected from the final table instance of  path .  An optional  out alias  can be assigned to rename the output column, and by default the output column will be named by the unqualified  column name .  *  A wildcard that expands to all of the columns from the final table instance of  path .  The output columns are automatically named by their unqualified column names.  [  out alias   :=  ]  alias   :   column name  A field is projected from a table instance bound to  alias  in  path .  An optional  out alias  can be assigned to rename the output column, and by default the output column will be named by the unqualified  column name .  alias   :   *  A wildcard that expands to all of the columns from a table instance bound to  alias  in  path .  The output columns are automatically named by their  alias  qualified column names to prevent collisions between the multiple wildcard-expansions that are possible within one complex  path . If a projection  A:*  is used for a table instance with a column named  foo  in it, the output data will then have a column with the literal name  A:foo . Special attention must be paid when trying to reference such columns using the  sort modifier , as this modifier uses the output name  A:foo  as a user-supplied literal and therefore the  :  must be escaped as in  @sort(A%3Afoo) .   Like in the  entity  resource space, joined tables may cause filtering but not duplication of rows in the final entity set. Thus, when projecting fields from aliased table instances in  path , values are arbitrarily selected from one of the joined contextual rows if more than one such row was joined to the same final entity.", 
            "title": "Attribute Names"
        }, 
        {
            "location": "/api-docs/data/naming/#aggregate-names", 
            "text": "The  aggregate  resource space denotes computed (global) aggregates using names of the form:   service   /catalog/   cid   /aggregate/   path   /   aggregate   ,  ...   The  path  is interpreted slightly differently than in the  attribute  resource space. Rather than denoting a set of entities drawn from the final table instance in  path , it denotes a set of entity combinations, meaning that there is a potential for a combinatoric number of intermediate records depending on how path entity elements are linked. This denoted set of entity combinations is reduced to a single  aggregate  tuple. The computed  aggregate  tuple elements can be in one of several forms:   out alias   :=   function   (   column name   )  out alias   :=   function   (*)  out alias   :=   function   (   in alias   :   column name   )  out alias   :=   function   (   in alias   :   *   )   The  out alias  is the name given to the computed field. The  function  is one of a limited set of aggregate functions supported by ERMrest:   min : the minimum non-NULL value (or NULL)  max : the maximum non-NULL value (or NULL)  cnt_d : the count of distinct non-NULL values  cnt : the count of non-NULL values  array : an array containing all values (including NULL)   These aggregate functions are evaluated over the set of values projected from the entity set denoted by  path . The same column resolution rules apply as in other projection lists: a bare  column name  MUST reference a column of the final entity set while an alias-qualified column name MUST reference a column of a table instance bound to  alias  in the  path .  As a special case, the psuedo-column  *  can be used in several idiomatic forms:   cnt(*) : a count of entities rather than of non-NULL values is computed  array( alias :*) : an array of records rather than an array of values is computed   TODO: document other variants?", 
            "title": "Aggregate Names"
        }, 
        {
            "location": "/api-docs/data/naming/#attribute-group-names", 
            "text": "The  attributegroup  resource space denotes groups of entities by arbitrary grouping keys and computed (group-level) aggregates using names of the form:   service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...  service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...  ;   aggregate   ,  ...   The  path  is interpreted slightly differently than in the  attribute  resource space. Rather than denoting a set of entities drawn from the final table instance in  path , it denotes a set of entity combinations, meaning that there is a potential for a combinatoric number of records depending on how path entity elements are linked. This denoted set of entity combinations is reduced to groups where each group represents a set of entities sharing the same  group key  tuple, and optional  aggregate  list elements are evaluated over this set of entities to produce a group-level aggregate value.  The  group key  list elements use the same notation as the  column reference  elements in the  attribute  resource space. The  aggregate  list elements use the same notation as the  aggregate  elements in the  aggregate  resource space or the  column reference  elements in the  attribute  resource space. An  aggregate  using  column reference  notation denotes an example value chosen from an arbitrary member of each group.", 
            "title": "Attribute Group Names"
        }, 
        {
            "location": "/api-docs/data/naming/#attribute-binning", 
            "text": "In order to group numerical values into bins, e.g. for histogram presentation, a special  binning  operator is allowed in attribute or group key projections in place of a bare column reference:   bin(   column name   ;   nbins   ;   minval   ;   maxval   )  bin(   in alias   :   column name   ;   nbins   ;   minval   ;   maxval   )   The binning operator determines which bucket the value in  column name  belongs to, dividing the requested range from  minval  (inclusive) to  maxval  (exclusive) into  nbins  equal-width intervals. The result is always a three-element JSON array  [   bucket   ,   lower   ,   upper   ]  describing the bucket.   bucket : The bin number which the value falls into.  null : The  null  bin captures all NULL values.  0: The zero bin captures all values below the requested range.  1: The first bin in the requested range.  nbins : The last bin in the requested range.  bins  + 1: The final bin captures all values above the requested range.    lower : The lower bound (inclusive) of the bin, or  null .  upper : The upper bound (exclusive) of the bin, or  null .   If the client does not wish to consider NULL or out-of-range values, they MAY include an appropriate filter to exclude those rows from the query.  A useful idiom is to use binning as a group-key in the  attributegroup  API with  cnt(*)  to count all matching rows within each bin. The results will be sparse: only bins with a non-zero row count will appear as grouped output rows. The sort modifier MAY be applied to the binning group key.  Supported Column Types for Binning \uf0c1  The binning operator is only supported for certain basic column storage types:   date  float4 ,  float8  int2 ,  int4 ,  int8  numeric  timestamptz ,  timestamp", 
            "title": "Attribute Binning"
        }, 
        {
            "location": "/api-docs/data/naming/#data-paths", 
            "text": "ERMrest introduces a general path-based syntax for naming data resources with idioms for navigation and filtering of entity sets. The  path  element of the data resource name always denotes a set of entities or joined entities.  The path must be interpreted from left to right in order to understand its meaning. The denoted entity set is understood upon reaching the right-most element of the path and may be modified by the resource space or  api  under which the path occurs.  Path Root \uf0c1  A path always starts with a direct table reference:   table name  schema name   :   table name   which must already be defined in the catalog under the corresponding model resource:   /schema/   schema name   /table/   table name   The unqualified  table name  MAY be used in a path if it is the only occurrence of that table name across all schemata in the catalog, i.e. only if it is unambiguous.  A path consisting of only one table reference denotes the entities within that table.  Path Filters \uf0c1  A filter element can augment a path with a filter expression:   parent path   /   filter   after which the combined path denotes a filtered subset of the entities denoted by  parent path  where the  filter  expressed in the  filter language  evaluates to a true value.  The accumulative affect of several filter path elements is a logical conjunction of all the filtering criteria in those elements. It is also intuitive to think of a chain of filter elements as a filtering pipeline or sieve, each eliminating data which does not match the filter criteria.  Entity Links \uf0c1  An entity link element can augment a path with an additional related or joined table:   parent path   /   table name  parent path   /   schema name   :   table name   as in the path root,  table name  may be explicitly schema qualified or left unqualified if it is unambiguous within the catalog. In order for this basic table link element to be valid, there must be at least one foreign-key relationship linking the entity set denoted by  parent path  and the table denoted by  table name . The links may point in either direction, i.e. the  parent path  entity set may contain foreign keys which reference  table name  or  table name  may contain foreign keys which reference the  parent path  entities.  When there are multiple possible linkages to choose from, the link is formed using the disjunction of all applicable link conditions.  Linkage by Foreign-Key Endpoint \uf0c1  A more precise entity link element can choose one link condition by identifying an endpoint of the linkage as a set of columns:   parent path   /(   column name   ,  ...  )  parent path   /(   table name   :   column name   ,  ...  )  parent path   /(   schema name   :   table name   :   column name   ,  ...  )   This set of columns MUST comprise either a primary key or a foreign key which unambiguously identifies a single possible linkage between the  parent path  and a single possible linked entity table. As a convenience, the  schema name  and  table name  need not be repeated for additional  column name  elements in the list after the first one; each unqualified  column name  will be resolved against the same table as the first  column name  in the sequence.  The resolution procedure for these column sets is as follows:   First column resolution:  Each bare  column name  MUST be a column of the entity set denoted by  parent path ;  Each qualified name pair  table name   :   column name  MUST be a column in a table instance within  parent path  if  table name  is bound as an alias in  parent path  (see following sub-section on table instance aliases);  Each qualified name pair  table name   :   column name  MUST be a column in a table known unambiguously by  table name  if  table name  is not bound as an alias in  parent path ;  Each qualified name triple  schema name   :   table name   :   column name  MUST be a column within a table in the catalog.  Endpoint resolution:  All columns in the column set MUST resolve to the same table in the catalog or the same table instance in the  parent path ;  When a sequence of more than one  column name  is presented, the second and subsequent column names MAY be unqualified and are resolved first to the table associated with the first (possibly qualified)  column name  in the sequence.  The set of columns MUST comprise either a foreign key or a key in their containing table but not both.  Link resolution:  If the endpoint is a key or foreign key in a table in the catalog, that endpoint MUST unambiguously participate in exactly one link between that table and the entity set denoted by  parent path ;  If the endpoint is a key or foreign key of a table instance in  parent path  (whether referenced by alias-qualified or unqualified column names), that endpoint MUST unambiguously participate in exactly one link between that table instance and exactly one table in the catalog.   The path extended with an entity link element denotes the entities of a new table drawn from the catalog and joined to the existing entities in  parent path , with the default entity context of the extended path being the newly joined (i.e. right-most) table instance.  Linkage by Explicit Column Mapping \uf0c1  When one endpoint is not sufficient to unambiguously select path linkage, a fully explicit join condition can be specified as a sequence of left-hand columns which are equated to a corresponding sequence of right-hand columns:   parent path   /(   left column name   ,  ...  )=(   right table name   :   right column name   ,  ...  )  parent path   /(   left column name   ,  ...  )=(   right schema name   :   right table name   :   right column name   ,  ...  )   This notation requires that the  left hand column  list resolve from  parent path  and the  right hand column  list resolve from a table found in the model. This notation resolves the first and subsequent columns of each list as per the preceding column resolution rule. However, it relaxes the other endpoint and link resolution rules. Because it fully expresses an unambiguous join condition, it does not require a corresponding foreign key reference link to be found in the catalog model.  For a hypothetical join condition:   parent path   /(L1,L2,L3)=(T:R1,R2,R3)   The indicated join condition corresponds to the SQL  L1 = T.R1 AND L2 = T.R2 AND L3 = T.R3 . Each positional  left column  and  right column  MUST have compatible types in order for their values to be tested for equality.  Outer-Join Linkage by Column Mapping \uf0c1  With the preceding notation, an optional join type is also allowed as a prefix to the column mapping notation:   parent path   /left(   left columns  ...  )=(   right columns  ...  )  parent path   /right(   left columns  ...  )=(   right columns  ...  )  parent path   /full(   left columns  ...  )=(   right columns  ...  )   These three keywords  left ,  right , and  full  denote a \"left outer join\", \"right outer join\", or \"full outer join\", respectively. When no such keyword is present, the default join type is an \"inner join\". Presently, the outer-join modes are only available with fully explicit column mapping notation.  Table Instance Aliases \uf0c1  The root element or an entity link element may be decorated with an alias prefix:   alias   :=   table name  parent path   /   alias   :=   table name  parent path   /   alias   :=(   column name , ...  )   This denotes the same entity set as the plain element but also binds the  alias  as a way to reference a particular table instance from other path elements to the right of the alias binding. All aliases bound in a single path must be distinct. The alias can form a convenient short-hand to avoid repeating long table names, and also enables expression of more complex concepts not otherwise possible.  Path Context Reset \uf0c1  A path can be modified by resetting its denoted entity context:   parent path   /$   alias   where  alias name  MUST be a table instance alias already bound by an element within  parent path .  This has no effect on the overall joining structure nor filtering of the  parent path  but changes the denoted entity set to be that of the aliased table instance. It also changes the column resolution logic to attempt to resolve unqualified column names within the aliased table instance rather than right-most entity link element within  parent path .  A path can chain a number of entity link elements from left to right to form long, linear joining structures. With the use of path context resets, a path can also form tree-shaped joining structures, i.e. multiple chains of links off a single ancestor table instance within the  parent path .  It can also be used to \"invert\" a tree to have several joined structures augmenting the final entity set denoted by the whole path.", 
            "title": "Data Paths"
        }, 
        {
            "location": "/api-docs/data/naming/#filter-language", 
            "text": "The  filter element  of data paths uses a general filter language described here. There are unary and binary filter predicates, logical combinations, negation, and parenthetic grouping. Together, these language elements allow arbitrarily complex boolean logic functions to be expressed directly, in  conjunctive normal form , or in  disjunctive normal form .  The operator precedence is as follows:   Parenthetic grouping overrides precedence, causing the expression inside the parenthetic group to be evaluated and its result used as the value of the parenthetic group.  Negation has the highest precedence, negating the immediately following predicate or parenthetic group.  Conjunction using the   operator has the next highest precedence, combining adjacent parenthetic groups, negated predicates, predicates, and conjunctions.  Disjunction using the  ;  operator has the next highest precedence, combining adjacent parenthetic groups, negated predicates, predicated, conjunctions, and disjunctions.  The path separator  /  has the lowest precedence, adding complete logical expressions to a path.   Unary Filter Predicate \uf0c1  A unary predicate has the form:   column reference   operator   There is currently only one unary operator,  ::null:: , which evaluates True if and only if the column is NULL for the row being tested.  Binary Filter Predicate \uf0c1  A binary predicate as the form:   column reference   operator   literal value      operator  meaning  notes      =  column equals value     ::lt::  column less than value     ::leq::  column less than or equal to value     ::gt::  column greater than value     ::geq::  column greater than or equal to value     ::regexp::  column matches regular expression value  also allowed on  *  free-text psuedo column    ::ciregexp::  column matches regular expression value case-insensitively  also allowed on  *  free-text psuedo column    ::ts::  column matches text-search query value  also allowed on  *  free-text psuedo column     Negated Filter \uf0c1  Any predicate or parenthetic filter may be prefixed with the  !  negation operator to invert its logical value:   !   predicate  !   (   logical expression   )   The negation operator has higher precedence than conjunctive or disjunctive operators, meaning it negates the nearest predicate or parenthetic expression on the right-hand side before logical operators apply.  Parenthetic Filter \uf0c1  Any predicate, conjunction, or disjunction may be wrapped in parentheses to override any implicit precedence for logical composition:   (   logical expression   )   Conjunctive Filter \uf0c1  A conjunction (logical AND) uses the   separator:    predicate     conjunction  predicate     predicate  predicate     !   predicate  predicate     (   logical expression   )  predicate     !   (   logical expression   )   Individual filter elements in the path are also conjoined (logical AND), but the path separator  /  cannot appear in a parenthetic group.   Disjunctive Filter \uf0c1  A disjunction (logical OR) uses the  ;  separator:   predicate   ;   disjunction  predicate   ;   conjunction  predicate   ;   predicate  predicate   ;   !   predicate  predicate   ;   (   logical expression   )  predicate   ;   !   (   logical expression   )   Conjunctive Normal Form \uf0c1  A filter in conjunctive normal form (CNF) is a conjunction of disjunctions over a set of possibly negated predicate terms. To write a CNF filter in a data resource name, use a sequence of filter path elements, separated by  / , to express the top-level conjunction.  Use the disjunction separator  ;  and optional negation prefix  !  on individual predicate terms in each disjunctive clause.  Disjunctive Normal Form \uf0c1  A filter in disjunctive normall form (DNF) is a disjunction of conjunctions over a set of possibly negated predicate terms. To write a DNF filter in a data resource name, use a single filter path element using the  ;  separator to express the top-level disjunction. Use the conjunction separator   and optional negation prefix  !  on individual predicate terms in each conjunctive clause.", 
            "title": "Filter Language"
        }, 
        {
            "location": "/api-docs/data/naming/#sort-modifier", 
            "text": "An optional sorting modifier can modify the ordering of elements in the set-based resources denoted by  entity ,  attribute , and  attributegroup  resource names. This modifier applies sorting based on output columns available in the set-based resource representation and may increase service cost significantly. The modifier has the form:   @sort(   output column   ,  ...  )  @sort(   output column   ::desc::   ,  ...  )   where the optional  ::desc::  direction indicator can apply a descending sort to that sort key to override the default ascending sort order. ERMrest by default sorts equivalently to the SQL sort order  ASC NULLS LAST  (ascending, with NULLs after non-NULLs) and switches to  DESC NULLS FIRST  (descending, with NULLs before non-NULLs) when the  ::desc::  direction is selected.  The list of sort keys goes left-to-right from primary to secondary etc.  The individual  output column  names are user-supplied values and therefore must be URL-escaped if they contain any special characters, including the  :  character in implicitly named output columns introduced using the  alias   :   *  wildcard syntax in projected  attribute names  or  aggregate names .  The modifier appears as an optional suffix to data names, but before any query parameters in the URL:   service   /catalog/   cid   /entity/   path   @sort(   sort key   ,  ...  )  Each  sort key  MUST be a column name in the denoted entities since no column renaming is supported in  entity  resources.  The sort modifies the order of the entity records in the external representation.  service   /catalog/   cid   /attribute/   path   /   projection   ,  ...  @sort(   sort key   ,  ...  )  Each  sort key  MUST refer to a column in the external representation, i.e. after any renaming has been applied.  The sort modifies the order of the entity records in the external representation.  service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...  ;   projection   ,  ...  @sort(   sort key   ,  ...  )  Each  sort key  MUST refer to a column in the external representation, i.e. after any renaming has been applied.  The sort modifies the order of the group records in the external representation, i.e. groups are sorted after aggregation has occurred. Sorting by a  projection  value means sorting by a computed aggregate or an arbitrarily chosen example value when projecting bare columns.   The sort modifier is only meaningful on retrieval requests using the  GET  method described in  Data Operations .", 
            "title": "Sort Modifier"
        }, 
        {
            "location": "/api-docs/data/naming/#paging-modifiers", 
            "text": "Optional paging modifiers can designate results that come  before  or  after  a designated page key in a sorted sequence. A page key is a vector of values taken from a row that falls outside the page, with one component per field in the sort modifier.  The modifier MUST be accompanied by a sort modifier to define the ordering of rows in the result set as well as the ordering of fields of the page key vector. The paging modifiers support a special symbol  ::null::  to represent a NULL column value in a page key. For determinism, page keys SHOULD include a non-null, unique key as the least significant key.  Supported combinations:     @after(...)  @before(...)  ?limit  Result set      K1  absent  absent  All records  after   K1    K1  absent  N  First records  after   K1  limited by page size    K1  K2  N  First records  after   K1  limited by page size or  K2  whichever is smaller    K1  K2  absent  All records  between   K1  and  K2    absent  K2  N  Last records  before   K2  limited by page size     Before Modifier \uf0c1  The  @before  modifier designates a result set of rows immediately antecedent to the encoded page key, unless combined with the  @after  modifier:   @sort(   output column  ... )@before(   ,  ...  )  (i.e. empty string)  @sort(   output column  ... )@before(   value   ,  ...  )  (i.e. literal string)  @sort(   output column  ... )@before(   ::null::   ,  ...  )  (i.e. NULL)   For each comma-separated output column named in the sort modifier, the corresponding comma-separated value represents a component in the page key vector. The denoted result MUST only include rows which come  immediately before  the page key according to the sorted sequence semantics (including ascending/descending direction). This means that at the time of evaluation, no rows exist between the returned set and the row identified by the page key vector.  The  @before  modifier MUST be combined with the  @after  modifier and/or the  ?limit=N  query parameter.  After Modifier \uf0c1  The  @after  modifier designates a result set of rows immediately subsequent to the encoded page key:   @sort(   output column  ... )@after(   ,  ...  )  (i.e. empty string)  @sort(   output column  ... )@after(   value   ,  ...  )  (i.e. literal string)  @sort(   output column  ... )@after(   ::null::   ,  ...  )  (i.e. NULL)   For each comma-separated output column named in the sort modifier, the corresponding comma-separated value represents a component in the page key vector. The denoted result MUST only include rows which come  immediately after  the page key according to the sorted sequence semantics (including ascending/descending direction). This means that at the time of evaluation, no rows exist between the returned set and the row identified by the page key vector.  The  @after  modifier MAY be combined with the  @before  modifier and/or the  ?limit=N  query parameter.", 
            "title": "Paging Modifiers"
        }, 
        {
            "location": "/api-docs/data/naming/#accept-query-parameter", 
            "text": "An optional  accept  query parameter can override the  Accept  HTTP header and content-negotiation in data access:   service   /catalog/   cid   /entity/   path  ...  ?accept=   t  service   /catalog/   cid   /attribute/   path   /   projection   ...  ?accept=   t  service   /catalog/   cid   /attributegroup/   path   /   group key    ;   projection   ...  ?accept=   t  service   /catalog/   cid   /aggregate/   path   /   projection  ...  ?accept=   t   If the specified MIME content-type  t  is one of those supported by the data API, it is selected in preference to normal content-negotiation rules. Otherwise, content-negotiation proceeds as usual. Two short-hand values are recognized:   accept=csv  is interpreted as  accept=text%2Fcsv  accept=json  is interpreted as  accept=application%2Fjson   Note that the content-type  t  MUST be URL-escaped to protect the  /  character unless using the short-hands above.", 
            "title": "Accept Query Parameter"
        }, 
        {
            "location": "/api-docs/data/naming/#download-query-parameter", 
            "text": "An optional  download  query parameter can activate a  Content-Disposition: attachment  response header for GET operations on data resources.   service   /catalog/   cid   /entity/   path  ...  ?download=   bn  service   /catalog/   cid   /attribute/   path   /   projection   ...  ?download=   bn  service   /catalog/   cid   /attributegroup/   path   /   group key    ;   projection   ...  ?download=   bn  service   /catalog/   cid   /aggregate/   path   /   projection  ...  ?download=   bn   The specified file base-name  bn  MUST be non-empty and SHOULD NOT include a file-extension suffix to indicate the download file type. The  bn , when URL-decoded, MUST be a valid UTF-8 string. The service SHOULD append an appropriate suffix based on the negotiated response content type, e.g.  .json' or .csv`.  As an example:  GET /ermrest/catalog/1/entity/MyTable?download=My%20File  will produce a response like:  200 OK\nContent-Type: application/json\nContent-Length: 3\nContent-Disposition: attachment; download*=UTF-8''My%20File.json\n\n[]  which the browser will interpret to suggest a local filename such as  My File.json .", 
            "title": "Download Query Parameter"
        }, 
        {
            "location": "/api-docs/data/naming/#defaults-query-parameter", 
            "text": "An optional  defaults  query parameter can be used with the  POST  operation on the  entity  API:   service   /catalog/   cid   /entity/   schema name   :   table name   ?defaults=   column name   ,  ...   A list of one or more  column name  indicates columns of the target table which should be populated using server-assigned defaults values, ignoring any values provided by the client. See the  Entity Creation with Defaults  operation documentation for more explanation.", 
            "title": "Defaults Query Parameter"
        }, 
        {
            "location": "/api-docs/data/naming/#limit-query-parameter", 
            "text": "An optional  limit  query parameter can truncate the length of set-based resource representations denoted by  entity ,  attribute , and  attributegroup  resource names:   service   /catalog/   cid   /entity/   path   ?limit=   n  service   /catalog/   cid   /entity/   path   @sort(   sort key   ,  ...  )   ?limit=   n  service   /catalog/   cid   /attribute/   path   /   projection   ,  ...  ?limit=   n  service   /catalog/   cid   /attribute/   path   /   projection   ,  ...  @sort(   sort key   ,  ...  )   ?limit=   n  service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...  ;   projection   ,  ...  ?limit=   n  service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...  ;   projection   ,  ...  @sort(   sort key   ,  ...  )   ?limit=   n   If the set denoted by the resource name (without the limit modifier) has  k  elements, the denoted limited subset will have  n  members if  n     k  and will otherwise have all  k  members. When combined with a sort modifier, the first  n  members will be returned, otherwise an arbitrary subset will be chosen.  The  limit  query parameter is only meaningful on retrieval requests using the  GET  method described in  Data Operations .", 
            "title": "Limit Query Parameter"
        }, 
        {
            "location": "/api-docs/data/naming/#data-paging", 
            "text": "The  sort modifier ,  limit parameter , and  paging modifers  can be combined to express paged access to set-based data resources:   The sort order defines a stable sequence of set elements.  The paging modifiers select set elements following (or preceding) the last-visited element.  The limit parameter defines the number of set elements in the retrieved page.   This allows sequential paging or scrolling of large result sets with reversing/rewind to earlier pages. Because ERMrest supports concurrent retrieval and modification of data resources by multiple clients, it is not sensible to randomly access set elements by stream position offsets (whether by element or page count) because you might skip or repeat elements if preceding elements have been inserted or removed from the sequence in between page requests.   A client can choose an arbitrary application-oriented sort order with paging. However, the client SHOULD include row-level unique key material in the sort and page key to avoid hazards of missing rows that have identical sorting rank due to non-unique page keys. This can be achieved by appending unique key columns to the application sort as the lowest precedence sort criteria, i.e. sort first by an interesting but non-unique property and then finally break ties by a unique serial ID or similar property.   Fetch first page:  service   /catalog/   cid   /entity/   path   @sort(   sort key   ,  ...  )   ?limit=   n  Fetch subsequent page by encoding a page key projected from the  last  row of the preceding page:  service   /catalog/   cid   /entity/   path   @sort(   sort key   ,  ...  )   @after(   limit value   ,  ... )   ?limit=   n  Fetch antecedent page by encoding a page key projected from the  first  row of the subsequent page:  service   /catalog/   cid   /entity/   path   @sort(   sort key   ,  ...  )   @before(   limit value   ,  ... )   ?limit=   n   Realize that a sequence of forward and backward page requests through a dataset might not land on the same page boundaries on both visits!   Rows might be inserted during a traversal. An inserted row MAY appear in the traversal or MAY be skipped depending on where it falls in the sorted sequence.  Rows might be deleted during a traversal. A deleted row MAY appear in the traversal or MAY be skipped depending on where it falls in the sorted sequence.  Rows might be mutated such that they change positions in the sorted sequence during a traversal. A mutated table row contains one tuple of data before the mutation and another tuple of data after. A single traversal concurrent with that mutation MAY encounter zero, one, or two copies of the row depending on where they fall in the sorted sequence.", 
            "title": "Data Paging"
        }, 
        {
            "location": "/api-docs/data/rest/", 
            "text": "ERMrest Data Operations\n\uf0c1\n\n\nThe \nERMrest\n data operations manipulate tabular data structured according to the existing entity-relationship model already configured as schemata resources in the catalog.\n\n\nIn the following examples, we illustrate the use of specific data formats. However, content negotiation allows any of the supported tabular data formats to be used in any request or response involving tabular data.\n\n\nEntity Creation\n\uf0c1\n\n\nThe POST operation is used to create new entity records in a table, using an \nentity\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \ntable name\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \nschema name\n \n:\n \ntable name\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:\n\n\nPOST /ermrest/catalog/42/entity/schema_name:table_name HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nThe input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. It is an error for any existing key in the stored table to match any key in the input data, as this would denote the creation of multiple rows with the same keys.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nEntity Creation with Defaults\n\uf0c1\n\n\nThe POST operation is also used to create new entity records in a table where some values are assigned default values, using an entity resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \ntable name\n \n?defaults=\n \ncolumn name\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \nschema name\n \n:\n \ntable name\n \n?defaults=\n \ncolumn name\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:\n\n\nPOST /ermrest/catalog/42/entity/schema_name:table_name?defaults=column1 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n1,bar\n1,baz\n1,bof\n\n\n\nThe input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. If multiple columns are to be set to defaults, they are provided as a comma-separated list of column names on the right-hand-side of the \naccept=...\n query parameter binding.\n\n\nAll columns should still be present in the input. However, the values for the column (or columns) named in the \ndefaults\n query parameter will be ignored and server-assigned values generated instead. It is an error for any existing key in the stored table to match any key in the input data, as this would denote the creation of multiple rows with the same keys.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n4,foo\n5,bar\n6,baz\n7,bof\n\n\n\nIn this example, a presumed \nserial4\n type used for \ncolumn1\n would lead to a sequence of serial numbers being issued for the default column.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nEntity Update\n\uf0c1\n\n\nThe PUT operation is used to update entity records in a table, using an \nentity\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \ntable name\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \nschema name\n \n:\n \ntable name\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:\n\n\nPUT /ermrest/catalog/42/entity/schema_name:table_name HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nThe input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. Any input row with keys matching an existing stored row will cause an update of non-key columns to match the input row.  Any input row with keys not matching an existing stored row will cause creation of a new row.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nEntity Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve entity records, using an \nentity\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed, for example:\n\n\nGET /ermrest/catalog/42/entity/table1/column1=value1/table2/column2=value2 HTTP/1.1\nHost: www.example.com\nAccept: text/csv\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nEach result row will correspond to an entity in the entity set denoted by \npath\n. This will be a filtered subset of entities from the table instance context of \npath\n considering all filtering and joining criteria.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nEntity Deletion\n\uf0c1\n\n\nThe DELETE operation is used to delete entity records, using an \nentity\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed.\n\n\nDELETE /ermrest/catalog/42/entity/table1/column1=value1/table2/column2=value2 HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 204 No Content\n\n\n\nThe result of the operation is that each of the entity records denoted by \npath\n are deleted from the catalog. This operation only (directly) affects the right-most table instance context of \npath\n. Additional joined entity context may be used to filter the set of affected rows, but none of the contextual table instances are targeted by deletion. However, due to constraints configured in the model, it is possible for a deletion to cause side-effects in another table, e.g. deletion of entities with key values causing foreign key references to those entities to also be processed by a cascading delete or update.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve projected attribute records, using an \nattribute\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \nprojection\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed and projection can draw values from any entity element of \npath\n, for example:\n\n\nGET /ermrest/catalog/42/attribute/A:=table1/column1=value1/table2/column2=value2/x:=A:column1,y:=column3 HTTP/1.1\nHost: www.example.com\nAccept: text/csv\n\n\n\nwhere output column \nx\n is drawn from column \ncolumn1\n of the \ntable1\n table instance aliased with \nA\n, while output column \ny\n is drawn from column \ncolumn3\n of the \ntable2\n table instance context of \npath\n.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\nx,y\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nEach result row will correspond to an entity in the entity set denoted by \npath\n but the result row will be populated with the specified projection values rather than the denoted entity fields. This will be a filtered subset of entities from the table instance context of \npath\n considering all filtering and joining criteria.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Deletion\n\uf0c1\n\n\nThe DELETE operation is used to clear attributes to their default value (usually NULL), using an \nattribute\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \ntarget\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed but only attributes from the \npath\n entity context can be specified as the target for deletion, rather than the generalized projection possible with retrieval.\n\n\nDELETE /ermrest/catalog/42/attribute/table1/column1=value1/table2/column2=value2/column3 HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 204 No Content\n\n\n\nThe result of the operation is that each of the entity records denoted by \npath\n are modified in the catalog, changing their \ntarget\n columns to default value (usually \nNULL\n or whatever default value is configured for that column in the model). This operation only (directly) affects the right-most table instance context of \npath\n. Additional joined entity context may be used to filter the set of affected rows, but none of the contextual table instances are targeted by deletion. However, due to constraints configured in the model, it is possible for a deletion to cause side-effects in another table, e.g. modification of key values causing foreign key references to those entities to also be processed by a cascading update.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Group Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve projected attribute group records, using an \nattributegroup\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \nprojection\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed, for example:\n\n\nGET /ermrest/catalog/42/attributegroup/A:=table1/column1=value1/table2/column2=value2/y:=column3;x:=A:cnt(column1),z:=A:column1 HTTP/1.1\nHost: www.example.com\nAccept: text/csv\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ny,x,z\nfoo,2,1\nbar,1,3\nbaz,1,4\n\n\n\nEach result row will correspond to a distinct \ngroup key\n tuple existing in the joined records denoted by \npath\n and the result row will be populated with the \ngroup key\n tuple and additional \nprojection\n values. Unlike the \nentity\n and \nattribute\n resource spaces which have outputs corresponding to entities in the context of \npath\n, the \nattributegroup\n resource space changes the semantics of \npath\n to denote a permutation set of joined rows based on all the entity-relationship linkages between the elements of \npath\n; this permutation set is further sub-setted by any filters in \npath\n.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Group Update\n\uf0c1\n\n\nThe PUT operation is used to update attributes in a table, using an \nattributegroup\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \ntarget\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are not allowed:\n\n\nPUT /ermrest/catalog/42/attributegroup/table/column1;column2 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nThe input data MUST NOT have more than one row with the same \ngroup key\n tuple of values. Any input row with \ngroup key\n columns matching an existing stored row will cause an update of \ntarget\n columns to match the input row.  Any input row with \ngroup key\n columns not matching an existing stored row will cause an error.\n\n\nOn success, the response contains updated row information:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nTODO: clarify the meaning of this result content.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Group Update with Renaming\n\uf0c1\n\n\nAs with retrieval of attribute groups, update supports renaming of stored columns within the external representation, so that it is even possible to rewrite the key columns as in this example:\n\n\nPUT /ermrest/catalog/42/attributegroup/table1/original:=column1;replacement:=column1 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\noriginal,replacement\nfoo,foo-prime\nbar,bar-prime\nbaz,baz-prime\n\n\n\nHere, the stored rows with \ncolumn1\n matching values in \noriginal\n of the input will have \ncolumn1\n rewritten to the corresponding value in \nreplacement\n.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\noriginal,replacement\nfoo,foo-prime\nbar,bar-prime\nbaz,baz-prime\n\n\n\nAggregate Retrieval\n\uf0c1\n\n\nThe GET operation is used to retrieve projected aggregates, using an \naggregate\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/aggregate/\n \npath\n \n/\n \nprojection\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed, for example:\n\n\nGET /ermrest/catalog/42/aggregate/A:=table1/column1=value1/table2/column2=value2/y:=cnt_d(column2),x:=A:cnt(column1),z:=A:column1 HTTP/1.1\nHost: www.example.com\nAccept: text/csv\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ny,x,z\n3,4,1\n\n\n\nA single result row will summarize the joined records denoted by \npath\n and the result row will be populated with \nprojection\n values. Like the \nattributegroup\n resource space, the \naggregate\n resource space changes the semantics of \npath\n to denote a permutation set of joined rows based on all the entity-relationship linkages between the elements of \npath\n; this permutation set is further sub-setted by any filters in \npath\n and then reduced to a single aggregate summary value by \nprojection\n values using an aggregate function or by choosing an arbitrary example value for \nprojection\n values referencing a bare column.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "ERMrest Data Operations"
        }, 
        {
            "location": "/api-docs/data/rest/#ermrest-data-operations", 
            "text": "The  ERMrest  data operations manipulate tabular data structured according to the existing entity-relationship model already configured as schemata resources in the catalog.  In the following examples, we illustrate the use of specific data formats. However, content negotiation allows any of the supported tabular data formats to be used in any request or response involving tabular data.", 
            "title": "ERMrest Data Operations"
        }, 
        {
            "location": "/api-docs/data/rest/#entity-creation", 
            "text": "The POST operation is used to create new entity records in a table, using an  entity  resource data name of the form:   service   /catalog/   cid   /entity/   table name  service   /catalog/   cid   /entity/   schema name   :   table name   In this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:  POST /ermrest/catalog/42/entity/schema_name:table_name HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  The input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. It is an error for any existing key in the stored table to match any key in the input data, as this would denote the creation of multiple rows with the same keys.  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  Typical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized  Entity Creation with Defaults \uf0c1  The POST operation is also used to create new entity records in a table where some values are assigned default values, using an entity resource data name of the form:   service   /catalog/   cid   /entity/   table name   ?defaults=   column name  service   /catalog/   cid   /entity/   schema name   :   table name   ?defaults=   column name   ,  ...   In this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:  POST /ermrest/catalog/42/entity/schema_name:table_name?defaults=column1 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n1,bar\n1,baz\n1,bof  The input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. If multiple columns are to be set to defaults, they are provided as a comma-separated list of column names on the right-hand-side of the  accept=...  query parameter binding.  All columns should still be present in the input. However, the values for the column (or columns) named in the  defaults  query parameter will be ignored and server-assigned values generated instead. It is an error for any existing key in the stored table to match any key in the input data, as this would denote the creation of multiple rows with the same keys.  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n4,foo\n5,bar\n6,baz\n7,bof  In this example, a presumed  serial4  type used for  column1  would lead to a sequence of serial numbers being issued for the default column.  Typical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Creation"
        }, 
        {
            "location": "/api-docs/data/rest/#entity-update", 
            "text": "The PUT operation is used to update entity records in a table, using an  entity  resource data name of the form:   service   /catalog/   cid   /entity/   table name  service   /catalog/   cid   /entity/   schema name   :   table name   In this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:  PUT /ermrest/catalog/42/entity/schema_name:table_name HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  The input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. Any input row with keys matching an existing stored row will cause an update of non-key columns to match the input row.  Any input row with keys not matching an existing stored row will cause creation of a new row.  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  Typical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Update"
        }, 
        {
            "location": "/api-docs/data/rest/#entity-retrieval", 
            "text": "The GET operation is used to retrieve entity records, using an  entity  resource data name of the form:   service   /catalog/   cid   /entity/   path   In this operation, complex entity paths with filter and linked entity elements are allowed, for example:  GET /ermrest/catalog/42/entity/table1/column1=value1/table2/column2=value2 HTTP/1.1\nHost: www.example.com\nAccept: text/csv  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  Each result row will correspond to an entity in the entity set denoted by  path . This will be a filtered subset of entities from the table instance context of  path  considering all filtering and joining criteria.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Retrieval"
        }, 
        {
            "location": "/api-docs/data/rest/#entity-deletion", 
            "text": "The DELETE operation is used to delete entity records, using an  entity  resource data name of the form:   service   /catalog/   cid   /entity/   path   In this operation, complex entity paths with filter and linked entity elements are allowed.  DELETE /ermrest/catalog/42/entity/table1/column1=value1/table2/column2=value2 HTTP/1.1\nHost: www.example.com  On success, the response is:  HTTP/1.1 204 No Content  The result of the operation is that each of the entity records denoted by  path  are deleted from the catalog. This operation only (directly) affects the right-most table instance context of  path . Additional joined entity context may be used to filter the set of affected rows, but none of the contextual table instances are targeted by deletion. However, due to constraints configured in the model, it is possible for a deletion to cause side-effects in another table, e.g. deletion of entities with key values causing foreign key references to those entities to also be processed by a cascading delete or update.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Deletion"
        }, 
        {
            "location": "/api-docs/data/rest/#attribute-retrieval", 
            "text": "The GET operation is used to retrieve projected attribute records, using an  attribute  resource data name of the form:   service   /catalog/   cid   /attribute/   path   /   projection   ,  ...   In this operation, complex entity paths with filter and linked entity elements are allowed and projection can draw values from any entity element of  path , for example:  GET /ermrest/catalog/42/attribute/A:=table1/column1=value1/table2/column2=value2/x:=A:column1,y:=column3 HTTP/1.1\nHost: www.example.com\nAccept: text/csv  where output column  x  is drawn from column  column1  of the  table1  table instance aliased with  A , while output column  y  is drawn from column  column3  of the  table2  table instance context of  path .  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\nx,y\n1,foo\n2,foo\n3,bar\n4,baz  Each result row will correspond to an entity in the entity set denoted by  path  but the result row will be populated with the specified projection values rather than the denoted entity fields. This will be a filtered subset of entities from the table instance context of  path  considering all filtering and joining criteria.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Attribute Retrieval"
        }, 
        {
            "location": "/api-docs/data/rest/#attribute-deletion", 
            "text": "The DELETE operation is used to clear attributes to their default value (usually NULL), using an  attribute  resource data name of the form:   service   /catalog/   cid   /attribute/   path   /   target   ,  ...   In this operation, complex entity paths with filter and linked entity elements are allowed but only attributes from the  path  entity context can be specified as the target for deletion, rather than the generalized projection possible with retrieval.  DELETE /ermrest/catalog/42/attribute/table1/column1=value1/table2/column2=value2/column3 HTTP/1.1\nHost: www.example.com  On success, the response is:  HTTP/1.1 204 No Content  The result of the operation is that each of the entity records denoted by  path  are modified in the catalog, changing their  target  columns to default value (usually  NULL  or whatever default value is configured for that column in the model). This operation only (directly) affects the right-most table instance context of  path . Additional joined entity context may be used to filter the set of affected rows, but none of the contextual table instances are targeted by deletion. However, due to constraints configured in the model, it is possible for a deletion to cause side-effects in another table, e.g. modification of key values causing foreign key references to those entities to also be processed by a cascading update.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Attribute Deletion"
        }, 
        {
            "location": "/api-docs/data/rest/#attribute-group-retrieval", 
            "text": "The GET operation is used to retrieve projected attribute group records, using an  attributegroup  resource data name of the form:   service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...   service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...  ;   projection   ,  ...   In this operation, complex entity paths with filter and linked entity elements are allowed, for example:  GET /ermrest/catalog/42/attributegroup/A:=table1/column1=value1/table2/column2=value2/y:=column3;x:=A:cnt(column1),z:=A:column1 HTTP/1.1\nHost: www.example.com\nAccept: text/csv  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ny,x,z\nfoo,2,1\nbar,1,3\nbaz,1,4  Each result row will correspond to a distinct  group key  tuple existing in the joined records denoted by  path  and the result row will be populated with the  group key  tuple and additional  projection  values. Unlike the  entity  and  attribute  resource spaces which have outputs corresponding to entities in the context of  path , the  attributegroup  resource space changes the semantics of  path  to denote a permutation set of joined rows based on all the entity-relationship linkages between the elements of  path ; this permutation set is further sub-setted by any filters in  path .  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Attribute Group Retrieval"
        }, 
        {
            "location": "/api-docs/data/rest/#attribute-group-update", 
            "text": "The PUT operation is used to update attributes in a table, using an  attributegroup  resource data name of the form:   service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...  ;   target   ,  ...   In this operation, complex entity paths with filter and linked entity elements are not allowed:  PUT /ermrest/catalog/42/attributegroup/table/column1;column2 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  The input data MUST NOT have more than one row with the same  group key  tuple of values. Any input row with  group key  columns matching an existing stored row will cause an update of  target  columns to match the input row.  Any input row with  group key  columns not matching an existing stored row will cause an error.  On success, the response contains updated row information:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  TODO: clarify the meaning of this result content.  Typical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized  Attribute Group Update with Renaming \uf0c1  As with retrieval of attribute groups, update supports renaming of stored columns within the external representation, so that it is even possible to rewrite the key columns as in this example:  PUT /ermrest/catalog/42/attributegroup/table1/original:=column1;replacement:=column1 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\noriginal,replacement\nfoo,foo-prime\nbar,bar-prime\nbaz,baz-prime  Here, the stored rows with  column1  matching values in  original  of the input will have  column1  rewritten to the corresponding value in  replacement .  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\noriginal,replacement\nfoo,foo-prime\nbar,bar-prime\nbaz,baz-prime", 
            "title": "Attribute Group Update"
        }, 
        {
            "location": "/api-docs/data/rest/#aggregate-retrieval", 
            "text": "The GET operation is used to retrieve projected aggregates, using an  aggregate  resource data name of the form:   service   /catalog/   cid   /aggregate/   path   /   projection   ,  ...   In this operation, complex entity paths with filter and linked entity elements are allowed, for example:  GET /ermrest/catalog/42/aggregate/A:=table1/column1=value1/table2/column2=value2/y:=cnt_d(column2),x:=A:cnt(column1),z:=A:column1 HTTP/1.1\nHost: www.example.com\nAccept: text/csv  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ny,x,z\n3,4,1  A single result row will summarize the joined records denoted by  path  and the result row will be populated with  projection  values. Like the  attributegroup  resource space, the  aggregate  resource space changes the semantics of  path  to denote a permutation set of joined rows based on all the entity-relationship linkages between the elements of  path ; this permutation set is further sub-setted by any filters in  path  and then reduced to a single aggregate summary value by  projection  values using an aggregate function or by choosing an arbitrary example value for  projection  values referencing a bare column.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Aggregate Retrieval"
        }, 
        {
            "location": "/api-docs/rest-catalog/", 
            "text": "ERMrest Catalog Operations\n\uf0c1\n\n\nIn this documentation and examples, the \nservice\n as described in the previous section on \nmodel resource naming\n is assumed to be \nhttps://www.example.com/ermrest\n.\n\n\nCatalog Creation\n\uf0c1\n\n\nThe POST method is used to create an empty catalog:\n\n\nPOST /ermrest/catalog HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields the new catalog identifier, e.g. \n42\n in this example:\n\n\nHTTP/1.1 201 Created\nLocation: /ermrest/catalog/42\nContent-Type: application/json\n\n{\"id\": 42}\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nCatalog Retrieval\n\uf0c1\n\n\nThe GET method is used to get a short description of a catalog:\n\n\nGET /ermrest/catalog/42 HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"id\": \"42\", ...}\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nCatalog Deletion\n\uf0c1\n\n\nThe DELETE method is used to delete a catalog and all its content:\n\n\nDELETE /ermrest/catalog/42 HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAccess Control Lists Retrieval\n\uf0c1\n\n\nThe GET method is used to get a summary of all access control (ACL)\nlists:\n\n\nGET /ermrest/catalog/42/acl HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields the ACL content as an object with one value list for each named ACL:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"owner\": [\"user1\", \"group2\"]\n}\n\n\n\nWhite-space is added above for readability. This legacy representation is likely to change in future revisions.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAccess Control List Retrieval\n\uf0c1\n\n\nThe GET method is used to get a summary of a specific access control (ACL)\nlist (\nowner\n in this example):\n\n\nGET /ermrest/catalog/42/acl/owner HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields the ACL content as a value list:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\"user1\", \"group2\"]\n\n\n\nThis legacy representation is likely to change in future revisions.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "ERMrest Catalog Operations"
        }, 
        {
            "location": "/api-docs/rest-catalog/#ermrest-catalog-operations", 
            "text": "In this documentation and examples, the  service  as described in the previous section on  model resource naming  is assumed to be  https://www.example.com/ermrest .", 
            "title": "ERMrest Catalog Operations"
        }, 
        {
            "location": "/api-docs/rest-catalog/#catalog-creation", 
            "text": "The POST method is used to create an empty catalog:  POST /ermrest/catalog HTTP/1.1\nHost: www.example.com  On success, this request yields the new catalog identifier, e.g.  42  in this example:  HTTP/1.1 201 Created\nLocation: /ermrest/catalog/42\nContent-Type: application/json\n\n{\"id\": 42}  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Catalog Creation"
        }, 
        {
            "location": "/api-docs/rest-catalog/#catalog-retrieval", 
            "text": "The GET method is used to get a short description of a catalog:  GET /ermrest/catalog/42 HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"id\": \"42\", ...}  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Catalog Retrieval"
        }, 
        {
            "location": "/api-docs/rest-catalog/#catalog-deletion", 
            "text": "The DELETE method is used to delete a catalog and all its content:  DELETE /ermrest/catalog/42 HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Catalog Deletion"
        }, 
        {
            "location": "/api-docs/rest-catalog/#access-control-lists-retrieval", 
            "text": "The GET method is used to get a summary of all access control (ACL)\nlists:  GET /ermrest/catalog/42/acl HTTP/1.1\nHost: www.example.com  On success, this request yields the ACL content as an object with one value list for each named ACL:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"owner\": [\"user1\", \"group2\"]\n}  White-space is added above for readability. This legacy representation is likely to change in future revisions.  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Access Control Lists Retrieval"
        }, 
        {
            "location": "/api-docs/rest-catalog/#access-control-list-retrieval", 
            "text": "The GET method is used to get a summary of a specific access control (ACL)\nlist ( owner  in this example):  GET /ermrest/catalog/42/acl/owner HTTP/1.1\nHost: www.example.com  On success, this request yields the ACL content as a value list:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\"user1\", \"group2\"]  This legacy representation is likely to change in future revisions.  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Access Control List Retrieval"
        }
    ]
}